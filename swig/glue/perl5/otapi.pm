# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package otapi;
use base qw(Exporter);
use base qw(DynaLoader);
package otapic;
bootstrap otapi;
package otapi;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package otapi;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package otapi;

*OT_API_Set_PasswordCallback = *otapic::OT_API_Set_PasswordCallback;
*OT_API_Init = *otapic::OT_API_Init;
*OT_API_LoadWallet = *otapic::OT_API_LoadWallet;
*OT_API_SwitchWallet = *otapic::OT_API_SwitchWallet;
*OT_API_Output = *otapic::OT_API_Output;
*OT_API_GetTime = *otapic::OT_API_GetTime;
*OT_API_Encode = *otapic::OT_API_Encode;
*OT_API_Decode = *otapic::OT_API_Decode;
*OT_API_Encrypt = *otapic::OT_API_Encrypt;
*OT_API_Decrypt = *otapic::OT_API_Decrypt;
*OT_API_CreateSymmetricKey = *otapic::OT_API_CreateSymmetricKey;
*OT_API_SymmetricEncrypt = *otapic::OT_API_SymmetricEncrypt;
*OT_API_SymmetricDecrypt = *otapic::OT_API_SymmetricDecrypt;
*OT_API_SignContract = *otapic::OT_API_SignContract;
*OT_API_AddSignature = *otapic::OT_API_AddSignature;
*OT_API_VerifySignature = *otapic::OT_API_VerifySignature;
*OT_API_VerifyAndRetrieveXMLContents = *otapic::OT_API_VerifyAndRetrieveXMLContents;
*OT_API_GetMemlogSize = *otapic::OT_API_GetMemlogSize;
*OT_API_GetMemlogAtIndex = *otapic::OT_API_GetMemlogAtIndex;
*OT_API_PeekMemlogFront = *otapic::OT_API_PeekMemlogFront;
*OT_API_PeekMemlogBack = *otapic::OT_API_PeekMemlogBack;
*OT_API_PopMemlogFront = *otapic::OT_API_PopMemlogFront;
*OT_API_PopMemlogBack = *otapic::OT_API_PopMemlogBack;
*OT_API_CreateNym = *otapic::OT_API_CreateNym;
*OT_API_CreateServerContract = *otapic::OT_API_CreateServerContract;
*OT_API_CreateAssetContract = *otapic::OT_API_CreateAssetContract;
*OT_API_AddServerContract = *otapic::OT_API_AddServerContract;
*OT_API_AddAssetContract = *otapic::OT_API_AddAssetContract;
*OT_API_GetServerCount = *otapic::OT_API_GetServerCount;
*OT_API_GetAssetTypeCount = *otapic::OT_API_GetAssetTypeCount;
*OT_API_GetAccountCount = *otapic::OT_API_GetAccountCount;
*OT_API_GetNymCount = *otapic::OT_API_GetNymCount;
*OT_API_GetServer_ID = *otapic::OT_API_GetServer_ID;
*OT_API_GetServer_Name = *otapic::OT_API_GetServer_Name;
*OT_API_GetServer_Contract = *otapic::OT_API_GetServer_Contract;
*OT_API_GetAssetType_ID = *otapic::OT_API_GetAssetType_ID;
*OT_API_GetAssetType_Name = *otapic::OT_API_GetAssetType_Name;
*OT_API_GetAssetType_Contract = *otapic::OT_API_GetAssetType_Contract;
*OT_API_GetAccountWallet_ID = *otapic::OT_API_GetAccountWallet_ID;
*OT_API_GetAccountWallet_Name = *otapic::OT_API_GetAccountWallet_Name;
*OT_API_GetAccountWallet_Balance = *otapic::OT_API_GetAccountWallet_Balance;
*OT_API_GetAccountWallet_Type = *otapic::OT_API_GetAccountWallet_Type;
*OT_API_GetAccountWallet_AssetTypeID = *otapic::OT_API_GetAccountWallet_AssetTypeID;
*OT_API_GetAccountWallet_ServerID = *otapic::OT_API_GetAccountWallet_ServerID;
*OT_API_GetAccountWallet_NymID = *otapic::OT_API_GetAccountWallet_NymID;
*OT_API_GetAccountWallet_InboxHash = *otapic::OT_API_GetAccountWallet_InboxHash;
*OT_API_GetAccountWallet_OutboxHash = *otapic::OT_API_GetAccountWallet_OutboxHash;
*OT_API_VerifyAccountReceipt = *otapic::OT_API_VerifyAccountReceipt;
*OT_API_GetNym_TransactionNumCount = *otapic::OT_API_GetNym_TransactionNumCount;
*OT_API_GetNym_ID = *otapic::OT_API_GetNym_ID;
*OT_API_GetNym_Name = *otapic::OT_API_GetNym_Name;
*OT_API_GetNym_Stats = *otapic::OT_API_GetNym_Stats;
*OT_API_GetNym_NymboxHash = *otapic::OT_API_GetNym_NymboxHash;
*OT_API_GetNym_RecentHash = *otapic::OT_API_GetNym_RecentHash;
*OT_API_GetNym_InboxHash = *otapic::OT_API_GetNym_InboxHash;
*OT_API_GetNym_OutboxHash = *otapic::OT_API_GetNym_OutboxHash;
*OT_API_IsNym_RegisteredAtServer = *otapic::OT_API_IsNym_RegisteredAtServer;
*OT_API_GetNym_MailCount = *otapic::OT_API_GetNym_MailCount;
*OT_API_GetNym_MailContentsByIndex = *otapic::OT_API_GetNym_MailContentsByIndex;
*OT_API_GetNym_MailSenderIDByIndex = *otapic::OT_API_GetNym_MailSenderIDByIndex;
*OT_API_GetNym_MailServerIDByIndex = *otapic::OT_API_GetNym_MailServerIDByIndex;
*OT_API_Nym_RemoveMailByIndex = *otapic::OT_API_Nym_RemoveMailByIndex;
*OT_API_Nym_VerifyMailByIndex = *otapic::OT_API_Nym_VerifyMailByIndex;
*OT_API_GetNym_OutmailCount = *otapic::OT_API_GetNym_OutmailCount;
*OT_API_GetNym_OutmailContentsByIndex = *otapic::OT_API_GetNym_OutmailContentsByIndex;
*OT_API_GetNym_OutmailRecipientIDByIndex = *otapic::OT_API_GetNym_OutmailRecipientIDByIndex;
*OT_API_GetNym_OutmailServerIDByIndex = *otapic::OT_API_GetNym_OutmailServerIDByIndex;
*OT_API_Nym_RemoveOutmailByIndex = *otapic::OT_API_Nym_RemoveOutmailByIndex;
*OT_API_Nym_VerifyOutmailByIndex = *otapic::OT_API_Nym_VerifyOutmailByIndex;
*OT_API_GetNym_OutpaymentsCount = *otapic::OT_API_GetNym_OutpaymentsCount;
*OT_API_GetNym_OutpaymentsContentsByIndex = *otapic::OT_API_GetNym_OutpaymentsContentsByIndex;
*OT_API_GetNym_OutpaymentsRecipientIDByIndex = *otapic::OT_API_GetNym_OutpaymentsRecipientIDByIndex;
*OT_API_GetNym_OutpaymentsServerIDByIndex = *otapic::OT_API_GetNym_OutpaymentsServerIDByIndex;
*OT_API_Nym_RemoveOutpaymentsByIndex = *otapic::OT_API_Nym_RemoveOutpaymentsByIndex;
*OT_API_Nym_VerifyOutpaymentsByIndex = *otapic::OT_API_Nym_VerifyOutpaymentsByIndex;
*OT_API_Wallet_CanRemoveServer = *otapic::OT_API_Wallet_CanRemoveServer;
*OT_API_Wallet_RemoveServer = *otapic::OT_API_Wallet_RemoveServer;
*OT_API_Wallet_CanRemoveAssetType = *otapic::OT_API_Wallet_CanRemoveAssetType;
*OT_API_Wallet_RemoveAssetType = *otapic::OT_API_Wallet_RemoveAssetType;
*OT_API_Wallet_CanRemoveNym = *otapic::OT_API_Wallet_CanRemoveNym;
*OT_API_Wallet_RemoveNym = *otapic::OT_API_Wallet_RemoveNym;
*OT_API_Wallet_CanRemoveAccount = *otapic::OT_API_Wallet_CanRemoveAccount;
*OT_API_Wallet_ImportNym = *otapic::OT_API_Wallet_ImportNym;
*OT_API_SetNym_Name = *otapic::OT_API_SetNym_Name;
*OT_API_SetAccountWallet_Name = *otapic::OT_API_SetAccountWallet_Name;
*OT_API_SetAssetType_Name = *otapic::OT_API_SetAssetType_Name;
*OT_API_SetServer_Name = *otapic::OT_API_SetServer_Name;
*OT_API_WriteCheque = *otapic::OT_API_WriteCheque;
*OT_API_DiscardCheque = *otapic::OT_API_DiscardCheque;
*OT_API_ProposePaymentPlan = *otapic::OT_API_ProposePaymentPlan;
*OT_API_ConfirmPaymentPlan = *otapic::OT_API_ConfirmPaymentPlan;
*OT_API_Create_SmartContract = *otapic::OT_API_Create_SmartContract;
*OT_API_SmartContract_AddBylaw = *otapic::OT_API_SmartContract_AddBylaw;
*OT_API_SmartContract_AddClause = *otapic::OT_API_SmartContract_AddClause;
*OT_API_SmartContract_AddVariable = *otapic::OT_API_SmartContract_AddVariable;
*OT_API_SmartContract_AddCallback = *otapic::OT_API_SmartContract_AddCallback;
*OT_API_SmartContract_AddHook = *otapic::OT_API_SmartContract_AddHook;
*OT_API_SmartContract_AddParty = *otapic::OT_API_SmartContract_AddParty;
*OT_API_SmartContract_AddAccount = *otapic::OT_API_SmartContract_AddAccount;
*OT_API_SmartContract_CountNumsNeeded = *otapic::OT_API_SmartContract_CountNumsNeeded;
*OT_API_SmartContract_ConfirmAccount = *otapic::OT_API_SmartContract_ConfirmAccount;
*OT_API_SmartContract_ConfirmParty = *otapic::OT_API_SmartContract_ConfirmParty;
*OT_API_activateSmartContract = *otapic::OT_API_activateSmartContract;
*OT_API_triggerClause = *otapic::OT_API_triggerClause;
*OT_API_Msg_HarvestTransactionNumbers = *otapic::OT_API_Msg_HarvestTransactionNumbers;
*OT_API_LoadUserPubkey = *otapic::OT_API_LoadUserPubkey;
*OT_API_LoadPubkey = *otapic::OT_API_LoadPubkey;
*OT_API_VerifyUserPrivateKey = *otapic::OT_API_VerifyUserPrivateKey;
*OT_API_LoadPurse = *otapic::OT_API_LoadPurse;
*OT_API_LoadMint = *otapic::OT_API_LoadMint;
*OT_API_LoadAssetContract = *otapic::OT_API_LoadAssetContract;
*OT_API_LoadServerContract = *otapic::OT_API_LoadServerContract;
*OT_API_Mint_IsStillGood = *otapic::OT_API_Mint_IsStillGood;
*OT_API_IsBasketCurrency = *otapic::OT_API_IsBasketCurrency;
*OT_API_Basket_GetMemberCount = *otapic::OT_API_Basket_GetMemberCount;
*OT_API_Basket_GetMemberType = *otapic::OT_API_Basket_GetMemberType;
*OT_API_Basket_GetMinimumTransferAmount = *otapic::OT_API_Basket_GetMinimumTransferAmount;
*OT_API_Basket_GetMemberMinimumTransferAmount = *otapic::OT_API_Basket_GetMemberMinimumTransferAmount;
*OT_API_LoadAssetAccount = *otapic::OT_API_LoadAssetAccount;
*OT_API_LoadInbox = *otapic::OT_API_LoadInbox;
*OT_API_LoadOutbox = *otapic::OT_API_LoadOutbox;
*OT_API_LoadInboxNoVerify = *otapic::OT_API_LoadInboxNoVerify;
*OT_API_LoadOutboxNoVerify = *otapic::OT_API_LoadOutboxNoVerify;
*OT_API_LoadPaymentInbox = *otapic::OT_API_LoadPaymentInbox;
*OT_API_LoadPaymentInboxNoVerify = *otapic::OT_API_LoadPaymentInboxNoVerify;
*OT_API_LoadRecordBox = *otapic::OT_API_LoadRecordBox;
*OT_API_LoadRecordBoxNoVerify = *otapic::OT_API_LoadRecordBoxNoVerify;
*OT_API_Ledger_GetCount = *otapic::OT_API_Ledger_GetCount;
*OT_API_Ledger_CreateResponse = *otapic::OT_API_Ledger_CreateResponse;
*OT_API_Ledger_GetTransactionByIndex = *otapic::OT_API_Ledger_GetTransactionByIndex;
*OT_API_Ledger_GetTransactionByID = *otapic::OT_API_Ledger_GetTransactionByID;
*OT_API_Ledger_GetTransactionIDByIndex = *otapic::OT_API_Ledger_GetTransactionIDByIndex;
*OT_API_Ledger_AddTransaction = *otapic::OT_API_Ledger_AddTransaction;
*OT_API_Transaction_CreateResponse = *otapic::OT_API_Transaction_CreateResponse;
*OT_API_Ledger_FinalizeResponse = *otapic::OT_API_Ledger_FinalizeResponse;
*OT_API_Ledger_GetInstrument = *otapic::OT_API_Ledger_GetInstrument;
*OT_API_Transaction_GetType = *otapic::OT_API_Transaction_GetType;
*OT_API_ReplyNotice_GetRequestNum = *otapic::OT_API_ReplyNotice_GetRequestNum;
*OT_API_Transaction_GetVoucher = *otapic::OT_API_Transaction_GetVoucher;
*OT_API_Transaction_GetSuccess = *otapic::OT_API_Transaction_GetSuccess;
*OT_API_Transaction_GetBalanceAgreementSuccess = *otapic::OT_API_Transaction_GetBalanceAgreementSuccess;
*OT_API_Transaction_GetDateSigned = *otapic::OT_API_Transaction_GetDateSigned;
*OT_API_Transaction_GetAmount = *otapic::OT_API_Transaction_GetAmount;
*OT_API_Pending_GetNote = *otapic::OT_API_Pending_GetNote;
*OT_API_Transaction_GetSenderUserID = *otapic::OT_API_Transaction_GetSenderUserID;
*OT_API_Transaction_GetSenderAcctID = *otapic::OT_API_Transaction_GetSenderAcctID;
*OT_API_Transaction_GetRecipientUserID = *otapic::OT_API_Transaction_GetRecipientUserID;
*OT_API_Transaction_GetRecipientAcctID = *otapic::OT_API_Transaction_GetRecipientAcctID;
*OT_API_Transaction_GetDisplayReferenceToNum = *otapic::OT_API_Transaction_GetDisplayReferenceToNum;
*OT_API_CreatePurse = *otapic::OT_API_CreatePurse;
*OT_API_SavePurse = *otapic::OT_API_SavePurse;
*OT_API_Purse_GetTotalValue = *otapic::OT_API_Purse_GetTotalValue;
*OT_API_Purse_Count = *otapic::OT_API_Purse_Count;
*OT_API_Purse_Peek = *otapic::OT_API_Purse_Peek;
*OT_API_Purse_Pop = *otapic::OT_API_Purse_Pop;
*OT_API_Purse_Push = *otapic::OT_API_Purse_Push;
*OT_API_Wallet_ImportPurse = *otapic::OT_API_Wallet_ImportPurse;
*OT_API_exchangePurse = *otapic::OT_API_exchangePurse;
*OT_API_Token_ChangeOwner = *otapic::OT_API_Token_ChangeOwner;
*OT_API_Token_GetID = *otapic::OT_API_Token_GetID;
*OT_API_Token_GetDenomination = *otapic::OT_API_Token_GetDenomination;
*OT_API_Token_GetSeries = *otapic::OT_API_Token_GetSeries;
*OT_API_Token_GetValidFrom = *otapic::OT_API_Token_GetValidFrom;
*OT_API_Token_GetValidTo = *otapic::OT_API_Token_GetValidTo;
*OT_API_Token_GetAssetID = *otapic::OT_API_Token_GetAssetID;
*OT_API_Token_GetServerID = *otapic::OT_API_Token_GetServerID;
*OT_API_Instrument_GetAmount = *otapic::OT_API_Instrument_GetAmount;
*OT_API_Instrument_GetTransNum = *otapic::OT_API_Instrument_GetTransNum;
*OT_API_Instrument_GetValidFrom = *otapic::OT_API_Instrument_GetValidFrom;
*OT_API_Instrument_GetValidTo = *otapic::OT_API_Instrument_GetValidTo;
*OT_API_Instrument_GetMemo = *otapic::OT_API_Instrument_GetMemo;
*OT_API_Instrument_GetAssetID = *otapic::OT_API_Instrument_GetAssetID;
*OT_API_Instrmnt_GetSenderUserID = *otapic::OT_API_Instrmnt_GetSenderUserID;
*OT_API_Instrmnt_GetSenderAcctID = *otapic::OT_API_Instrmnt_GetSenderAcctID;
*OT_API_Instrmnt_GetRecipientUserID = *otapic::OT_API_Instrmnt_GetRecipientUserID;
*OT_API_Instrmnt_GetRecipientAcctID = *otapic::OT_API_Instrmnt_GetRecipientAcctID;
*OT_API_checkServerID = *otapic::OT_API_checkServerID;
*OT_API_createUserAccount = *otapic::OT_API_createUserAccount;
*OT_API_deleteUserAccount = *otapic::OT_API_deleteUserAccount;
*OT_API_deleteAssetAccount = *otapic::OT_API_deleteAssetAccount;
*OT_API_usageCredits = *otapic::OT_API_usageCredits;
*OT_API_Message_GetUsageCredits = *otapic::OT_API_Message_GetUsageCredits;
*OT_API_checkUser = *otapic::OT_API_checkUser;
*OT_API_sendUserMessage = *otapic::OT_API_sendUserMessage;
*OT_API_sendUserInstrument = *otapic::OT_API_sendUserInstrument;
*OT_API_getRequest = *otapic::OT_API_getRequest;
*OT_API_getTransactionNumber = *otapic::OT_API_getTransactionNumber;
*OT_API_issueAssetType = *otapic::OT_API_issueAssetType;
*OT_API_getContract = *otapic::OT_API_getContract;
*OT_API_getMint = *otapic::OT_API_getMint;
*OT_API_createAssetAccount = *otapic::OT_API_createAssetAccount;
*OT_API_getAccount = *otapic::OT_API_getAccount;
*OT_API_GenerateBasketCreation = *otapic::OT_API_GenerateBasketCreation;
*OT_API_AddBasketCreationItem = *otapic::OT_API_AddBasketCreationItem;
*OT_API_issueBasket = *otapic::OT_API_issueBasket;
*OT_API_GenerateBasketExchange = *otapic::OT_API_GenerateBasketExchange;
*OT_API_AddBasketExchangeItem = *otapic::OT_API_AddBasketExchangeItem;
*OT_API_exchangeBasket = *otapic::OT_API_exchangeBasket;
*OT_API_notarizeWithdrawal = *otapic::OT_API_notarizeWithdrawal;
*OT_API_notarizeDeposit = *otapic::OT_API_notarizeDeposit;
*OT_API_notarizeTransfer = *otapic::OT_API_notarizeTransfer;
*OT_API_getInbox = *otapic::OT_API_getInbox;
*OT_API_getOutbox = *otapic::OT_API_getOutbox;
*OT_API_getNymbox = *otapic::OT_API_getNymbox;
*OT_API_LoadNymbox = *otapic::OT_API_LoadNymbox;
*OT_API_LoadNymboxNoVerify = *otapic::OT_API_LoadNymboxNoVerify;
*OT_API_Nymbox_GetReplyNotice = *otapic::OT_API_Nymbox_GetReplyNotice;
*OT_API_HaveAlreadySeenReply = *otapic::OT_API_HaveAlreadySeenReply;
*OT_API_getBoxReceipt = *otapic::OT_API_getBoxReceipt;
*OT_API_DoesBoxReceiptExist = *otapic::OT_API_DoesBoxReceiptExist;
*OT_API_processInbox = *otapic::OT_API_processInbox;
*OT_API_processNymbox = *otapic::OT_API_processNymbox;
*OT_API_withdrawVoucher = *otapic::OT_API_withdrawVoucher;
*OT_API_depositCheque = *otapic::OT_API_depositCheque;
*OT_API_depositPaymentPlan = *otapic::OT_API_depositPaymentPlan;
*OT_API_issueMarketOffer = *otapic::OT_API_issueMarketOffer;
*OT_API_getMarketList = *otapic::OT_API_getMarketList;
*OT_API_getMarketOffers = *otapic::OT_API_getMarketOffers;
*OT_API_getMarketRecentTrades = *otapic::OT_API_getMarketRecentTrades;
*OT_API_getNym_MarketOffers = *otapic::OT_API_getNym_MarketOffers;
*OT_API_cancelMarketOffer = *otapic::OT_API_cancelMarketOffer;
*OT_API_cancelPaymentPlan = *otapic::OT_API_cancelPaymentPlan;
*OT_API_PopMessageBuffer = *otapic::OT_API_PopMessageBuffer;
*OT_API_FlushMessageBuffer = *otapic::OT_API_FlushMessageBuffer;
*OT_API_GetSentMessage = *otapic::OT_API_GetSentMessage;
*OT_API_RemoveSentMessage = *otapic::OT_API_RemoveSentMessage;
*OT_API_FlushSentMessages = *otapic::OT_API_FlushSentMessages;
*OT_API_Sleep = *otapic::OT_API_Sleep;
*OT_API_ResyncNymWithServer = *otapic::OT_API_ResyncNymWithServer;
*OT_API_Message_GetCommand = *otapic::OT_API_Message_GetCommand;
*OT_API_Message_GetSuccess = *otapic::OT_API_Message_GetSuccess;
*OT_API_queryAssetTypes = *otapic::OT_API_queryAssetTypes;
*OT_API_Message_GetPayload = *otapic::OT_API_Message_GetPayload;
*OT_API_Message_GetDepth = *otapic::OT_API_Message_GetDepth;
*OT_API_Message_GetTransactionSuccess = *otapic::OT_API_Message_GetTransactionSuccess;
*OT_API_Message_GetBalanceAgreementSuccess = *otapic::OT_API_Message_GetBalanceAgreementSuccess;
*OT_API_Message_GetLedger = *otapic::OT_API_Message_GetLedger;
*OT_API_Message_GetNewAssetTypeID = *otapic::OT_API_Message_GetNewAssetTypeID;
*OT_API_Message_GetNewIssuerAcctID = *otapic::OT_API_Message_GetNewIssuerAcctID;
*OT_API_Message_GetNewAcctID = *otapic::OT_API_Message_GetNewAcctID;
*OT_API_Message_GetNymboxHash = *otapic::OT_API_Message_GetNymboxHash;
*OT_API_ConnectServer = *otapic::OT_API_ConnectServer;
*OT_API_ProcessSockets = *otapic::OT_API_ProcessSockets;
*InitDefaultStorage = *otapic::InitDefaultStorage;
*GetDefaultStorage = *otapic::GetDefaultStorage;
*CreateStorageContext = *otapic::CreateStorageContext;
*CreateObject = *otapic::CreateObject;
*Exists = *otapic::Exists;
*StoreString = *otapic::StoreString;
*QueryString = *otapic::QueryString;
*StorePlainString = *otapic::StorePlainString;
*QueryPlainString = *otapic::QueryPlainString;
*StoreObject = *otapic::StoreObject;
*QueryObject = *otapic::QueryObject;
*EncodeObject = *otapic::EncodeObject;
*DecodeObject = *otapic::DecodeObject;
*EraseValueByKey = *otapic::EraseValueByKey;

############# Class : otapi::OTPasswordData ##############

package otapi::OTPasswordData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
*isForNormalNym = *otapic::OTPasswordData_isForNormalNym;
*isForMasterKey = *otapic::OTPasswordData_isForMasterKey;
*GetDisplayString = *otapic::OTPasswordData_GetDisplayString;
*isUsingOldSystem = *otapic::OTPasswordData_isUsingOldSystem;
*setUsingOldSystem = *otapic::OTPasswordData_setUsingOldSystem;
*GetMasterPW = *otapic::OTPasswordData_GetMasterPW;
sub new {
    my $pkg = shift;
    my $self = otapic::new_OTPasswordData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OTPasswordData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OTPassword ##############

package otapi::OTPassword;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
*DEFAULT_SIZE = *otapic::OTPassword_DEFAULT_SIZE;
*LARGER_SIZE = *otapic::OTPassword_LARGER_SIZE;
*swig_m_theBlockSize_get = *otapic::OTPassword_m_theBlockSize_get;
*swig_m_theBlockSize_set = *otapic::OTPassword_m_theBlockSize_set;
*isPassword = *otapic::OTPassword_isPassword;
*getPassword_uint8 = *otapic::OTPassword_getPassword_uint8;
*getPassword = *otapic::OTPassword_getPassword;
*getPasswordWritable = *otapic::OTPassword_getPasswordWritable;
*getPasswordWritable_char = *otapic::OTPassword_getPasswordWritable_char;
*setPassword = *otapic::OTPassword_setPassword;
*setPassword_uint8 = *otapic::OTPassword_setPassword_uint8;
*addChar = *otapic::OTPassword_addChar;
*randomizePassword_uint8 = *otapic::OTPassword_randomizePassword_uint8;
*randomizePassword = *otapic::OTPassword_randomizePassword;
*isMemory = *otapic::OTPassword_isMemory;
*getMemory = *otapic::OTPassword_getMemory;
*getMemory_uint8 = *otapic::OTPassword_getMemory_uint8;
*getMemoryWritable = *otapic::OTPassword_getMemoryWritable;
*setMemory = *otapic::OTPassword_setMemory;
*addMemory = *otapic::OTPassword_addMemory;
*randomizeMemory_uint8 = *otapic::OTPassword_randomizeMemory_uint8;
*randomizeMemory = *otapic::OTPassword_randomizeMemory;
*getBlockSize = *otapic::OTPassword_getBlockSize;
*Compare = *otapic::OTPassword_Compare;
*getPasswordSize = *otapic::OTPassword_getPasswordSize;
*getMemorySize = *otapic::OTPassword_getMemorySize;
*zeroMemory = *otapic::OTPassword_zeroMemory;
*safe_memcpy = *otapic::OTPassword_safe_memcpy;
sub new {
    my $pkg = shift;
    my $self = otapic::new_OTPassword(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OTPassword($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OTCallback ##############

package otapi::OTCallback;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = otapic::new_OTCallback(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OTCallback($self);
        delete $OWNER{$self};
    }
}

*runOne = *otapic::OTCallback_runOne;
*runTwo = *otapic::OTCallback_runTwo;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OTCaller ##############

package otapi::OTCaller;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = otapic::new_OTCaller(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OTCaller($self);
        delete $OWNER{$self};
    }
}

*GetPassword = *otapic::OTCaller_GetPassword;
*ZeroOutPassword = *otapic::OTCaller_ZeroOutPassword;
*GetDisplay = *otapic::OTCaller_GetDisplay;
*SetDisplay = *otapic::OTCaller_SetDisplay;
*delCallback = *otapic::OTCaller_delCallback;
*setCallback = *otapic::OTCaller_setCallback;
*isCallbackSet = *otapic::OTCaller_isCallbackSet;
*callOne = *otapic::OTCaller_callOne;
*callTwo = *otapic::OTCaller_callTwo;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::Storable ##############

package otapi::Storable;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_Storable($self);
        delete $OWNER{$self};
    }
}

*Create = *otapic::Storable_Create;
*ot_dynamic_cast = *otapic::Storable_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::Storage ##############

package otapi::Storage;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
*GetPacker = *otapic::Storage_GetPacker;
*Init = *otapic::Storage_Init;
*Exists = *otapic::Storage_Exists;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_Storage($self);
        delete $OWNER{$self};
    }
}

*StoreString = *otapic::Storage_StoreString;
*QueryString = *otapic::Storage_QueryString;
*StorePlainString = *otapic::Storage_StorePlainString;
*QueryPlainString = *otapic::Storage_QueryPlainString;
*StoreObject = *otapic::Storage_StoreObject;
*QueryObject = *otapic::Storage_QueryObject;
*EncodeObject = *otapic::Storage_EncodeObject;
*DecodeObject = *otapic::Storage_DecodeObject;
*EraseValueByKey = *otapic::Storage_EraseValueByKey;
*CreateObject = *otapic::Storage_CreateObject;
*Create = *otapic::Storage_Create;
*GetType = *otapic::Storage_GetType;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OTDBString ##############

package otapi::OTDBString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OTDBString($self);
        delete $OWNER{$self};
    }
}

*swig_m_string_get = *otapic::OTDBString_m_string_get;
*swig_m_string_set = *otapic::OTDBString_m_string_set;
*ot_dynamic_cast = *otapic::OTDBString_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::Blob ##############

package otapi::Blob;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_Blob($self);
        delete $OWNER{$self};
    }
}

*swig_m_memBuffer_get = *otapic::Blob_m_memBuffer_get;
*swig_m_memBuffer_set = *otapic::Blob_m_memBuffer_set;
*ot_dynamic_cast = *otapic::Blob_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::StringMap ##############

package otapi::StringMap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_StringMap($self);
        delete $OWNER{$self};
    }
}

*swig_the_map_get = *otapic::StringMap_the_map_get;
*swig_the_map_set = *otapic::StringMap_the_map_set;
*SetValue = *otapic::StringMap_SetValue;
*GetValue = *otapic::StringMap_GetValue;
*ot_dynamic_cast = *otapic::StringMap_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::Displayable ##############

package otapi::Displayable;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_Displayable($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::Displayable_gui_label_get;
*swig_gui_label_set = *otapic::Displayable_gui_label_set;
*ot_dynamic_cast = *otapic::Displayable_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::MarketData ##############

package otapi::MarketData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_MarketData($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::MarketData_gui_label_get;
*swig_gui_label_set = *otapic::MarketData_gui_label_set;
*swig_server_id_get = *otapic::MarketData_server_id_get;
*swig_server_id_set = *otapic::MarketData_server_id_set;
*swig_market_id_get = *otapic::MarketData_market_id_get;
*swig_market_id_set = *otapic::MarketData_market_id_set;
*swig_asset_type_id_get = *otapic::MarketData_asset_type_id_get;
*swig_asset_type_id_set = *otapic::MarketData_asset_type_id_set;
*swig_currency_type_id_get = *otapic::MarketData_currency_type_id_get;
*swig_currency_type_id_set = *otapic::MarketData_currency_type_id_set;
*swig_scale_get = *otapic::MarketData_scale_get;
*swig_scale_set = *otapic::MarketData_scale_set;
*swig_total_assets_get = *otapic::MarketData_total_assets_get;
*swig_total_assets_set = *otapic::MarketData_total_assets_set;
*swig_number_bids_get = *otapic::MarketData_number_bids_get;
*swig_number_bids_set = *otapic::MarketData_number_bids_set;
*swig_number_asks_get = *otapic::MarketData_number_asks_get;
*swig_number_asks_set = *otapic::MarketData_number_asks_set;
*swig_last_sale_price_get = *otapic::MarketData_last_sale_price_get;
*swig_last_sale_price_set = *otapic::MarketData_last_sale_price_set;
*swig_current_bid_get = *otapic::MarketData_current_bid_get;
*swig_current_bid_set = *otapic::MarketData_current_bid_set;
*swig_current_ask_get = *otapic::MarketData_current_ask_get;
*swig_current_ask_set = *otapic::MarketData_current_ask_set;
*swig_volume_trades_get = *otapic::MarketData_volume_trades_get;
*swig_volume_trades_set = *otapic::MarketData_volume_trades_set;
*swig_volume_assets_get = *otapic::MarketData_volume_assets_get;
*swig_volume_assets_set = *otapic::MarketData_volume_assets_set;
*swig_volume_currency_get = *otapic::MarketData_volume_currency_get;
*swig_volume_currency_set = *otapic::MarketData_volume_currency_set;
*swig_recent_highest_bid_get = *otapic::MarketData_recent_highest_bid_get;
*swig_recent_highest_bid_set = *otapic::MarketData_recent_highest_bid_set;
*swig_recent_lowest_ask_get = *otapic::MarketData_recent_lowest_ask_get;
*swig_recent_lowest_ask_set = *otapic::MarketData_recent_lowest_ask_set;
*ot_dynamic_cast = *otapic::MarketData_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::MarketList ##############

package otapi::MarketList;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_MarketList($self);
        delete $OWNER{$self};
    }
}

*GetMarketDataCount = *otapic::MarketList_GetMarketDataCount;
*GetMarketData = *otapic::MarketList_GetMarketData;
*RemoveMarketData = *otapic::MarketList_RemoveMarketData;
*AddMarketData = *otapic::MarketList_AddMarketData;
*ot_dynamic_cast = *otapic::MarketList_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OfferDataMarket ##############

package otapi::OfferDataMarket;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OfferDataMarket($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::OfferDataMarket_gui_label_get;
*swig_gui_label_set = *otapic::OfferDataMarket_gui_label_set;
*swig_transaction_id_get = *otapic::OfferDataMarket_transaction_id_get;
*swig_transaction_id_set = *otapic::OfferDataMarket_transaction_id_set;
*swig_price_per_scale_get = *otapic::OfferDataMarket_price_per_scale_get;
*swig_price_per_scale_set = *otapic::OfferDataMarket_price_per_scale_set;
*swig_available_assets_get = *otapic::OfferDataMarket_available_assets_get;
*swig_available_assets_set = *otapic::OfferDataMarket_available_assets_set;
*swig_minimum_increment_get = *otapic::OfferDataMarket_minimum_increment_get;
*swig_minimum_increment_set = *otapic::OfferDataMarket_minimum_increment_set;
*ot_dynamic_cast = *otapic::OfferDataMarket_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::BidData ##############

package otapi::BidData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::OfferDataMarket otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_BidData($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::BidData_gui_label_get;
*swig_gui_label_set = *otapic::BidData_gui_label_set;
*swig_transaction_id_get = *otapic::BidData_transaction_id_get;
*swig_transaction_id_set = *otapic::BidData_transaction_id_set;
*swig_price_per_scale_get = *otapic::BidData_price_per_scale_get;
*swig_price_per_scale_set = *otapic::BidData_price_per_scale_set;
*swig_available_assets_get = *otapic::BidData_available_assets_get;
*swig_available_assets_set = *otapic::BidData_available_assets_set;
*swig_minimum_increment_get = *otapic::BidData_minimum_increment_get;
*swig_minimum_increment_set = *otapic::BidData_minimum_increment_set;
*ot_dynamic_cast = *otapic::BidData_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::AskData ##############

package otapi::AskData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::OfferDataMarket otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_AskData($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::AskData_gui_label_get;
*swig_gui_label_set = *otapic::AskData_gui_label_set;
*swig_transaction_id_get = *otapic::AskData_transaction_id_get;
*swig_transaction_id_set = *otapic::AskData_transaction_id_set;
*swig_price_per_scale_get = *otapic::AskData_price_per_scale_get;
*swig_price_per_scale_set = *otapic::AskData_price_per_scale_set;
*swig_available_assets_get = *otapic::AskData_available_assets_get;
*swig_available_assets_set = *otapic::AskData_available_assets_set;
*swig_minimum_increment_get = *otapic::AskData_minimum_increment_get;
*swig_minimum_increment_set = *otapic::AskData_minimum_increment_set;
*ot_dynamic_cast = *otapic::AskData_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OfferListMarket ##############

package otapi::OfferListMarket;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OfferListMarket($self);
        delete $OWNER{$self};
    }
}

*GetBidDataCount = *otapic::OfferListMarket_GetBidDataCount;
*GetBidData = *otapic::OfferListMarket_GetBidData;
*RemoveBidData = *otapic::OfferListMarket_RemoveBidData;
*AddBidData = *otapic::OfferListMarket_AddBidData;
*GetAskDataCount = *otapic::OfferListMarket_GetAskDataCount;
*GetAskData = *otapic::OfferListMarket_GetAskData;
*RemoveAskData = *otapic::OfferListMarket_RemoveAskData;
*AddAskData = *otapic::OfferListMarket_AddAskData;
*ot_dynamic_cast = *otapic::OfferListMarket_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::TradeDataMarket ##############

package otapi::TradeDataMarket;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_TradeDataMarket($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::TradeDataMarket_gui_label_get;
*swig_gui_label_set = *otapic::TradeDataMarket_gui_label_set;
*swig_transaction_id_get = *otapic::TradeDataMarket_transaction_id_get;
*swig_transaction_id_set = *otapic::TradeDataMarket_transaction_id_set;
*swig_date_get = *otapic::TradeDataMarket_date_get;
*swig_date_set = *otapic::TradeDataMarket_date_set;
*swig_price_get = *otapic::TradeDataMarket_price_get;
*swig_price_set = *otapic::TradeDataMarket_price_set;
*swig_amount_sold_get = *otapic::TradeDataMarket_amount_sold_get;
*swig_amount_sold_set = *otapic::TradeDataMarket_amount_sold_set;
*ot_dynamic_cast = *otapic::TradeDataMarket_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::TradeListMarket ##############

package otapi::TradeListMarket;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_TradeListMarket($self);
        delete $OWNER{$self};
    }
}

*GetTradeDataMarketCount = *otapic::TradeListMarket_GetTradeDataMarketCount;
*GetTradeDataMarket = *otapic::TradeListMarket_GetTradeDataMarket;
*RemoveTradeDataMarket = *otapic::TradeListMarket_RemoveTradeDataMarket;
*AddTradeDataMarket = *otapic::TradeListMarket_AddTradeDataMarket;
*ot_dynamic_cast = *otapic::TradeListMarket_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OfferDataNym ##############

package otapi::OfferDataNym;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OfferDataNym($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::OfferDataNym_gui_label_get;
*swig_gui_label_set = *otapic::OfferDataNym_gui_label_set;
*swig_valid_from_get = *otapic::OfferDataNym_valid_from_get;
*swig_valid_from_set = *otapic::OfferDataNym_valid_from_set;
*swig_valid_to_get = *otapic::OfferDataNym_valid_to_get;
*swig_valid_to_set = *otapic::OfferDataNym_valid_to_set;
*swig_server_id_get = *otapic::OfferDataNym_server_id_get;
*swig_server_id_set = *otapic::OfferDataNym_server_id_set;
*swig_asset_type_id_get = *otapic::OfferDataNym_asset_type_id_get;
*swig_asset_type_id_set = *otapic::OfferDataNym_asset_type_id_set;
*swig_asset_acct_id_get = *otapic::OfferDataNym_asset_acct_id_get;
*swig_asset_acct_id_set = *otapic::OfferDataNym_asset_acct_id_set;
*swig_currency_type_id_get = *otapic::OfferDataNym_currency_type_id_get;
*swig_currency_type_id_set = *otapic::OfferDataNym_currency_type_id_set;
*swig_currency_acct_id_get = *otapic::OfferDataNym_currency_acct_id_get;
*swig_currency_acct_id_set = *otapic::OfferDataNym_currency_acct_id_set;
*swig_selling_get = *otapic::OfferDataNym_selling_get;
*swig_selling_set = *otapic::OfferDataNym_selling_set;
*swig_scale_get = *otapic::OfferDataNym_scale_get;
*swig_scale_set = *otapic::OfferDataNym_scale_set;
*swig_price_per_scale_get = *otapic::OfferDataNym_price_per_scale_get;
*swig_price_per_scale_set = *otapic::OfferDataNym_price_per_scale_set;
*swig_transaction_id_get = *otapic::OfferDataNym_transaction_id_get;
*swig_transaction_id_set = *otapic::OfferDataNym_transaction_id_set;
*swig_total_assets_get = *otapic::OfferDataNym_total_assets_get;
*swig_total_assets_set = *otapic::OfferDataNym_total_assets_set;
*swig_finished_so_far_get = *otapic::OfferDataNym_finished_so_far_get;
*swig_finished_so_far_set = *otapic::OfferDataNym_finished_so_far_set;
*swig_minimum_increment_get = *otapic::OfferDataNym_minimum_increment_get;
*swig_minimum_increment_set = *otapic::OfferDataNym_minimum_increment_set;
*swig_stop_sign_get = *otapic::OfferDataNym_stop_sign_get;
*swig_stop_sign_set = *otapic::OfferDataNym_stop_sign_set;
*swig_stop_price_get = *otapic::OfferDataNym_stop_price_get;
*swig_stop_price_set = *otapic::OfferDataNym_stop_price_set;
*ot_dynamic_cast = *otapic::OfferDataNym_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OfferListNym ##############

package otapi::OfferListNym;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OfferListNym($self);
        delete $OWNER{$self};
    }
}

*GetOfferDataNymCount = *otapic::OfferListNym_GetOfferDataNymCount;
*GetOfferDataNym = *otapic::OfferListNym_GetOfferDataNym;
*RemoveOfferDataNym = *otapic::OfferListNym_RemoveOfferDataNym;
*AddOfferDataNym = *otapic::OfferListNym_AddOfferDataNym;
*ot_dynamic_cast = *otapic::OfferListNym_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::TradeDataNym ##############

package otapi::TradeDataNym;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_TradeDataNym($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::TradeDataNym_gui_label_get;
*swig_gui_label_set = *otapic::TradeDataNym_gui_label_set;
*swig_transaction_id_get = *otapic::TradeDataNym_transaction_id_get;
*swig_transaction_id_set = *otapic::TradeDataNym_transaction_id_set;
*swig_completed_count_get = *otapic::TradeDataNym_completed_count_get;
*swig_completed_count_set = *otapic::TradeDataNym_completed_count_set;
*swig_date_get = *otapic::TradeDataNym_date_get;
*swig_date_set = *otapic::TradeDataNym_date_set;
*swig_price_get = *otapic::TradeDataNym_price_get;
*swig_price_set = *otapic::TradeDataNym_price_set;
*swig_amount_sold_get = *otapic::TradeDataNym_amount_sold_get;
*swig_amount_sold_set = *otapic::TradeDataNym_amount_sold_set;
*ot_dynamic_cast = *otapic::TradeDataNym_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::TradeListNym ##############

package otapi::TradeListNym;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_TradeListNym($self);
        delete $OWNER{$self};
    }
}

*GetTradeDataNymCount = *otapic::TradeListNym_GetTradeDataNymCount;
*GetTradeDataNym = *otapic::TradeListNym_GetTradeDataNym;
*RemoveTradeDataNym = *otapic::TradeListNym_RemoveTradeDataNym;
*AddTradeDataNym = *otapic::TradeListNym_AddTradeDataNym;
*ot_dynamic_cast = *otapic::TradeListNym_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::Acct ##############

package otapi::Acct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_Acct($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::Acct_gui_label_get;
*swig_gui_label_set = *otapic::Acct_gui_label_set;
*swig_acct_id_get = *otapic::Acct_acct_id_get;
*swig_acct_id_set = *otapic::Acct_acct_id_set;
*swig_server_id_get = *otapic::Acct_server_id_get;
*swig_server_id_set = *otapic::Acct_server_id_set;
*ot_dynamic_cast = *otapic::Acct_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::BitcoinAcct ##############

package otapi::BitcoinAcct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Acct otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_BitcoinAcct($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::BitcoinAcct_gui_label_get;
*swig_gui_label_set = *otapic::BitcoinAcct_gui_label_set;
*swig_acct_id_get = *otapic::BitcoinAcct_acct_id_get;
*swig_acct_id_set = *otapic::BitcoinAcct_acct_id_set;
*swig_server_id_get = *otapic::BitcoinAcct_server_id_get;
*swig_server_id_set = *otapic::BitcoinAcct_server_id_set;
*swig_bitcoin_acct_name_get = *otapic::BitcoinAcct_bitcoin_acct_name_get;
*swig_bitcoin_acct_name_set = *otapic::BitcoinAcct_bitcoin_acct_name_set;
*ot_dynamic_cast = *otapic::BitcoinAcct_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::ServerInfo ##############

package otapi::ServerInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_ServerInfo($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::ServerInfo_gui_label_get;
*swig_gui_label_set = *otapic::ServerInfo_gui_label_set;
*swig_server_id_get = *otapic::ServerInfo_server_id_get;
*swig_server_id_set = *otapic::ServerInfo_server_id_set;
*swig_server_type_get = *otapic::ServerInfo_server_type_get;
*swig_server_type_set = *otapic::ServerInfo_server_type_set;
*ot_dynamic_cast = *otapic::ServerInfo_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::Server ##############

package otapi::Server;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::ServerInfo otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_Server($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::Server_gui_label_get;
*swig_gui_label_set = *otapic::Server_gui_label_set;
*swig_server_id_get = *otapic::Server_server_id_get;
*swig_server_id_set = *otapic::Server_server_id_set;
*swig_server_type_get = *otapic::Server_server_type_get;
*swig_server_type_set = *otapic::Server_server_type_set;
*swig_server_host_get = *otapic::Server_server_host_get;
*swig_server_host_set = *otapic::Server_server_host_set;
*swig_server_port_get = *otapic::Server_server_port_get;
*swig_server_port_set = *otapic::Server_server_port_set;
*ot_dynamic_cast = *otapic::Server_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::BitcoinServer ##############

package otapi::BitcoinServer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Server otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_BitcoinServer($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::BitcoinServer_gui_label_get;
*swig_gui_label_set = *otapic::BitcoinServer_gui_label_set;
*swig_server_id_get = *otapic::BitcoinServer_server_id_get;
*swig_server_id_set = *otapic::BitcoinServer_server_id_set;
*swig_server_type_get = *otapic::BitcoinServer_server_type_get;
*swig_server_type_set = *otapic::BitcoinServer_server_type_set;
*swig_server_host_get = *otapic::BitcoinServer_server_host_get;
*swig_server_host_set = *otapic::BitcoinServer_server_host_set;
*swig_server_port_get = *otapic::BitcoinServer_server_port_get;
*swig_server_port_set = *otapic::BitcoinServer_server_port_set;
*swig_bitcoin_username_get = *otapic::BitcoinServer_bitcoin_username_get;
*swig_bitcoin_username_set = *otapic::BitcoinServer_bitcoin_username_set;
*swig_bitcoin_password_get = *otapic::BitcoinServer_bitcoin_password_get;
*swig_bitcoin_password_set = *otapic::BitcoinServer_bitcoin_password_set;
*ot_dynamic_cast = *otapic::BitcoinServer_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::RippleServer ##############

package otapi::RippleServer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Server otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_RippleServer($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::RippleServer_gui_label_get;
*swig_gui_label_set = *otapic::RippleServer_gui_label_set;
*swig_server_id_get = *otapic::RippleServer_server_id_get;
*swig_server_id_set = *otapic::RippleServer_server_id_set;
*swig_server_type_get = *otapic::RippleServer_server_type_get;
*swig_server_type_set = *otapic::RippleServer_server_type_set;
*swig_server_host_get = *otapic::RippleServer_server_host_get;
*swig_server_host_set = *otapic::RippleServer_server_host_set;
*swig_server_port_get = *otapic::RippleServer_server_port_get;
*swig_server_port_set = *otapic::RippleServer_server_port_set;
*swig_ripple_username_get = *otapic::RippleServer_ripple_username_get;
*swig_ripple_username_set = *otapic::RippleServer_ripple_username_set;
*swig_ripple_password_get = *otapic::RippleServer_ripple_password_get;
*swig_ripple_password_set = *otapic::RippleServer_ripple_password_set;
*swig_namefield_id_get = *otapic::RippleServer_namefield_id_get;
*swig_namefield_id_set = *otapic::RippleServer_namefield_id_set;
*swig_passfield_id_get = *otapic::RippleServer_passfield_id_get;
*swig_passfield_id_set = *otapic::RippleServer_passfield_id_set;
*ot_dynamic_cast = *otapic::RippleServer_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::LoomServer ##############

package otapi::LoomServer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Server otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_LoomServer($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::LoomServer_gui_label_get;
*swig_gui_label_set = *otapic::LoomServer_gui_label_set;
*swig_server_id_get = *otapic::LoomServer_server_id_get;
*swig_server_id_set = *otapic::LoomServer_server_id_set;
*swig_server_type_get = *otapic::LoomServer_server_type_get;
*swig_server_type_set = *otapic::LoomServer_server_type_set;
*swig_server_host_get = *otapic::LoomServer_server_host_get;
*swig_server_host_set = *otapic::LoomServer_server_host_set;
*swig_server_port_get = *otapic::LoomServer_server_port_get;
*swig_server_port_set = *otapic::LoomServer_server_port_set;
*swig_loom_username_get = *otapic::LoomServer_loom_username_get;
*swig_loom_username_set = *otapic::LoomServer_loom_username_set;
*swig_namefield_id_get = *otapic::LoomServer_namefield_id_get;
*swig_namefield_id_set = *otapic::LoomServer_namefield_id_set;
*ot_dynamic_cast = *otapic::LoomServer_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::ContactNym ##############

package otapi::ContactNym;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_ContactNym($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::ContactNym_gui_label_get;
*swig_gui_label_set = *otapic::ContactNym_gui_label_set;
*swig_nym_type_get = *otapic::ContactNym_nym_type_get;
*swig_nym_type_set = *otapic::ContactNym_nym_type_set;
*swig_nym_id_get = *otapic::ContactNym_nym_id_get;
*swig_nym_id_set = *otapic::ContactNym_nym_id_set;
*swig_public_key_get = *otapic::ContactNym_public_key_get;
*swig_public_key_set = *otapic::ContactNym_public_key_set;
*swig_memo_get = *otapic::ContactNym_memo_get;
*swig_memo_set = *otapic::ContactNym_memo_set;
*GetServerInfoCount = *otapic::ContactNym_GetServerInfoCount;
*GetServerInfo = *otapic::ContactNym_GetServerInfo;
*RemoveServerInfo = *otapic::ContactNym_RemoveServerInfo;
*AddServerInfo = *otapic::ContactNym_AddServerInfo;
*ot_dynamic_cast = *otapic::ContactNym_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::WalletData ##############

package otapi::WalletData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_WalletData($self);
        delete $OWNER{$self};
    }
}

*GetBitcoinServerCount = *otapic::WalletData_GetBitcoinServerCount;
*GetBitcoinServer = *otapic::WalletData_GetBitcoinServer;
*RemoveBitcoinServer = *otapic::WalletData_RemoveBitcoinServer;
*AddBitcoinServer = *otapic::WalletData_AddBitcoinServer;
*GetBitcoinAcctCount = *otapic::WalletData_GetBitcoinAcctCount;
*GetBitcoinAcct = *otapic::WalletData_GetBitcoinAcct;
*RemoveBitcoinAcct = *otapic::WalletData_RemoveBitcoinAcct;
*AddBitcoinAcct = *otapic::WalletData_AddBitcoinAcct;
*GetRippleServerCount = *otapic::WalletData_GetRippleServerCount;
*GetRippleServer = *otapic::WalletData_GetRippleServer;
*RemoveRippleServer = *otapic::WalletData_RemoveRippleServer;
*AddRippleServer = *otapic::WalletData_AddRippleServer;
*GetLoomServerCount = *otapic::WalletData_GetLoomServerCount;
*GetLoomServer = *otapic::WalletData_GetLoomServer;
*RemoveLoomServer = *otapic::WalletData_RemoveLoomServer;
*AddLoomServer = *otapic::WalletData_AddLoomServer;
*ot_dynamic_cast = *otapic::WalletData_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::ContactAcct ##############

package otapi::ContactAcct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_ContactAcct($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::ContactAcct_gui_label_get;
*swig_gui_label_set = *otapic::ContactAcct_gui_label_set;
*swig_server_type_get = *otapic::ContactAcct_server_type_get;
*swig_server_type_set = *otapic::ContactAcct_server_type_set;
*swig_server_id_get = *otapic::ContactAcct_server_id_get;
*swig_server_id_set = *otapic::ContactAcct_server_id_set;
*swig_asset_type_id_get = *otapic::ContactAcct_asset_type_id_get;
*swig_asset_type_id_set = *otapic::ContactAcct_asset_type_id_set;
*swig_acct_id_get = *otapic::ContactAcct_acct_id_get;
*swig_acct_id_set = *otapic::ContactAcct_acct_id_set;
*swig_nym_id_get = *otapic::ContactAcct_nym_id_get;
*swig_nym_id_set = *otapic::ContactAcct_nym_id_set;
*swig_memo_get = *otapic::ContactAcct_memo_get;
*swig_memo_set = *otapic::ContactAcct_memo_set;
*swig_public_key_get = *otapic::ContactAcct_public_key_get;
*swig_public_key_set = *otapic::ContactAcct_public_key_set;
*ot_dynamic_cast = *otapic::ContactAcct_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::Contact ##############

package otapi::Contact;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_Contact($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::Contact_gui_label_get;
*swig_gui_label_set = *otapic::Contact_gui_label_set;
*swig_contact_id_get = *otapic::Contact_contact_id_get;
*swig_contact_id_set = *otapic::Contact_contact_id_set;
*swig_email_get = *otapic::Contact_email_get;
*swig_email_set = *otapic::Contact_email_set;
*swig_memo_get = *otapic::Contact_memo_get;
*swig_memo_set = *otapic::Contact_memo_set;
*swig_public_key_get = *otapic::Contact_public_key_get;
*swig_public_key_set = *otapic::Contact_public_key_set;
*GetContactNymCount = *otapic::Contact_GetContactNymCount;
*GetContactNym = *otapic::Contact_GetContactNym;
*RemoveContactNym = *otapic::Contact_RemoveContactNym;
*AddContactNym = *otapic::Contact_AddContactNym;
*GetContactAcctCount = *otapic::Contact_GetContactAcctCount;
*GetContactAcct = *otapic::Contact_GetContactAcct;
*RemoveContactAcct = *otapic::Contact_RemoveContactAcct;
*AddContactAcct = *otapic::Contact_AddContactAcct;
*ot_dynamic_cast = *otapic::Contact_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::AddressBook ##############

package otapi::AddressBook;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_AddressBook($self);
        delete $OWNER{$self};
    }
}

*GetContactCount = *otapic::AddressBook_GetContactCount;
*GetContact = *otapic::AddressBook_GetContact;
*RemoveContact = *otapic::AddressBook_RemoveContact;
*AddContact = *otapic::AddressBook_AddContact;
*ot_dynamic_cast = *otapic::AddressBook_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package otapi;

*OTPASSWORD_BLOCKSIZE = *otapic::OTPASSWORD_BLOCKSIZE;
*OTPASSWORD_MEMSIZE = *otapic::OTPASSWORD_MEMSIZE;
*OT_LARGE_BLOCKSIZE = *otapic::OT_LARGE_BLOCKSIZE;
*OT_LARGE_MEMSIZE = *otapic::OT_LARGE_MEMSIZE;
*OT_DEFAULT_BLOCKSIZE = *otapic::OT_DEFAULT_BLOCKSIZE;
*OT_DEFAULT_MEMSIZE = *otapic::OT_DEFAULT_MEMSIZE;
*PACK_MESSAGE_PACK = *otapic::PACK_MESSAGE_PACK;
*PACK_PROTOCOL_BUFFERS = *otapic::PACK_PROTOCOL_BUFFERS;
*PACK_TYPE_ERROR = *otapic::PACK_TYPE_ERROR;
*STORE_FILESYSTEM = *otapic::STORE_FILESYSTEM;
*STORE_TYPE_SUBCLASS = *otapic::STORE_TYPE_SUBCLASS;
*STORED_OBJ_STRING = *otapic::STORED_OBJ_STRING;
*STORED_OBJ_BLOB = *otapic::STORED_OBJ_BLOB;
*STORED_OBJ_STRING_MAP = *otapic::STORED_OBJ_STRING_MAP;
*STORED_OBJ_WALLET_DATA = *otapic::STORED_OBJ_WALLET_DATA;
*STORED_OBJ_BITCOIN_ACCT = *otapic::STORED_OBJ_BITCOIN_ACCT;
*STORED_OBJ_BITCOIN_SERVER = *otapic::STORED_OBJ_BITCOIN_SERVER;
*STORED_OBJ_RIPPLE_SERVER = *otapic::STORED_OBJ_RIPPLE_SERVER;
*STORED_OBJ_LOOM_SERVER = *otapic::STORED_OBJ_LOOM_SERVER;
*STORED_OBJ_SERVER_INFO = *otapic::STORED_OBJ_SERVER_INFO;
*STORED_OBJ_CONTACT_NYM = *otapic::STORED_OBJ_CONTACT_NYM;
*STORED_OBJ_CONTACT_ACCT = *otapic::STORED_OBJ_CONTACT_ACCT;
*STORED_OBJ_CONTACT = *otapic::STORED_OBJ_CONTACT;
*STORED_OBJ_ADDRESS_BOOK = *otapic::STORED_OBJ_ADDRESS_BOOK;
*STORED_OBJ_MARKET_DATA = *otapic::STORED_OBJ_MARKET_DATA;
*STORED_OBJ_MARKET_LIST = *otapic::STORED_OBJ_MARKET_LIST;
*STORED_OBJ_BID_DATA = *otapic::STORED_OBJ_BID_DATA;
*STORED_OBJ_ASK_DATA = *otapic::STORED_OBJ_ASK_DATA;
*STORED_OBJ_OFFER_LIST_MARKET = *otapic::STORED_OBJ_OFFER_LIST_MARKET;
*STORED_OBJ_TRADE_DATA_MARKET = *otapic::STORED_OBJ_TRADE_DATA_MARKET;
*STORED_OBJ_TRADE_LIST_MARKET = *otapic::STORED_OBJ_TRADE_LIST_MARKET;
*STORED_OBJ_OFFER_DATA_NYM = *otapic::STORED_OBJ_OFFER_DATA_NYM;
*STORED_OBJ_OFFER_LIST_NYM = *otapic::STORED_OBJ_OFFER_LIST_NYM;
*STORED_OBJ_TRADE_DATA_NYM = *otapic::STORED_OBJ_TRADE_DATA_NYM;
*STORED_OBJ_TRADE_LIST_NYM = *otapic::STORED_OBJ_TRADE_LIST_NYM;
*STORED_OBJ_ERROR = *otapic::STORED_OBJ_ERROR;
1;

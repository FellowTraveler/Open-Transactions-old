// ------------------------------------------------------------------
// This is a library written in OTScript, which makes the OT-API
// much easier to use from inside your own OTScripts, by providing
// a higher-level layer.
//
// Think of it as the "standard header" for using OT from a script.
//
// There is similar code to this in Java also, in the OTAPI_Func and
// Utility classes, in the Moneychanger project. They also make the 
// OTAPI much easier to use, by providing a higher-level layer.
//
//  http://www.chaiscript.com/doxygen/namespace_chai_script___language.html
//

// *************************************************************************************


/*
 * FT:  I noticed a lot of code duplication, when sending messages and transaction
 * requests. I could basically remove all that duplication, except there are a couple
 * of OT_API calls inside each one, that are different, and that take different
 * parameters. 
 * Best way to get around that, is to just make an object that will do the appropriate
 * API call, and store the necessary parameters inside. (A "functor" aka function
 * object.) Then pass it in as a parameter and trigger it at the appropriate time.
 * (That's what this is.)
 */

	attr OTAPI_Func::CREATE_USER_ACCT			
	attr OTAPI_Func::DELETE_USER_ACCT			
	attr OTAPI_Func::CHECK_USER					
    attr OTAPI_Func::SEND_USER_MESSAGE			
    attr OTAPI_Func::SEND_USER_INSTRUMENT			
	attr OTAPI_Func::ISSUE_ASSET_TYPE			
	attr OTAPI_Func::ISSUE_BASKET
	attr OTAPI_Func::CREATE_ASSET_ACCT
	attr OTAPI_Func::DELETE_ASSET_ACCT
    attr OTAPI_Func::ACTIVATE_SMART_CONTRACT
    attr OTAPI_Func::TRIGGER_CLAUSE
    attr OTAPI_Func::PROCESS_INBOX
    attr OTAPI_Func::EXCHANGE_BASKET			
	attr OTAPI_Func::DEPOSIT_CASH				
	attr OTAPI_Func::EXCHANGE_CASH				
	attr OTAPI_Func::DEPOSIT_CHEQUE				
    attr OTAPI_Func::WITHDRAW_VOUCHER			
    attr OTAPI_Func::PAY_DIVIDEND			
	attr OTAPI_Func::WITHDRAW_CASH
	attr OTAPI_Func::GET_CONTRACT
	attr OTAPI_Func::SEND_TRANSFER
	attr OTAPI_Func::GET_MARKET_LIST
	attr OTAPI_Func::CREATE_MARKET_OFFER
	attr OTAPI_Func::KILL_MARKET_OFFER
	attr OTAPI_Func::KILL_PAYMENT_PLAN
	attr OTAPI_Func::DEPOSIT_PAYMENT_PLAN
	attr OTAPI_Func::GET_NYM_MARKET_OFFERS
	attr OTAPI_Func::GET_MARKET_OFFERS
	attr OTAPI_Func::GET_MARKET_RECENT_TRADES
	attr OTAPI_Func::GET_MINT
	attr OTAPI_Func::QUERY_ASSET_TYPES
    attr OTAPI_Func::GET_BOX_RECEIPT
    attr OTAPI_Func::ADJUST_USAGE_CREDITS
// -------------------------------------------
	attr OTAPI_Func::funcType
// -------------------------------------------
	attr OTAPI_Func::serverID
	attr OTAPI_Func::nymID
	attr OTAPI_Func::nymID2
	attr OTAPI_Func::assetID
	attr OTAPI_Func::assetID2
	attr OTAPI_Func::accountID
	attr OTAPI_Func::accountID2
	attr OTAPI_Func::basket
	attr OTAPI_Func::strData
	attr OTAPI_Func::strData2
	attr OTAPI_Func::strData3
    attr OTAPI_Func::strData4
    attr OTAPI_Func::strData5
	attr OTAPI_Func::bBool
    attr OTAPI_Func::nData
    attr OTAPI_Func::lData
    attr OTAPI_Func::tData
    attr OTAPI_Func::nTransNumsNeeded

    attr OTAPI_Func::nRequestNum
// ---------------------------------------
/*	public String   serverID;
    public String   nymID, nymID2;
    public String   assetID, assetID2;
    public String   accountID;
    public String   accountID2;
    public String   basket;
    public String   strData, strData2, strData3, strData4;
    public boolean  bBool;    
    public int      nData;
    public long     lData;
    public int      nTransNumsNeeded;
    public int      nRequestNum;
*/
// -----------------------------------


// -----------------------------------

	def OTAPI_Func::InitCustom()
	{
		
//		this.serverID		
//		this.nymID
//		this.nymID2
//		this.assetID
//		this.assetID2
//		this.accountID
//		this.accountID2
//		this.basket
//		this.strData
//		this.strData2
//		this.strData3
//		this.strData4
        
		this.bBool						= false
		this.nData						= 0
		this.lData						= int64_t(0)
		this.tData						= OT_API_GetTime() // So it gets created as a time_t
		this.tData						= 0 // initialize it to 0.
		this.nTransNumsNeeded			= 0
		this.nRequestNum			    = (-1)
	// ---------------------------------------
		this.funcType					= 0
	// ---------------------------------------
		this.CREATE_USER_ACCT			= 1
		this.DELETE_USER_ACCT			= 2
		this.CHECK_USER					= 3
		this.SEND_USER_MESSAGE			= 4
		this.SEND_USER_INSTRUMENT       = 5
		this.ISSUE_ASSET_TYPE			= 6
		this.ISSUE_BASKET				= 7
		this.CREATE_ASSET_ACCT			= 8
		this.DELETE_ASSET_ACCT			= 9
		this.ACTIVATE_SMART_CONTRACT	= 10
        this.TRIGGER_CLAUSE             = 11
		this.PROCESS_INBOX				= 12
		this.EXCHANGE_BASKET			= 13
        this.DEPOSIT_CASH				= 14
		this.EXCHANGE_CASH				= 15
		this.DEPOSIT_CHEQUE				= 16
		this.WITHDRAW_VOUCHER			= 17
		this.PAY_DIVIDEND               = 18
		this.WITHDRAW_CASH				= 19
		this.GET_CONTRACT				= 20
		this.SEND_TRANSFER				= 21
		this.GET_MARKET_LIST			= 22
		this.CREATE_MARKET_OFFER		= 23
		this.KILL_MARKET_OFFER          = 24
		this.KILL_PAYMENT_PLAN          = 25
		this.DEPOSIT_PAYMENT_PLAN		= 26 
		this.GET_NYM_MARKET_OFFERS		= 27
		this.GET_MARKET_OFFERS			= 28
		this.GET_MARKET_RECENT_TRADES	= 29
		this.GET_MINT					= 30
		this.QUERY_ASSET_TYPES			= 31
		this.GET_BOX_RECEIPT			= 32
        this.ADJUST_USAGE_CREDITS       = 33
	}
// ---------------------------------------

    def OTAPI_Func::OTAPI_Func() // 0 args
	{
//		OT_API_Output(0, "(Version of OTAPI_Func with 0 arguments.)\n");	
		
		this.InitCustom()
        // ---------------------------
        
    }
// ---------------------------------------

   
    def OTAPI_Func::OTAPI_Func(theType, p_serverID, p_nymID) // 3 args
	{
//		OT_API_Output(0, "(Version of OTAPI_Func with 3 arguments.)\n");	
		
		this.InitCustom()
		// ---------------------------
		var strError = "ERROR! Empty string passed to OTAPI_Func.OTAPI_Func() as: ";
		if (!VerifyStringVal(p_serverID))
		{	OT_API_Output(0, concat(strError, "p_serverID")); }
		if (!VerifyStringVal(p_nymID))
		{	OT_API_Output(0, concat(strError, "p_nymID")); }
		// ---------------------------

        this.funcType   = theType;
        this.serverID   = p_serverID;
        this.nymID      = p_nymID;
        this.nTransNumsNeeded = 1;
        this.bBool		= false;
    }
// ---------------------------------------
	
	
    def OTAPI_Func::OTAPI_Func(theType, p_serverID, p_nymID, p_strParam) // 4 args
	{
//		OT_API_Output(0, "(Version of OTAPI_Func with 4 arguments.)\n");	
		
		this.InitCustom()
		// ---------------------------
		var strError = "ERROR! Empty string passed to OTAPI_Func.OTAPI_Func() as: ";
		if (!VerifyStringVal(p_serverID))
		{	OT_API_Output(0, concat(strError, "p_serverID")); }
		if (!VerifyStringVal(p_nymID))
		{	OT_API_Output(0, concat(strError, "p_nymID")); }
		if (!VerifyStringVal(p_strParam))
		{	OT_API_Output(0, concat(strError, "p_strParam")); }
		// ---------------------------

        this.funcType   = theType;
        this.serverID   = p_serverID;
        this.nymID      = p_nymID;
        this.nTransNumsNeeded = 1;
        this.bBool      = false;
        
		if (theType == this.ISSUE_BASKET)
		{
			this.basket     = p_strParam;
		}
		else if ((theType == this.GET_MINT) || (theType == this.GET_CONTRACT) || (theType == this.CREATE_ASSET_ACCT))
		{
			this.assetID    = p_strParam;
		}
		else if (theType == this.CHECK_USER)
		{
			this.nymID2     = p_strParam;
		}
		else if ((theType == this.DELETE_ASSET_ACCT))
		{
			this.accountID     = p_strParam;
		}
		else if ((theType == this.ISSUE_ASSET_TYPE) || (theType == this.GET_MARKET_RECENT_TRADES) || (theType == this.QUERY_ASSET_TYPES))
		{
			this.strData    = p_strParam;
		}
		else
		{
			OT_API_Output(0, "ERROR! WRONG TYPE passed to OTAPI_Func.OTAPI_Func()\n");		
		}		
    }
	// ---------------------------------------

	def OTAPI_Func::OTAPI_Func(theType, p_serverID, p_nymID, p_strParam, p_strData) // 5 args
	{
//		OT_API_Output(0, "(Version of OTAPI_Func with 5 arguments.)\n");	

		this.InitCustom()
		// ---------------------------
		var strError = "ERROR! Empty string passed to OTAPI_Func.OTAPI_Func() as: ";
		if (!VerifyStringVal(p_serverID))
		{	OT_API_Output(0, concat(strError, "p_serverID \n")); }
		if (!VerifyStringVal(p_nymID))
		{	OT_API_Output(0, concat(strError, "p_nymID \n")); }

		if (!VerifyStringVal(p_strParam))
		{	OT_API_Output(0, concat(strError, "p_strParam \n")); }
        
        if ((theType == this.WITHDRAW_CASH) || (theType == this.GET_MARKET_OFFERS))
        {
            if (!VerifyIntVal(p_strData))
            {	OT_API_Output(0, concat(strError, "p_strData -- expected int64_t, but found: "+p_strData.get_type_info().name()+" \n")); }
        }
        else // It's not withdraw cash or get market offers.
        {
            if (!VerifyStringVal(p_strData))
            {	OT_API_Output(0, concat(strError, "p_strData -- expected string, but found: "+p_strData.get_type_info().name()+" \n")); }
        }
		// ---------------------------

        this.funcType   = theType;
        this.serverID   = p_serverID;
        this.nymID      = p_nymID;
        this.nTransNumsNeeded = 1;
        this.bBool      = false;
		
//if ((theType == this.KILL_MARKET_OFFER) || (theType == this.KILL_PAYMENT_PLAN) || (theType == this.PROCESS_INBOX) ||
//	  (theType == this.DEPOSIT_CASH) || (theType == this.DEPOSIT_CHEQUE) || (theType == this.WITHDRAW_CASH))

		if ((theType == this.KILL_MARKET_OFFER) || (theType == this.KILL_PAYMENT_PLAN) || (theType == this.PROCESS_INBOX) || (theType == this.DEPOSIT_CASH) || (theType == this.DEPOSIT_CHEQUE) || (theType == this.DEPOSIT_PAYMENT_PLAN))
		{
			this.accountID  = p_strParam;
			this.strData    = p_strData;
		}
		else if (theType == this.WITHDRAW_CASH)
		{
			this.accountID  = p_strParam;
			this.lData      = p_strData;
		}
        else if (theType == this.ADJUST_USAGE_CREDITS)
        {
            this.nymID2     = p_strParam; // target nym ID
            this.strData    = p_strData;  // adjustment (up or down.)
        }
		else if (theType == this.EXCHANGE_CASH)
		{
			this.assetID    = p_strParam;
			this.strData    = p_strData;        
		}
		else if (theType == this.GET_MARKET_OFFERS)
		{
			this.strData    = p_strParam;
			this.lData      = p_strData;
		}
		else
		{
			OT_API_Output(0, "ERROR! WRONG TYPE passed to OTAPI_Func.OTAPI_Func()\n");		
		}
    }
// ---------------------------------------
	
    def OTAPI_Func::OTAPI_Func(theType, p_serverID, p_nymID, p_nymID2, p_strData, p_strData2) // 6 args
	{
//		OT_API_Output(0, "(Version of OTAPI_Func with 6 arguments.)\n");	

		this.InitCustom()
		// ---------------------------
		var strError = "ERROR! Empty string passed to OTAPI_Func.OTAPI_Func() as: ";
		if (!VerifyStringVal(p_serverID))
		{	OT_API_Output(0, concat(strError, "p_serverID")); }
		if (!VerifyStringVal(p_nymID))
		{	OT_API_Output(0, concat(strError, "p_nymID")); }
		if (!VerifyStringVal(p_nymID2))
		{	OT_API_Output(0, concat(strError, "p_nymID2")); }        
		if (!VerifyStringVal(p_strData))
		{	OT_API_Output(0, concat(strError, "p_strData")); }
		if (!VerifyStringVal(p_strData2))
		{	OT_API_Output(0, concat(strError, "p_strData2")); }
		// ---------------------------

        this.funcType   = theType
        this.serverID   = p_serverID
        this.nymID      = p_nymID
        this.nTransNumsNeeded = 1
        this.bBool      = false
        
		if ((theType == this.SEND_USER_MESSAGE) || (theType == this.SEND_USER_INSTRUMENT))
		{
			this.nymID2     = p_nymID2
			this.strData    = p_strData
			this.strData2   = p_strData2
		}
        /*
         // -------------------------------------------
         OTAPI_Func(ot_Msg.TRIGGER_CLAUSE, SERVER_ID, NYM_ID, STR_TRANS_NUM, CLAUSE_NAME, STR_PARAM)
         */
		else if (theType == this.TRIGGER_CLAUSE)
		{
			this.strData    = p_nymID2
			this.strData2   = p_strData
			this.strData3   = p_strData2		
		}
		else if (theType == this.ACTIVATE_SMART_CONTRACT)
		{         
//      OTAPI_Func(ot_Msg.ACTIVATE_SMART_CONTRACT, SERVER_ID, NYM_ID, ACCT_ID, AGENT_NAME, THE_SMART_CONTRACT)
//          def OTAPI_Func::OTAPI_Func  (theType, p_serverID, p_nymID, p_nymID2, p_strData, p_strData2) // 6 args

            this.accountID  = p_nymID2    // the "official" asset account of the party activating the contract.
            this.strData    = p_strData   // the agent's name for that party, as listed on the contract.
            this.strData2   = p_strData2  // the smart contract itself.
            
            var nNumsNeeded = OT_API_SmartContract_CountNumsNeeded(p_strData2, p_strData)

            if (VerifyIntVal(nNumsNeeded) && nNumsNeeded > 0)
            {
                this.nTransNumsNeeded = nNumsNeeded
            }
		}
		else if (theType == this.GET_BOX_RECEIPT)
		{
			this.accountID	= p_nymID2		// accountID (inbox/outbox) or NymID (nymbox) is passed here.
			this.nData		= p_strData.to_int() 
			this.strData	= p_strData2	// transaction number passed here as string
		}
		else
		{
			OT_API_Output(0, "ERROR! WRONG TYPE passed to OTAPI_Func.OTAPI_Func() ERROR!!!!!!\n");
		}
	}
    // ---------------------------------------
    

	
    def OTAPI_Func::OTAPI_Func(theType, p_serverID, p_nymID, p_accountID, p_strParam, p_strData, p_strData2) // 7 args
	{
//		OT_API_Output(0, "(Version of OTAPI_Func with 7 arguments.)\n");	
		
		this.InitCustom()
		// ---------------------------
		var strError = "ERROR! Empty string passed to OTAPI_Func.OTAPI_Func() as: ";
		if (!VerifyStringVal(p_serverID))
		{	OT_API_Output(0, concat(strError, "p_serverID")); }
		if (!VerifyStringVal(p_nymID))
		{	OT_API_Output(0, concat(strError, "p_nymID")); }
		if (!VerifyStringVal(p_accountID))
		{	OT_API_Output(0, concat(strError, "p_accountID")); }
		if (!VerifyStringVal(p_strParam))
		{	OT_API_Output(0, concat(strError, "p_strParam")); }
		// ---------------------------
        this.funcType   = theType
        this.serverID   = p_serverID
        this.nymID      = p_nymID
        this.nTransNumsNeeded = 1
        this.bBool      = false
        this.accountID  = p_accountID
		
//      var theRequest := OTAPI_Func(ot_Msg.WITHDRAW_VOUCHER, SERVER_ID, NYM_ID, ACCT_ID, RECIP_NYM_ID, STR_MEMO, STR_AMOUNT)
		if (theType == this.WITHDRAW_VOUCHER)
		{
            if (!VerifyStringVal(p_strData))
            {	OT_API_Output(0, concat(strError, "p_strData")); }
            if (!VerifyIntVal(p_strData2))
            {	OT_API_Output(0, concat(strError, "p_strData2")); }
			this.nymID2     = p_strParam // str  Recipient Nym ID
            this.strData    = p_strData  // str  Memo
            this.lData      = p_strData2 // long Amount
		}
        
//      var theRequest := OTAPI_Func(ot_Msg.PAY_DIVIDEND, SERVER_ID, NYM_ID, SOURCE_ACCT_ID, SHARES_ASSET_ID, STR_MEMO, STR_AMOUNT_PER_SHARE)
		else if (theType == this.PAY_DIVIDEND)
		{
            if (!VerifyStringVal(p_strData))
            {	OT_API_Output(0, concat(strError, "p_strData")); }
            if (!VerifyIntVal(p_strData2))
            {	OT_API_Output(0, concat(strError, "p_strData2")); }
			this.assetID    = p_strParam   // str  Shares Asset ID
            this.strData    = p_strData    // str  Memo
            this.lData      = p_strData2   // long Amount Per Share
		}
        
//      var theRequest := OTAPI_Func(ot_Msg.SEND_TRANSFER, SERVER_ID, NYM_ID, ACCT_FROM, ACCT_TO, AMOUNT, NOTE)
		else if (theType == this.SEND_TRANSFER)
		{
            if (!VerifyIntVal(p_strData))
            {	OT_API_Output(0, concat(strError, "p_strData")); }
            if (!VerifyStringVal(p_strData2))
            {	OT_API_Output(0, concat(strError, "p_strData2")); }
			this.accountID2 = p_strParam
            this.lData      = p_strData    // long Amount
            this.strData    = p_strData2   // str  Note
		}
        else if (theType == this.SEND_USER_INSTRUMENT)
        {
            if (!VerifyStringVal(p_accountID))
            {	OT_API_Output(0, concat(strError, "p_accountID")); }
            if (!VerifyStringVal(p_strParam))
            {	OT_API_Output(0, concat(strError, "p_strParam")); }
            if (!VerifyStringVal(p_strData))
            {	OT_API_Output(0, concat(strError, "p_strData")); }
            this.nymID2     = p_accountID // Recipient Nym
            this.strData    = p_strParam  // Recipient pubkey
			this.strData2   = p_strData   // Instrument for recipient.
            this.accountID  = p_strData2  // sender_instrument is attached here. (Optional.)
        }
		else
		{
			OT_API_Output(0, "ERROR! WRONG TYPE passed to OTAPI_Func.OTAPI_Func() ERROR!!!!!!\n")
		}
    }
	
	
	// ---------------------------------------

		
    def OTAPI_Func::OTAPI_Func(theType, p_serverID, p_nymID, p_assetID,  // 8 args
            p_basket, p_accountID, p_bBool, p_nTransNumsNeeded) 
	{
//		OT_API_Output(0, "(Version of OTAPI_Func with 8 arguments.)\n");	

		this.InitCustom()
		// ---------------------------
		var strError = "ERROR! Empty string passed to OTAPI_Func.OTAPI_Func() as: ";
		if (!VerifyStringVal(p_serverID))
		{	OT_API_Output(0, concat(strError, "p_serverID")); }
		if (!VerifyStringVal(p_nymID))
		{	OT_API_Output(0, concat(strError, "p_nymID")); }
		if (!VerifyStringVal(p_assetID))
		{	OT_API_Output(0, concat(strError, "p_assetID")); }
		if (!VerifyStringVal(p_accountID))
		{	OT_API_Output(0, concat(strError, "p_accountID")); }
		if (!VerifyStringVal(p_basket))
		{	OT_API_Output(0, concat(strError, "p_basket")); }
 		// ---------------------------

        this.funcType   = theType;
        this.serverID   = p_serverID;
        this.nymID      = p_nymID;
        this.nTransNumsNeeded = p_nTransNumsNeeded;
        this.bBool      = p_bBool;
        this.assetID    = p_assetID;
        this.basket     = p_basket;
        this.accountID  = p_accountID;
    }
	// ---------------------------------------
	
		
    // CREATE_MARKET_OFFER
    //
	def OTAPI_Func::OTAPI_Func(theType, p_serverID, p_nymID, assetAccountID, currencyAcctID, scale, minIncrement, quantity, price, bSelling)	// 10 args
	{
//		OT_API_Output(0, "(Version of OTAPI_Func with 10 arguments.)\n");	

		this.InitCustom()
		// ---------------------------
		var strError = "ERROR! Empty string passed to OTAPI_Func.OTAPI_Func() as: ";
		if (!VerifyStringVal(p_serverID))
		{	OT_API_Output(0, concat(strError, "p_serverID")); }
		if (!VerifyStringVal(p_nymID))
		{	OT_API_Output(0, concat(strError, "p_nymID")); }
		if (!VerifyStringVal(assetAccountID))
		{	OT_API_Output(0, concat(strError, "assetAccountID")); }
		if (!VerifyStringVal(currencyAcctID))
		{	OT_API_Output(0, concat(strError, "currencyAcctID")); }
		if (!VerifyStringVal(scale))
		{	OT_API_Output(0, concat(strError, "scale")); }
		if (!VerifyStringVal(minIncrement))
		{	OT_API_Output(0, concat(strError, "minIncrement")); }
		if (!VerifyStringVal(quantity))
		{	OT_API_Output(0, concat(strError, "quantity")); }
		if (!VerifyStringVal(price))
		{	OT_API_Output(0, concat(strError, "price")); }
		// ---------------------------

        this.funcType   = theType;
        this.serverID   = p_serverID;
        this.nymID      = p_nymID;
        this.accountID  = assetAccountID;
        this.accountID2 = currencyAcctID;

        this.strData    = scale; 
        this.strData2   = minIncrement;
        this.strData3   = quantity;
        this.strData4   = price;

        this.strData5   = ""; // Will be set after this function is called, since there were too many arguments.

        this.bBool      = bSelling;
        
        this.nTransNumsNeeded = 3; // An opening transaction number, plus another for each asset account, total of 3.
	}


    // **********************************************************************

	
	def OTAPI_Func::Run() 
	{
        // -1 means error, no message was sent.
        //  0 means NO error, yet still no message was sent.
        // >0 means (usually) the request number is being returned.
        //
        var nRetVal = (-1);

        switch (this.funcType)
        {
            case (this.CHECK_USER)
            {	nRetVal = OT_API_checkUser(this.serverID, this.nymID, this.nymID2);	 break;}
            case (this.CREATE_USER_ACCT)
            {	nRetVal = OT_API_createUserAccount(this.serverID, this.nymID);	 break;}
            case (this.DELETE_USER_ACCT)
            {	nRetVal = OT_API_deleteUserAccount(this.serverID, this.nymID);	 break;}
            case (this.SEND_USER_MESSAGE)
            {	nRetVal = OT_API_sendUserMessage(this.serverID, this.nymID, this.nymID2, this.strData, this.strData2);	 break;}
            case (this.SEND_USER_INSTRUMENT)
            {
                if (VerifyStringVal(this.accountID))
                {
                    nRetVal = OT_API_sendUserInstrument(this.serverID, this.nymID, this.nymID2, this.strData, this.strData2, this.accountID); // this.accountID stores here the sender's copy of the instrument, which is used only in the case of a cash purse.
                }
                else
                {
                    var strEmpty = ""
                    nRetVal = OT_API_sendUserInstrument(this.serverID, this.nymID, this.nymID2, this.strData, this.strData2, strEmpty);
                }
                break;
            }
            case (this.GET_NYM_MARKET_OFFERS)
            {	nRetVal = OT_API_getNym_MarketOffers(this.serverID, this.nymID);	 break;}
            case (this.CREATE_ASSET_ACCT)
            {	nRetVal = OT_API_createAssetAccount(this.serverID, this.nymID, this.assetID);	 break;}
            case (this.DELETE_ASSET_ACCT)
            {	nRetVal = OT_API_deleteAssetAccount(this.serverID, this.nymID, this.accountID);	 break;}
            case (this.ACTIVATE_SMART_CONTRACT)
            {	nRetVal = OT_API_activateSmartContract(this.serverID, this.nymID, this.strData2);  break;}
            case (this.TRIGGER_CLAUSE)
            {
                var lData1 = int64_t(this.strData.to_int())
                nRetVal = OT_API_triggerClause(this.serverID, this.nymID, lData1, this.strData2, this.strData3);  break; }
            case (this.EXCHANGE_BASKET)
            {	nRetVal = OT_API_exchangeBasket(this.serverID, this.nymID, this.assetID, this.basket, this.bBool); break;  }
            case (this.GET_CONTRACT)
            {	nRetVal = OT_API_getContract(this.serverID, this.nymID, this.assetID);	 break; }
            case (this.GET_MINT)
            {	nRetVal = OT_API_getMint(this.serverID, this.nymID, this.assetID); break;	}
            case (this.QUERY_ASSET_TYPES)
            {	nRetVal = OT_API_queryAssetTypes(this.serverID, this.nymID, this.strData);	 break; }
            case (this.ISSUE_ASSET_TYPE)
            {	nRetVal = OT_API_issueAssetType(this.serverID, this.nymID, this.strData);  break;	}
            case (this.ISSUE_BASKET)
            {	nRetVal = OT_API_issueBasket(this.serverID, this.nymID, this.basket);	 break; }
            case (this.EXCHANGE_CASH)
            {	nRetVal = OT_API_exchangePurse(this.serverID, this.assetID, this.nymID, this.strData); break; }
            case (this.KILL_MARKET_OFFER)
            {
                var lData1 = int64_t(this.strData.to_int())
                nRetVal = OT_API_killMarketOffer(this.serverID, this.nymID, this.accountID, lData1); break; }
            case (this.KILL_PAYMENT_PLAN)
            {
                var lData1 = int64_t(this.strData.to_int())
                nRetVal = OT_API_killPaymentPlan(this.serverID, this.nymID, this.accountID, lData1); break; }
            case (this.GET_BOX_RECEIPT)
            {
                var lData1 = int64_t(this.strData.to_int())
                nRetVal = OT_API_getBoxReceipt(this.serverID, this.nymID, this.accountID, this.nData, lData1);  break; }
            case (this.PROCESS_INBOX)
            {	nRetVal = OT_API_processInbox(this.serverID, this.nymID, this.accountID, this.strData); break; }
            case (this.DEPOSIT_CASH)
            {	nRetVal = OT_API_notarizeDeposit(this.serverID, this.nymID, this.accountID, this.strData); break; }
            case (this.DEPOSIT_CHEQUE)
            {	nRetVal = OT_API_depositCheque(this.serverID, this.nymID, this.accountID, this.strData); break; }
            case (this.DEPOSIT_PAYMENT_PLAN)
            {	nRetVal = OT_API_depositPaymentPlan(this.serverID, this.nymID, this.strData); break; }
            case (this.WITHDRAW_CASH)
            {	nRetVal = OT_API_notarizeWithdrawal(this.serverID, this.nymID, this.accountID, this.lData);	 break; }
            case (this.WITHDRAW_VOUCHER)
            {	nRetVal = OT_API_withdrawVoucher(this.serverID, this.nymID, this.accountID, this.nymID2, this.strData, this.lData);	 break; }
            case (this.PAY_DIVIDEND)
            {	nRetVal = OT_API_payDividend(this.serverID, this.nymID, this.accountID, this.assetID, this.strData, this.lData);  break; }
            case (this.SEND_TRANSFER)
            {	nRetVal = OT_API_notarizeTransfer(this.serverID, this.nymID, this.accountID, this.accountID2, this.lData, this.strData);  break; } // amount and note, for the last two.
            case (this.GET_MARKET_LIST)
            {	nRetVal = OT_API_getMarketList(this.serverID, this.nymID);	 break; }
            case (this.GET_MARKET_OFFERS)
            {	nRetVal = OT_API_getMarketOffers(this.serverID, this.nymID, this.strData, this.lData); break; }
            case (this.GET_MARKET_RECENT_TRADES)
            {	nRetVal = OT_API_getMarketRecentTrades(this.serverID, this.nymID, this.strData); break;	}
            case (this.CREATE_MARKET_OFFER)
            {
                var lData1 = int64_t(this.strData.to_int())
                var lData2 = int64_t(this.strData2.to_int())
                var lData3 = int64_t(this.strData3.to_int())
                var lData4 = int64_t(this.strData4.to_int())

                nRetVal = OT_API_issueMarketOffer(this.accountID, this.accountID2,
                                                  lData1, lData2, lData3, lData4, this.bBool, this.tData, this.strData5, this.lData);
                break;
            }
            case (this.ADJUST_USAGE_CREDITS)
            {
                var lAdjust = this.strData.to_int();
                
                nRetVal = OT_API_usageCredits(this.serverID, this.nymID, this.nymID2, int64_t(lAdjust));
                break;
            }
            default
            {
                OT_API_Output(0, "ERROR! OTAPI_Func.Send() activated, with bad function type: ");
                OT_API_Output(0, concat(to_string(this.funcType),"\n"));
                 break;
            }
        }
        // Here we're returning this value.
        //
        nRetVal
    }






    // **********************************************************************


    def OTAPI_Func::SendRequestLowLevel(theFunction, IN_FUNCTION)
    {
        var MsgUtil	= Utility()
        var strLocation = concat("OTAPI_Func::SendRequestLowLevel: ", IN_FUNCTION)
        // --------------------------------------------------------------------
        OT_API_FlushMessageBuffer()
        // --------------------------------------------------------------------
        var nRun = theFunction.Run()  // <===== ATTEMPT TO SEND THE MESSAGE HERE...
        
        if (nRun == (-1))  // if the requestNumber returned by the send-attempt is -1, that means it DIDN'T SEND (error)
        {
            OT_API_Output(0, strLocation + ": Failed to send message due to error.\n")
            
            theFunction.nRequestNum  = (-1)
        }
        else if (nRun == 0) // if the requestNumber returned by the send-attempt is 0, it means no error, but nothing was sent. (Like processing an empty box.)
        {
            OT_API_Output(0, strLocation + ": Didn't send this message, but NO error occurred, either. (For example, a request to process an empty Nymbox will return 0, meaning, nothing was sent, but also no error occurred.)\n")
            
            theFunction.nRequestNum  = 0
        }
        else if (nRun == (-2)) // -2 is also possible at some future date. (If the request number won't fit in an int, this is returned and then you can retrieve the actual number via a separate call.)
        {
            OT_API_Output(0, strLocation + ": ERROR, not supported. (-2 was returned.)\n")
            
            // TODO: Have an OT API call here, which retrieves the request number
            // (It must be too large to fit into an integer, which is why this happened.)
            
            theFunction.nRequestNum  = (-1)
        }
        else
        {
            theFunction.nRequestNum  = nRun
        }
        
        // BY this point, we definitely have the request number, which means the
        // message was actually SENT. (At least.) This also means we can use nRun
        // later to query for a copy of that sent message (like if we need to clawback
        // the transaction numbers from it later, once we confirm whether the server
        // actually never got it.)
        //
        theFunction.nRequestNum
    }

    // **********************************************************************

    def OTAPI_Func::SendTransaction(theFunction, IN_FUNCTION)
    {
        var nTotalRetries = 2
        this.SendTransaction(theFunction, IN_FUNCTION, nTotalRetries)
    }

    def OTAPI_Func::SendTransaction(theFunction, IN_FUNCTION, nTotalRetries)
    {
        var MsgUtil	    = Utility()
        var strLocation = concat("OTAPI_Func::SendTransaction: ", IN_FUNCTION)
        // --------------------------------------------------------------------
        
        if (!MsgUtil.getIntermediaryFiles(theFunction.serverID, theFunction.nymID, theFunction.accountID, false)) // bForceDownload=false)) 
        {
            OT_API_Output(0, strLocation + ", getIntermediaryFiles returned false. (It couldn't download files that it needed.)\n")
            return ""
        }

        // **********************************************************************
        // GET TRANSACTION NUMBERS HERE IF NECESSARY.
        //
        var	bTrue = true

        var getnym_trnsnum_count = OT_API_GetNym_TransactionNumCount(theFunction.serverID, theFunction.nymID)
        var configTxnCount       = MsgUtil.getNbrTransactionCount()
        var b1                   = (theFunction.nTransNumsNeeded > configTxnCount)
        var comparative          = 0
        
        if (b1)
        {	comparative = theFunction.nTransNumsNeeded;	}
        else
        {	comparative = configTxnCount;	}
        // -------------------------------------------------------        
        if (getnym_trnsnum_count < comparative) 
        {
            OT_API_Output(0, strLocation + ", I don't have enough transaction numbers to perform this transaction. Grabbing more now...\n")        
            MsgUtil.setNbrTransactionCount(comparative)
            bTrue = MsgUtil.getTransactionNumbers(theFunction.serverID, theFunction.nymID)
            MsgUtil.setNbrTransactionCount(configTxnCount)
        }
        // ---------------------------
        //
        var f_temp = fun(MsgUtil, strLocation, comparative, configTxnCount, serverID, nymID) 
        { 
            var getnym_trnsnum_count = OT_API_GetNym_TransactionNumCount(serverID, nymID)

            if (getnym_trnsnum_count < comparative) // try a second time.
            {
                OT_API_Output(0, strLocation + ", failure: MsgUtil.getTransactionNumbers. (Trying again...)\n")

                // (the final parameter, the 'false' is us telling getTransNumbers that
                // it can skip the first call to getTransNumLowLevel)
                //
                MsgUtil.setNbrTransactionCount(comparative)
                var bTrue = MsgUtil.getTransactionNumbers(serverID, nymID, false)
                MsgUtil.setNbrTransactionCount(configTxnCount)
            }
        }
        // ---------------------------
        
        f_temp(MsgUtil, strLocation, comparative, configTxnCount, theFunction.serverID, theFunction.nymID) // second try
        f_temp(MsgUtil, strLocation, comparative, configTxnCount, theFunction.serverID, theFunction.nymID) // third try
        
        // --------------------------------------
        // Giving up, if still a failure by this point.
        //
        getnym_trnsnum_count = OT_API_GetNym_TransactionNumCount(theFunction.serverID, theFunction.nymID)
        
        if (getnym_trnsnum_count < comparative)
        {
            OT_API_Output(0, strLocation + ", third failure: MsgUtil.getTransactionNumbers. (Giving up.)\n")
            return ""
        }
        // ************************************************************************
        
        var bCanRetryAfterThis = OTBool(false)

        var strResult = this.SendRequestOnce(   theFunction,
                                           IN_FUNCTION,
                                           true,   // bIsTransaction      = true;
                                           true,   // bWillRetryAfterThis = true
                                           bCanRetryAfterThis) // output        
        // -------------------------------------------------------
        
        if (VerifyStringVal(strResult))
        {
            OT_API_Output(0, " Getting Intermediary files.. \n")

            if (!MsgUtil.getIntermediaryFiles(theFunction.serverID, theFunction.nymID, theFunction.accountID, true)) // bForceDownload=true
            {
                OT_API_Output(0, strLocation + ", getIntermediaryFiles returned false. (After a success sending the transaction. Strange...)\n")
                return ""
            }
            // -----------------------------
            return strResult // success!
        }
        
        
        //
        // Maybe we have an old Inbox or something.
        //
        
        
        // TODO!!  SECURITY:  This is where a GOOD CLIENT (vs. a test client)
        // will verify these intermediary files against your LAST SIGNED RECEIPT,
        // using OT_API_VerifySomethingorother().
        // See verifyFiles() at the bottom of this file.
        // Add some kind of warning Modal Dialog here, since it's actually
        // normal for a NEW account (never had any receipts yet.) But for
        // any other account, this should ALWAYS VERIFY!
        //
        // Another note: this should happen INSIDE the getIntermediaryFiles call itself,
        // and all similar calls.  You simply should not download those files,
        // without verifying them also. Otherwise you could end up signing
        // a future bad receipt, based on malicious, planted intermediary files.
        
        var nRetries = nTotalRetries;
        
        while ((nRetries > 0) && !VerifyStringVal(strResult) && bCanRetryAfterThis.getBooleanValue())
        {
            --nRetries
            // -------------------------------
            var bWillRetryAfterThis = true
            
            if ((nRetries == 0) || !bCanRetryAfterThis.getBooleanValue())
            {
                bWillRetryAfterThis = false
            }
            
            strResult = this.SendRequestOnce( theFunction, IN_FUNCTION, true, bWillRetryAfterThis, bCanRetryAfterThis)
            
            // ---------------------------
            // In case of failure, we want to get these before we re-try.
            // But in case of success, we also want to get these, so we can
            // see the results of our success. So we get these either way...
            //
            if (VerifyStringVal(strResult))
            {
                if (!MsgUtil.getIntermediaryFiles(theFunction.serverID, theFunction.nymID, theFunction.accountID, true)) // bForceDownload=true
                {
                    OT_API_Output(0, strLocation + ", getIntermediaryFiles (loop) returned false even after successfully sending the transaction.\n")
                    return ""
                }
                break
            }
            // -------------------------------
        } // while
        
        // Here we return strResult, for good or ill.
        //
        strResult
    }


    // **********************************************************************
    

    def OTAPI_Func::SendRequest(theFunction, IN_FUNCTION)  
    {
        var MsgUtil	= Utility()
        // --------------------------------------------------------------------
        var bCanRetryAfterThis = OTBool(false)
        // -------------------------------------------------------
        var strResult = this.SendRequestOnce( theFunction, IN_FUNCTION, false,/*bIsTransaction=false*/ true, /* bWillRetryAfterThis=true*/ bCanRetryAfterThis)
        // -------------------------------------------------------
        
        if (!VerifyStringVal(strResult) && bCanRetryAfterThis.getBooleanValue())
        {
            strResult = this.SendRequestOnce(theFunction, IN_FUNCTION, false, /* bIsTransaction=false;*/ false, /*bWillRetryAfterThis=false*/ bCanRetryAfterThis) // unused in this case, I suppose. It's still returned as output.
        }
        // Here we return strResult.
        //
        strResult
    }


    // **********************************************************************


    def OTAPI_Func::SendRequestOnce(theFunction, IN_FUNCTION, bIsTransaction, bWillRetryAfterThis, bCanRetryAfterThis)
    {
        var MsgUtil	= Utility()
        var strLocation = concat("OTAPI_Func::SendRequestOnce: ", IN_FUNCTION)
        // --------------------------------------------------------------------
        if (!VerifyOTBoolRef(bCanRetryAfterThis))
        {
            OT_API_Output(0, strLocation + ", Error: bCanRetryAfterThis was null.\n")
            return ""
        }
        bCanRetryAfterThis.setBooleanValue(false)
        // ----------------------------------------------
        var strReply = ""
        var nlocalRequestNum = this.SendRequestLowLevel(theFunction, IN_FUNCTION)  // <========   FIRST ATTEMPT!!!!!!
        
        if ((nlocalRequestNum == (-1)) || (nlocalRequestNum == 0))
        {
            return ""
        }
        else // 1 and default.
        {    
            if (nlocalRequestNum < (-1))
            {
                return ""
            }
            
            strReply = MsgUtil.ReceiveReplyLowLevel(theFunction.serverID, theFunction.nymID, nlocalRequestNum, IN_FUNCTION)  // <==== Here we RECEIVE the REPLY...
        }

        // Below this point, we definitely have a request number.
        // (But not yet necessarily a reply...)
        //
        // ----------------------------------------------
        
        // nlocalRequestNum is positive and contains the request number from sending.
        //
        // nReplySuccess contains status of the REPLY to that sent message.
        // nReplySuccess contains:
        //   0 == FAILURE reply msg from server,
        //   1 == SUCCESS reply msg from server (transaction could be success or fail.)
        //  -1 == (ERROR)
        //
        // strReply contains the reply itself (or null.)
        //
        var nReplySuccess      = VerifyMessageSuccess(strReply)
        // -----------------------------------------------------------------------------------------------------
        var bMsgReplyError     = (!VerifyStringVal(strReply) || (nReplySuccess < 0))
        // -----------------------------------------------------------------------------------------------------
        var bMsgReplySuccess   = (!bMsgReplyError && (nReplySuccess  > 0))
        var bMsgReplyFailure   = (!bMsgReplyError && (nReplySuccess == 0))
        // -----------------------------------------------------------------------------------------------------
        // -----------------------------------------------------------------------------------------------------
        var bMsgBalanceError
        var bMsgBalanceSuccess
        var bMsgBalanceFailure
        // -----------------------------------------------------------------------------------------------------
        var bMsgTransError
        var bMsgTransSuccess
        var bMsgTransFailure
        // -----------------------------------------------------------------------------------------------------
        // -----------------------------------------------------------------------------------------------------
        var bMsgAnyError
        var bMsgAnyFailure
        // -----------------------------------------------------------------------------------------------------
        var bMsgAllSuccess
        // -----------------------------------------------------------------------------------------------------
        
        // If you EVER are in a situation where you have to harvest numbers
        // back, it will ONLY be for transactions, not normal messages. (Those
        // are the only ones that USE transaction numbers.)
        //
        var nTransSuccess
        var nBalanceSuccess
        //
        if (bIsTransaction) // This request contains a TRANSACTION...
        {
            if (bMsgReplySuccess) // If message was success, then let's see if the transaction was, too.
            {
                nBalanceSuccess = OT_API_Msg_GetBlnceAgrmntSuccess(theFunction.serverID, theFunction.nymID, theFunction.accountID, strReply) 

                if (nBalanceSuccess > 0)
                {
                    // Sometimes a transaction is sent that is meant to "fail" in order to cancel itself from
                    // ever being run in the future. It's being cancelled. In that case, whether the server reply
                    // itself is acknowledged or rejection, either way, IsCancelled() will be set to TRUE.
                    // This is used when cancelling a cheque, or a payment plan, or a smart contract, so that it
                    // can never be activated at some future time.
                    //
                    // Therefore when we see that IsCancelled is set to TRUE, we interpret it as a "success" as far
                    // as the UI is concerned, even though behind the scenes, it is still "rejected" and transaction
                    // numbers were harvested from it.
                    //
                    var nTransCancelled = 1
                    nTransCancelled = OT_API_Msg_IsTransactionCanceled (theFunction.serverID, theFunction.nymID, theFunction.accountID, strReply)
                    
                    // If it's not cancelled, then we assume it's a normal transaction (versus a cancellation)
                    // and we check for success/failure as normal...
                    //
                    if (1 != nTransCancelled)
                    {
                        nTransSuccess   = OT_API_Msg_GetTransactionSuccess (theFunction.serverID, theFunction.nymID, theFunction.accountID, strReply)
                    }
                    else // If it WAS cancelled, then for the UI we say "Success" even though OT behind the scenes is harvesting as though it failed.
                    {    // (Which is what we want to happen, in the case that a cancellation was performed.)
                         // This way, the UI won't go off doing a bunch of unnecessary retries for a "failed" transaction.
                         // (After all, if it was cancelled, then we know for a fact that all future retries will fail anyway.)
                         //
                        nTransSuccess   = 1
                    }
                }
                else
                {
                    nTransSuccess = (-1)
                }
            }
            else
            {
                nBalanceSuccess = (-1)
                nTransSuccess   = (-1)
            }
            // All of these booleans (except "error") represent RECEIVED ANSWERS from the server.
            // In other words, "failure" does not mean "failed to find message."
            // Rather, it means "DEFINITELY got a reply, and that reply says status==failure."
            //
            // -----------------------------------------------------------------------------------------------------
            bMsgBalanceError   = (!VerifyStringVal(strReply) || (nBalanceSuccess < 0))
            bMsgBalanceSuccess = (!bMsgReplyError && !bMsgBalanceError && (nBalanceSuccess  > 0))
            bMsgBalanceFailure = (!bMsgReplyError && !bMsgBalanceError && (nBalanceSuccess == 0))
            // -----------------------------------------------------------------------------------------------------
            bMsgTransError     = (!VerifyStringVal(strReply) || (nTransSuccess   < 0))
            bMsgTransSuccess   = (!bMsgReplyError && !bMsgBalanceError && !bMsgTransError && (nTransSuccess  > 0))
            bMsgTransFailure   = (!bMsgReplyError && !bMsgBalanceError && !bMsgTransError && (nTransSuccess == 0))
            // -----------------------------------------------------------------------------------------------------
            // -----------------------------------------------------------------------------------------------------
            bMsgAnyError       = (bMsgReplyError   || bMsgBalanceError   || bMsgTransError)
            bMsgAnyFailure     = (bMsgReplyFailure || bMsgBalanceFailure || bMsgTransFailure)
            // -----------------------------------------------------------------------------------------------------
            bMsgAllSuccess     = (bMsgReplySuccess && bMsgBalanceSuccess && bMsgTransSuccess)
            // -----------------------------------------------------------------------------------------------------
        }
        else // it's NOT a transaction, but a normal message..
        {
            nBalanceSuccess = (-1)
            nTransSuccess   = (-1)
            // -----------------------------------------------------------------------------------------------------
            bMsgBalanceError   = false
            bMsgBalanceSuccess = false
            bMsgBalanceFailure = false
            // -----------------------------------------------------------------------------------------------------
            bMsgTransError     = false
            bMsgTransSuccess   = false
            bMsgTransFailure   = false
            // -----------------------------------------------------------------------------------------------------
            // -----------------------------------------------------------------------------------------------------
            bMsgAnyError       = (bMsgReplyError)
            bMsgAnyFailure     = (bMsgReplyFailure)
            // -----------------------------------------------------------------------------------------------------
            bMsgAllSuccess     = (bMsgReplySuccess)
            // -----------------------------------------------------------------------------------------------------            
        }
        // ****************************************************************************
        
        // We know the message SENT. The above logic is about figuring out whether the reply message,
        // the transaction inside it, and the balance agreement inside that transaction, whether
        // any of those three things is a definite error, a definite failure, or a definite success.
        // (Any one of those things could be true, OR NOT, and we can only act as if they are, if we
        // have definitive proof in any of those cases.)
        //
        // The below logic is about what sort of REPLY we may have gotten (if anything.)
        // Without a definite reply we cannot claw back. But the Nymbox can show us this answer,
        // either now, or later...
        //
        if (bMsgAllSuccess)
        {
            // the Msg was a complete success, including the message
            // AND the transaction AND the balance agreement.
            // Therefore, there's DEFINITELY nothing to clawback.
            //
            // (Thus I RemoveSentMessage for the message, since 
            // I'm totally done with it now. NO NEED TO HARVEST anything, either.)
            //
//          var nRemoved = OT_API_RemoveSentMessage(Integer.toString(nlocalRequestNum), theFunction.serverID, theFunction.nymID);
            //            
            // NOTE: The above call is unnecessary, since a successful reply means
            // we already received the successful server reply, and OT's "ProcessServerReply"
            // already removed the sent message from the sent buffer (so no need to do that here.)
            
//          OT_API_Output(0, strLocation + ", SendRequestOnce(): OT_API_RemoveSentMessage: " + nRemoved);
            
            return strReply  
            
        }
        // In this case we want to grab the Nymbox and see if the replyNotice is there.
        // If it IS, then OT server DEFINITELY replied to it (the MESSAGE was a success,
        // whether the transaction inside of it was success or fail.) So we know bMsgReplySuccess
        // is true, if we find a replyNotice.
        // From there, we can also check for transaction success.
        //
        else if (bMsgAnyError || bMsgAnyFailure) // let's resync, and clawback whatever transaction numbers we might have used on the Request...
        {                
            var bWasGetReqSent = OTBool(false)
            var nGetRequest    = MsgUtil.getRequestNumber(theFunction.serverID, theFunction.nymID, bWasGetReqSent)  // <==== RE-SYNC ATTEMPT...
            // ------------------------------------------
            // GET REQUEST WAS A SUCCESS.
            //
            if (bWasGetReqSent.getBooleanValue() && (nGetRequest > 0)) // success
            {
                bCanRetryAfterThis.setBooleanValue(true)
                // ------------------------------------------------------------------------------
                // But--if it was a TRANSACTION, then we're not done syncing yet!
                //
                if (bIsTransaction) 
                {
                    bCanRetryAfterThis.setBooleanValue(false)
                    // -------------------------------------------
                    //
                    // Maybe we have an old Inbox or something.
                    // NEW CODE HERE FOR DEBUGGING (THIS BLOCK)
                    //
                    var bForceDownload = true
                    if (!MsgUtil.getIntermediaryFiles(theFunction.serverID, theFunction.nymID, theFunction.accountID, bForceDownload)) // bForceDownload=true
                    {
                        OT_API_Output(0, strLocation + ", getIntermediaryFiles returned false. (After a failure to send the transaction. Thus, I give up.)\n")
                        return ""
                    }
                    // -------------------------------------------
                    var bWasFound    = OTBool(false)
                    var bWasSent     = OTBool(false)
                    
                    var the_foursome = OTfourbool(bMsgReplySuccess, bMsgReplyFailure, bMsgTransSuccess, bMsgTransFailure)
                    
                    bForceDownload   = false
                    
                    var nProcessNymboxResult = MsgUtil.getAndProcessNymbox_8(theFunction.serverID, theFunction.nymID, bWasSent, bForceDownload, nlocalRequestNum, bWasFound, bWillRetryAfterThis, the_foursome)
                    
// bHarvestingForRetry,// bHarvestingForRetry is INPUT, in the case nlocalRequestNum needs to be harvested before a flush occurs.
// --------------------
                                                        
//  bMsgReplySuccess,    // bMsgReplySuccess is INPUT, and is in case nlocalRequestNum needs to be HARVESTED before a FLUSH happens.
//  bMsgReplyFailure,    // bMsgReplyFailure is INPUT, and is in case nlocalRequestNum needs to be HARVESTED before a FLUSH happens.
//  bMsgTransSuccess,    // bMsgTransSuccess is INPUT, and is in case nlocalRequestNum needs to be HARVESTED before a FLUSH happens.
//  bMsgTransFailure)    // Etc.
                    // -------------------------------------------
                    if ((bWasSent.getBooleanValue() && (1 == nProcessNymboxResult)) || !bWasSent.getBooleanValue() && (0 == nProcessNymboxResult))// success processing Nymbox.
                    {
                        bCanRetryAfterThis.setBooleanValue(true)
                    }
                    // -------------------------------------------
                    
                    // This means a request number was returned, since the processNymbox failed,
                    // and hasn't been properly harvested, so we either need to harvest it for a re-try,
                    // or flush it.
                    //
                    else if (bWasSent.getBooleanValue() && (nProcessNymboxResult > 1))
                    {
                        var strNymbox = OT_API_LoadNymboxNoVerify(theFunction.serverID, theFunction.nymID) // FLUSH SENT MESSAGES!!!!  (AND HARVEST.)
                        
                        // *******************************************************
                        if (VerifyStringVal(strNymbox))
                        {
                            OT_API_FlushSentMessages(false, /*harvesting-for-retry==OT_FALSE*/ theFunction.serverID, theFunction.nymID, strNymbox)
                        }
                    }
                } // if (bIsTransaction)
                // -----------------------------------------------------------------------                                    
            } // if getRequest was success.
            else
            {
                OT_API_Output(0, strLocation + ", Failure: Never got reply from server, so tried getRequest, and that failed too. (I give up.)\n")
                
                // Note: cannot harvest transaction nums here because I do NOT know for sure
                // whether the server has replied to the message or not! (Not until I successfully
                // download my Nymbox.) Therefore, do NOT harvest or flush, but hold back and wait
                // until the next attempt does a successful getNymbox and THEN do a "flush sent" after
                // that. (That's the time we'll know for SURE what happened to the original reply.)
                //
                // (Therefore LEAVE the sent message in the sent queue.)
                
                return ""
            }
        } // else if (bMsgAnyError || bMsgAnyFailure)
        // --------------------------------------------------------
        
        // Returning an empty string.
        
        ""         
    }


    // **********************************************************************






















// used for passing and returning values when giving a 
//lambda function to a loop function.
//
attr the_lambda_struct::the_vector        // used for returning a list of something.
attr the_lambda_struct::the_asset_acct    // for newoffer, we want to remove existing offers for the same accounts in certain cases.
attr the_lambda_struct::the_currency_acct // for newoffer, we want to remove existing offers for the same accounts in certain cases.
attr the_lambda_struct::the_scale         // for newoffer as well.
attr the_lambda_struct::the_price         // for newoffer as well.
attr the_lambda_struct::bSelling          // for newoffer as well.

def the_lambda_struct::the_lambda_struct()
{
    this.the_vector     = Vector()
}
// ---------------------------------------




def loadNymOffers(serverID, nymID) 
{
    var offerList
    var storable
    var nUndefRetVal
    
    if (OTDB_Exists("nyms", serverID, "offers", nymID + ".bin")) 
    {
        OT_API_Output(1, "Offers file exists... Querying nyms...\n")
        storable := OTDB_QueryObject(STORED_OBJ_OFFER_LIST_NYM, "nyms", serverID, "offers", nymID + ".bin")
        
        if (!VerifyStorable(storable, "OTDB_Storable"))
        {
            OT_API_Output(0, "Unable to verify storable object. Probably doesn't exist.\n")
            return nUndefRetVal // containing null or undef
        }
        // -----------------------------------------------------
        OT_API_Output(1, "QueryObject worked. Now dynamic casting from storable to a (nym) offerList...\n")
        offerList := OTDB_CAST_OFFER_LIST_NYM(storable)
        
        if (!VerifyStorable(offerList, "OTDB_OfferListNym"))
        {
            OT_API_Output(0, "Unable to dynamic cast a storable to a (nym) offerList.\n")
            return nUndefRetVal // containing null or undef
        }
    }
    
    return offerList  // possibly containing the offerList (if success), or possibly containing a null/undef value (if failure.)
}


def convert_offerlist_to_maps(offerList)
{
    var strLocation = "convert_offerlist_to_maps"
    
    var map_of_maps // return value. (currently undefined or null or whatever. VerifyType("Map") will return false at this point.
    
    // ----------------------------------
    // LOOP THROUGH THE OFFERS and sort them into a map_of_maps, key is: scale-assetID-currencyID
    // the value for each key is a sub-map, with the key: transaction ID and value: the offer data itself.
    //
    var nCount = offerList.GetOfferDataNymCount() // size_t
    var nTemp  = nCount // so it's created as size_t
    
    if (VerifyIntVal(nCount) && (nCount > 0))
    {        
        for (var nIndex = 0; nIndex < nCount; ++nIndex)
        {
            nTemp = nIndex // convert from int to size_t
            var offerData := offerList.GetOfferDataNym(nTemp)
            
            if (!VerifyStorable(offerData, "OTDB_OfferDataNym"))
            {
                OT_API_Output(0, strLocation + ": Unable to reference (nym) offerData on offerList, at index: " + nIndex.to_string() + "\n")
                return map_of_maps
            }
            // -------------------------------------------------------            
            var strScale          = offerData.scale.to_string()
            var strAssetTypeID    = offerData.asset_type_id
            var strCurrencyTypeID = offerData.currency_type_id
            var strSellStatus     = (offerData.selling ? "SELL" : "BUY")
            var strTransactionID  = offerData.transaction_id
            // -------------------------------------------------------            
            var strMapKey  = strScale + "-" + strAssetTypeID + "-" + strCurrencyTypeID
            var sub_map
            
            if (VerifyType(map_of_maps, "Map") && !map_of_maps.empty() && (map_of_maps.count(strMapKey) > 0))
            {
                sub_map := map_of_maps[strMapKey]   
            }
            // -------------------------------
            if (VerifyType(sub_map, "Map")) // the submap already exists for this market.
            {
                OT_API_Output(1, strLocation+": The sub-map already exists!\n")
                
                // Let's just add this offer to the existing submap
                // (There must be other offers already there for the same market,
                // since the submap already exists.)
                //
                // the sub_map for this market is mapped by BUY/SELL ==> the actual
                // offerData.
                //
                var the_second = ObjRef()
                the_second.setRef(offerData)
                
                sub_map[strTransactionID] = the_second
            }
            else // submap does NOT already exist for this market. (Create it...)
            {
                OT_API_Output(1, strLocation+": The sub-map does NOT already exist!\n")
                //
                // Let's create the submap with this new offer, and add it
                // to the main map.
                //
                var the_second = ObjRef()
                the_second.setRef(offerData)
                
                sub_map = [strTransactionID:the_second]
                
                if (VerifyType(map_of_maps, "Map"))
                {
                    map_of_maps[strMapKey] = sub_map
                }
                else
                {
                    map_of_maps = [strMapKey:sub_map]
                }
            }
            // -------------------------------------------------------
            // Supposedly by this point I have constructed a map keyed by the market,
            // which returns a sub_map for each market. Each sub map uses the key "BUY"
            // or "SELL" and that points to the actual offer data. (Like a Multimap.)
            //
            // Therefore we have sorted out all the buys and sells for each market.
            // Later on, we can loop through the main map, and for each market, we can
            // loop through all the buys and sells.
            // -------------------------------------------------------
        } // for (constructing the map_of_maps and all the sub_maps, so that the offers are sorted
        // by market and buy/sell status. 
        // -------------------------------------------
    }
    
    return map_of_maps
}



def output_nymoffer_data(offer_data, nIndex, map_of_maps, sub_map, extra_vals) // if 10 offers are printed for the SAME market, nIndex will be 0..9
{ // extra_vals unused in this function, but not in others that share this parameter profile.
    // (It's used as a lambda.)
    // -------------------------------------------------------
    var strScale          = offer_data.scale.to_string()
    var strAssetTypeID    = offer_data.asset_type_id
    var strCurrencyTypeID = offer_data.currency_type_id
    var strSellStatus     = (offer_data.selling ? "SELL" : "BUY")     
    var strTransactionID  = offer_data.transaction_id
    var strAvailableAssets = (offer_data.total_assets.to_int() - offer_data.finished_so_far.to_int()).to_string()            
    // -------------------------------------------------------
    if (0 == nIndex) // first iteration! (Output a header.)
    {
        OT_API_Output(0, "Scale:\t\t"+strScale+"\n")
        OT_API_Output(0, "Asset:\t\t"+strAssetTypeID+"\n")
        OT_API_Output(0, "Currency:\t"+strCurrencyTypeID+"\n")
        // ---------------        
        OT_API_Output(0, "\nIndex\tTrans#\tType\tPrice\tAvailable\n")
    }
    // ---------------
    //
    // Okay, we have the offer_data, so let's output it!
    //
    print(nIndex.to_string() + "\t" + offer_data.transaction_id + "\t" + strSellStatus + "\t" + offer_data.price_per_scale + "\t" + strAvailableAssets)
    // -------------------------------------------------------
    return 1
}




// If you have a buy offer, to buy silver for $30, and to sell silver for $35,
// what happens tomorrow when the market shifts, and you want to buy for $40 and
// sell for $45 ?
//
// Well, now you need to cancel certain sell orders from yesterday! Because why on
// earth would you want to sell silver for $35 while buying it for $40? (knotwork
// raised this.) That would be buy-high, sell-low. 
//
// Any rational trader would cancel the old $35 sell order before placing a new $40
// buy order!
//
// Similarly, if the market went DOWN such that my old offers were $40 buy / $45 sell,
// and my new offers are going to be $30 buy / $35 sell, then I want to cancel certain
// buy orders for yesterday. After all, why on earth would you want to buy silver for
// $40 meanwhile putting up a new sell order at $35! You would immediately just turn
// around, after buying something, and sell it for LESS? 
//
// Since the user would most likely be forced anyway to do this, for reasons of self-interest,
// it will probably end up as the default behavior here.
//



// RETURN VALUE: extra_vals will contain a list of offers that need to be removed AFTER

def find_strange_offers(offer_data, nIndex, map_of_maps, sub_map, extra_vals) // if 10 offers are printed for the SAME market, nIndex will be 0..9
{
    var strLocation = "find_strange_offers"
    /*
     me: How about this  when you do "opentxs newoffer" I can alter that 
     script to automatically cancel any sell offers for a lower amount 
     than my new buy offer, if they're on the same market at the same scale.
     and vice versa. Vice versa meaning, cancel any bid offers for a higher
     amount than my new sell offer.
     
     knotwork: yeah that would work.
     
     So when placing a buy offer, check all the other offers I already have at the same scale,
     same asset and currency ID. (That is, the same "market" as denoted by strMapKey in "opentxs showmyoffers")
     For each, see if it's a sell offer and if so, if the amount is lower than the amount on
     the new buy offer, then cancel that sell offer from the market. (Because I don't want to buy-high, sell low.)
     
     Similarly, if placing a sell offer, then check all the other offers I already have at the
     same scale, same asset and currency ID, (the same "market" as denoted by strMapKey....) For
     each, see if it's a buy offer and if so, if the amount is higher than the amount of my new
     sell offer, then cancel that buy offer from the market. (Because I don't want some old buy offer
     for $10 laying around for the same stock that I'm SELLING for $8! If I dump 100 shares, I'll receive
     $800--I don't want my software to automatically turn around and BUY those same shares again for $1000!
     That would be a $200 loss.)
     
     This is done here. This function gets called once for each offer that's active for this Nym.
     extra_vals contains the relevant info we're looking for, and offer_data contains the current
     offer (as we loop through ALL this Nym's offers, this function gets called for each one.)
     So here we just need to compare once, and add to the list if the comparison matches.
     */
/*
 attr the_lambda_struct::the_vector        // used for returning a list of something.
 attr the_lambda_struct::the_asset_acct    // for newoffer, we want to remove existing offers for the same accounts in certain cases.
 attr the_lambda_struct::the_currency_acct // for newoffer, we want to remove existing offers for the same accounts in certain cases.
 attr the_lambda_struct::the_scale         // for newoffer as well.
 attr the_lambda_struct::the_price         // for newoffer as well.
 attr the_lambda_struct::bSelling          // for newoffer as well. 
 */
    OT_API_Output(4, strLocation+": About to compare the new potential offer against one of the existing ones...")
    
    if ((extra_vals.the_asset_acct == offer_data.asset_acct_id) && (extra_vals.the_currency_acct == offer_data.currency_acct_id) && (extra_vals.the_scale == offer_data.scale))
    {
        OT_API_Output(4, strLocation+": the account IDs and the scale match...")

        // By this point we know the current offer_data has the same asset acct, currency acct, and scale
        // as the offer we're comparing to all the rest.
        //
        // But that's not enough: we also need to compare some prices:
        //
        // So when placing a buy offer, check all the other offers I already have.
        // For each, see if it's a sell offer and if so, if the amount is lower than the amount on
        // the new buy offer, then cancel that sell offer from the market. (Because I don't want to buy-high, sell low.)
        //
        if (!extra_vals.bSelling && offer_data.selling && (offer_data.price_per_scale.to_int() < extra_vals.the_price.to_int()))
        {
            extra_vals.the_vector.push_back(offer_data.transaction_id)            
        }
        // Similarly, when placing a sell offer, check all the other offers I already have.
        // For each, see if it's a buy offer and if so, if the amount is higher than the amount of my new
        // sell offer, then cancel that buy offer from the market.
        //
        else if (extra_vals.bSelling && !offer_data.selling && (offer_data.price_per_scale.to_int() > extra_vals.the_price.to_int()))
        {
            extra_vals.the_vector.push_back(offer_data.transaction_id)            
        }
    }
    // We don't actually do the removing here, since we are still looping through the maps.
    // So we just add the IDs to a vector so that the caller can do the removing once this loop
    // is over.
    // -------------------------------------------------------
    return 1
}


def iterate_nymoffers_sub_map(map_of_maps, sub_map, the_lambda) 
{
    var extra_vals
    
    return iterate_nymoffers_sub_map(map_of_maps, sub_map, the_lambda, extra_vals) 
}


// low level. map_of_maps and sub_map must be good. (assumed.) 
//
// extra_vals allows you to pass any extra data you want into your 
// lambda, for when it is called. (Like a functor.)
//
def iterate_nymoffers_sub_map(map_of_maps, sub_map, the_lambda, extra_vals) 
{
    // the_lambda must be good (assumed) and must have the parameter profile like this sample:
    // def the_lambda(offer_data, nIndex, map_of_maps, sub_map, extra_vals) // if 10 offers are printed for the SAME market, nIndex will be 0..9
    
    var strLocation = "iterate_nymoffers_sub_map"
    
    // -------------------------------------------
    // Looping through the map_of_maps, we are now on a valid sub_map in this iteration.
    // Therefore let's loop through the offers on that sub_map and output them!
    //
    var range_sub_map := sub_map.range()
    
    if (!VerifyNotNull(range_sub_map))
    {
        OT_API_Output(0, strLocation+": No range retrieved from sub_map. It must be non-existent, I guess.\n")
        return (-1)
    }
    else if (range_sub_map.empty())
    {
        // Should never happen since we already made sure all the sub_maps
        // have data on them. Therefore if this range is empty now, it's a chaiscript
        // bug (extremely unlikely.)
        //
        OT_API_Output(0, strLocation+": Error: A range was retrieved for the sub_map, but the range is empty.\n")
        return (-1)
    }
    // -----------------
    
    var nIndex = -1
    
    // -----------------
    while (!range_sub_map.empty())
    {
        ++ nIndex                
        // ---------------
        var offer_data_pair := range_sub_map.front()
        
        if (!VerifyNotNull(offer_data_pair))
        {
            OT_API_Output(0, strLocation+": Looping through range_sub_map range, and first offer_data_pair fails to verify.\n")
            return (-1)
        }
        // ----------------
        var offer_data   := offer_data_pair.second.the_ref
        
        if (!VerifyStorable(offer_data, "OTDB_OfferDataNym"))
        {
            OT_API_Output(0, strLocation+": Error: offer_data is not an OTDB_OfferDataNym. Type: "+offer_data.get_type_info().name()+"\n")
            return (-1)
        }
        // -------------------------------------------------------

        var nLambda = the_lambda(offer_data, nIndex, map_of_maps, sub_map, extra_vals) // if 10 offers are printed for the SAME market, nIndex will be 0..9
        
        if ((-1) == nLambda)
        {
            OT_API_Output(0, strLocation+": Error: the_lambda failed.\n")
            return (-1)
        }
        // -------------------------------------------------------
        
        range_sub_map.pop_front()
        
    } // while (!range_sub_map.empty())
    // -----------------

    return 1
}



def iterate_nymoffers_maps(map_of_maps, the_lambda) // low level. map_of_maps must be good. (assumed.) 
{
    var extra_vals
    
    return iterate_nymoffers_maps(map_of_maps, the_lambda, extra_vals)
}

// extra_vals allows you to pass any extra data you want into your 
// lambda, for when it is called. (Like a functor.)
//
def iterate_nymoffers_maps(map_of_maps, the_lambda, extra_vals) // low level. map_of_maps must be good. (assumed.) 
{
    // the_lambda must be good (assumed) and must have the parameter profile like this sample:
    // def the_lambda(offer_data, nIndex, map_of_maps, sub_map, extra_vals) // if 10 offers are printed for the SAME market, nIndex will be 0..9
    
    var strLocation = "iterate_nymoffers_maps"
    
    // -------------------------------------------
    // Next let's loop through the map_of_maps and output the offers for each market therein...
    //
    var range_map_of_maps := map_of_maps.range()
    
    if (!VerifyType(range_map_of_maps, "Map_Range"))
    {
        OT_API_Output(0, strLocation+": No range retrieved from map_of_maps. Type is: "+range_map_of_maps.get_type_info().name()+"\n")
        return (-1)
    }
    else if (range_map_of_maps.empty())
    {
        OT_API_Output(0, strLocation+": A range was retrieved for the map_of_maps, but the range is empty.\n")
        return (-1)
    }
    
    var nMainIndex = -1
    
    while (!range_map_of_maps.empty())
    {
        ++nMainIndex // so we can output a header on the FIRST one only.
        
        // ---------------
        var sub_map_pair := range_map_of_maps.front()
        
        if (!VerifyType(sub_map_pair, "Map_Pair"))
        {
            OT_API_Output(0, strLocation+": Looping through map_of_maps range, and first sub_map_pair fails to verify.\n")
            return (-1)
        }
        // ----------------
        var strMapKey = sub_map_pair.first
        
        var sub_map := sub_map_pair.second
        
        if (!VerifyNotNull(sub_map))
        {
            OT_API_Output(0, strLocation+": Error: Sub_map is not a map. (Then how is it even here?? Submaps are only added based on existing offers.)\n")
            return (-1)
        }
        // -----------------
        if (sub_map.empty())
        {
            OT_API_Output(0, strLocation+": Error: Sub_map is empty (Then how is it even here?? Submaps are only added based on existing offers.)\n")
            return (-1)
        }
        // -----------------
        if (0 == nMainIndex) // this is the first iteration of the main output loop...
        {
//          OT_API_Output(0, "\n** MY OFFERS **\n\n")
        }
        // -----------------          

        var nSubMap = iterate_nymoffers_sub_map(map_of_maps, sub_map, the_lambda, extra_vals)

        if ((-1) == nSubMap)
        {
            OT_API_Output(0, strLocation+": Error: while trying to iterate_nymoffers_sub_map.\n")
            return (-1)
        }
        // -----------------          
        
        range_map_of_maps.pop_front()
        
    } // while !range_map_of_maps.empty()
    
    1
}





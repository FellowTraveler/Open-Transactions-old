// ------------------------------------------------------------------
// This is a library written in OTScript, which makes the OT-API
// much easier to use from inside your own OTScripts, by providing
// a higher-level layer.
//
// Think of it as the "standard header" for using OT from a script.
//
// There is similar code to this in Java also, in the OTAPI_Func and
// Utility classes, in the Moneychanger project. They also make the 
// OTAPI much easier to use, by providing a higher-level layer.
//
//  http://www.chaiscript.com/doxygen/namespace_chai_script___language.html
//

// *************************************************************************************

// This is even HIGHER level than otapi.ot!!  This uses those calls to provide a
// single function interface to most of OT.  Like, "WithdrawVoucher" would go here,
// and basically copy the Moneychanger code.
 
 

 
// -----------------------------------------------------------------------------------------------

    def OT_ME::OT_ME() // constructor.
	{
	
    }

// -----------------------------------------------------------------------------------------------
//	REGISTER NYM AT SERVER (or download nymfile, if nym already registered.)
//
    def OT_ME::register_nym(SERVER_ID, NYM_ID) 
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------
		var theRequest := OTAPI_Func(ot_Msg.CREATE_USER_ACCT, SERVER_ID, NYM_ID)
		var	strResponse = theRequest.SendRequest(theRequest, "CREATE_USER_ACCT")

		return strResponse
    }
	
// -----------------------------------------------------------------------------------------------
//	CHECK USER (download a public key)
//
    def OT_ME::check_user(SERVER_ID, NYM_ID, TARGET_NYM_ID) 
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var theRequest := OTAPI_Func(ot_Msg.CHECK_USER, SERVER_ID, NYM_ID, TARGET_NYM_ID)
        var	strResponse = theRequest.SendRequest(theRequest, "CHECK_USER")
        
        return strResponse
    }

// -----------------------------------------------------------------------------------------------
//  CREATE NYM (pseudonym)
//  returns new Nym ID
//
    def OT_ME::create_pseudonym(nKeybits) 
    {
        var strLocation = "OT_ME::create_pseudonym"
        // -------------------        
        var strNymID = OT_API_CreateNym(nKeybits)  // returns new Nym ID
        
        if (!VerifyStringVal(strNymID))
        {
            OT_API_Output(0, strLocation+": Failed in OT_API_CreateNym(keybits == " + nKeybits.to_string() + ")\n")
        }
        // -------------------    
        return strNymID
    }

// -----------------------------------------------------------------------------------------------
//  ISSUE ASSET TYPE
//
    def OT_ME::issue_asset_type(SERVER_ID, NYM_ID, THE_CONTRACT) 
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var theRequest := OTAPI_Func(ot_Msg.ISSUE_ASSET_TYPE, SERVER_ID, NYM_ID, THE_CONTRACT)
        var	strResponse = theRequest.SendRequest(theRequest, "ISSUE_ASSET_TYPE")
        
        return strResponse
    }

// -----------------------------------------------------------------------------------------------
//  RETRIEVE CONTRACT
//
    def OT_ME::retrieve_contract(SERVER_ID, NYM_ID, CONTRACT_ID) 
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var theRequest := OTAPI_Func(ot_Msg.GET_CONTRACT, SERVER_ID, NYM_ID, CONTRACT_ID)
        var	strResponse = theRequest.SendRequest(theRequest, "GET_CONTRACT")
        
        return strResponse
    }

// -----------------------------------------------------------------------------------------------
//  CREATE ASSET ACCOUNT
//
    def OT_ME::create_asset_acct(SERVER_ID, NYM_ID, ASSET_TYPE_ID) 
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var theRequest := OTAPI_Func(ot_Msg.CREATE_ASSET_ACCT, SERVER_ID, NYM_ID, ASSET_TYPE_ID)
        var	strResponse = theRequest.SendRequest(theRequest, "CREATE_ASSET_ACCT")
        
        return strResponse
    }

// -----------------------------------------------------------------------------------------------

    def OT_ME::stat_asset_account(ACCOUNT_ID)
    {    
        var strName          = OT_API_GetAccountWallet_Name(ACCOUNT_ID)
        var strNymID         = OT_API_GetAccountWallet_NymID(ACCOUNT_ID)
        var strServerID      = OT_API_GetAccountWallet_ServerID(ACCOUNT_ID)
        var strAssetID       = OT_API_GetAccountWallet_AssetTypeID(ACCOUNT_ID)
        var lBalance		 = OT_API_GetAccountWallet_Balance(ACCOUNT_ID)
        var strAssetTypeName = OT_API_GetAssetType_Name(strAssetID)
        var strNymName       = OT_API_GetNym_Name(strNymID)
        var strServerName    = OT_API_GetServer_Name(strServerID)
        
        return("   Balance: " + lBalance.to_string() + "   (" + strName + ")\nAccount ID: " + ACCOUNT_ID + "\nAsset Type: " + strAssetID + " ( " + strAssetTypeName + " )\nOwner Nym:  " + strNymID + " ( " + strNymName + " )\nServer:     " + strServerID + " ( " + strServerName + " )")
    }


// -----------------------------------------------------------------------------------------------
// DOWNLOAD ACCOUNT FILES  (account balance, inbox, outbox, etc)
//

    // returns true/false
    def OT_ME::retrieve_account(SERVER_ID, NYM_ID, ACCOUNT_ID) 
    {
        var bForceDownload = false
        return this.retrieve_account(SERVER_ID, NYM_ID, ACCOUNT_ID, bForceDownload)
    }

    // returns true/false
    def OT_ME::retrieve_account(SERVER_ID, NYM_ID, ACCOUNT_ID, bForceDownload) // bForceDownload=false
    {
        var MsgUtil	= Utility()
        // -------------------------
        var bResponse = MsgUtil.getIntermediaryFiles(SERVER_ID, NYM_ID, ACCOUNT_ID, bForceDownload)
        return bResponse
    }

// --------------------------------------------------------------
// SEND TRANSFER  -- TRANSACTION

    def OT_ME::send_transfer(SERVER_ID, NYM_ID, ACCT_FROM, ACCT_TO, AMOUNT, NOTE) 
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var theRequest := OTAPI_Func(ot_Msg.SEND_TRANSFER, SERVER_ID, NYM_ID, ACCT_FROM, ACCT_TO, AMOUNT, NOTE)
        var	strResponse = theRequest.SendTransaction(theRequest, "SEND_TRANSFER")
        
        return strResponse
    }

// -----------------------------------------------------------------------------------------------
// PROCESS INBOX  -- TRANSACTION

    def OT_ME::process_inbox(SERVER_ID, NYM_ID, ACCOUNT_ID, RESPONSE_LEDGER) 
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var theRequest := OTAPI_Func(ot_Msg.PROCESS_INBOX, SERVER_ID, NYM_ID, ACCOUNT_ID, RESPONSE_LEDGER)
        var	strResponse = theRequest.SendTransaction(theRequest, "PROCESS_INBOX")
        
        return strResponse
    }

// -----------------------------------------------------------------------------------------------
	// load_public_key():
	//
	// Load a public key from local storage, and return it (or null).
	//
	def OT_ME::load_public_key(NYM_ID)	// from local storage.
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------		
		var strPubkey = OT_API_LoadPubkey(NYM_ID)		// This version is for "other people"
		// -------------------------
		if (!VerifyStringVal(strPubkey))
		{
			strPubkey = OT_API_LoadUserPubkey(NYM_ID)	// This version is for "the user sitting at the machine."
		}
		return strPubkey // might be null.
	}
	// -------------------------------------------------------
    //
	// load_or_retrieve_pubkey()
	//
	// Load TARGET_NYM_ID from local storage. 
	// If not there, then retrieve TARGET_NYM_ID from server,
	// using NYM_ID to send check_user request. Then re-load
	// and return. (Might still return null.)
	//
	def OT_ME::load_or_retrieve_pubkey(SERVER_ID, NYM_ID, TARGET_NYM_ID)	
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------
        
		var strPubkey = this.load_public_key(TARGET_NYM_ID)

		// -------------------------
		if (!VerifyStringVal(strPubkey))
		{
			var strResponse = this.check_user(SERVER_ID, NYM_ID, TARGET_NYM_ID)
			
			if (1 == VerifyMessageSuccess(strResponse))
			{
				strPubkey = this.load_public_key(TARGET_NYM_ID)		
			}
		}

		return strPubkey; // might be null.
	}
// -----------------------------------------------------------------------------------------------
	
	// SEND USER MESSAGE  (requires recipient public key)
	//
    def OT_ME::send_user_msg_pubkey(SERVER_ID, NYM_ID, RECIPIENT_NYM_ID, RECIPIENT_PUBKEY, THE_MESSAGE) 
	{
		var ot_Msg := OTAPI_Func()      
		// -------------------------
		var theRequest := OTAPI_Func(ot_Msg.SEND_USER_MESSAGE, SERVER_ID, NYM_ID, RECIPIENT_NYM_ID, RECIPIENT_PUBKEY, THE_MESSAGE)
		var	strResponse = theRequest.SendRequest(theRequest, "SEND_USER_MESSAGE")

		return strResponse
    }
	// ---------------------------
	
	// SEND USER MESSAGE  (only requires recipient's ID, and retrieves pubkey automatically)
	//
    def OT_ME::send_user_msg(SERVER_ID, NYM_ID, RECIPIENT_NYM_ID, THE_MESSAGE) 
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------
                
		var strRecipientPubkey = this.load_or_retrieve_pubkey(SERVER_ID, NYM_ID, RECIPIENT_NYM_ID)
        
		// -------------------------
		if (!VerifyStringVal(strRecipientPubkey))
		{
			OT_API_Output(0, "OT_ME::send_user_msg: Unable to load or retrieve public key for recipient: ")
			OT_API_Output(0, concat(RECIPIENT_NYM_ID,"\n"))
			return strRecipientPubkey; // basically this means "return null".
		}
		// -------------------------
        
        var nTemp = this.send_user_msg_pubkey(SERVER_ID, NYM_ID, RECIPIENT_NYM_ID, strRecipientPubkey, THE_MESSAGE)

		return nTemp
    }	
	// --------------------------------------------------------------
	// GET BOX RECEIPT
	// Note: nBoxType is 0 for Nymbox, 1 for Inbox, and 2 for Outbox.
	// Also, if nBoxType is 0 (nymbox) then you have to pass the NymID in the ACCT_ID 
	// argument, as well as the NYM_ID argument (you have to pass it twice...)
	// Otherwise for inbox/outbox, pass the actual ACCT_ID there as normal.
	//
    def OT_ME::get_box_receipt(SERVER_ID, NYM_ID, ACCT_ID, nBoxType, STR_TRANS_NUM) 
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------
		var theRequest := OTAPI_Func(ot_Msg.GET_BOX_RECEIPT, SERVER_ID, NYM_ID, ACCT_ID, nBoxType.to_string(), STR_TRANS_NUM)
		var	strResponse = theRequest.SendRequest(theRequest, "GET_BOX_RECEIPT")

		return strResponse;
    }
	
// -----------------------------------------------------------------------------------------------
	// DOWNLOAD PUBLIC MINT
	//
    def OT_ME::retrieve_mint(SERVER_ID, NYM_ID, ASSET_ID) 
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------
		var theRequest := OTAPI_Func(ot_Msg.GET_MINT, SERVER_ID, NYM_ID, ASSET_ID)
		var	strResponse = theRequest.SendRequest(theRequest, "GET_MINT")

		return strResponse
    }
	
	// --------------------------------------------------------------
	// LOAD MINT (from local storage)
	//
	// To load a mint withOUT retrieving it from server, call:
	//
	// var strMint = OT_API_LoadMint(SERVER_ID, ASSET_ID);
	// It returns the mint, or null.
	// --------------------------------------------------------------
	// LOAD MINT (from local storage).
	// Also, if necessary, RETRIEVE it from the server first.
	//
	// Returns the mint, or null.
	
    def OT_ME::load_or_retrieve_mint(SERVER_ID, NYM_ID, ASSET_ID) 
	{
        // ---------------------------------------------------------
        // HERE, WE MAKE SURE WE HAVE THE PROPER MINT...
        //
        // Download the public mintfile if it's not there, or if it's expired.
        // Also load it up into memory as a string (just to make sure it works.)
        //
        var strMint
        
        // expired or missing.
        if (!OT_API_Mint_IsStillGood(SERVER_ID, ASSET_ID)) 
        {
            OT_API_Output(1, "OT_ME::load_or_retrieve_mint: Mint file is missing or expired. Downloading from server...\n")
            // ----------------------------------------            
            var	strResponse = this.retrieve_mint(SERVER_ID, NYM_ID, ASSET_ID)
            
            if (1 != VerifyMessageSuccess(strResponse)) 
            {
				OT_API_Output(0, "OT_ME::load_or_retrieve_mint: Unable to retrieve mint for IDs: \n")
				OT_API_Output(0, "  Server ID: " + SERVER_ID  + "\n")
				OT_API_Output(0, "   Asset ID: " + ASSET_ID + "\n")
				return strMint // basically this means "return null".			
            }
            // ----------------------------------------
            if (!OT_API_Mint_IsStillGood(SERVER_ID, ASSET_ID))
            {
				OT_API_Output(0, "OT_ME::load_or_retrieve_mint: Retrieved mint, but still 'not good' for IDs: \n")
				OT_API_Output(0, "  Server ID: " + SERVER_ID  + "\n")
				OT_API_Output(0, "   Asset ID: " + ASSET_ID + "\n")
				return strMint // basically this means "return null".			
            }
        }
        //else // current mint IS available already on local storage (and not expired.)
        // ----------------------------------------
        // By this point, the mint is definitely good, whether we had to download it or not.
        // It's here, and it's NOT expired. (Or we would have returned already.)
        // ----------------------------------------
        strMint		= OT_API_LoadMint(SERVER_ID, ASSET_ID)
        
        if (!VerifyStringVal(strMint)) {
            OT_API_Output(0, "OT_ME::load_or_retrieve_mint: Unable to load mint for IDs: \n")
            OT_API_Output(0, concat("Server ID: ", SERVER_ID));	OT_API_Output(0,"\n")
            OT_API_Output(0, concat(" Asset ID: ", ASSET_ID));	OT_API_Output(0,"\n")
        }
        // ----------------------------------------
		return strMint
	}
// -----------------------------------------------------------------------------------------------
	// QUERY ASSET TYPES
	//
	// See if some asset types are issued on the server.
	//
	def OT_ME::query_asset_types(SERVER_ID, NYM_ID, ENCODED_MAP)
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------
		var theRequest := OTAPI_Func(ot_Msg.QUERY_ASSET_TYPES, SERVER_ID, NYM_ID, ENCODED_MAP)
		var	strResponse = theRequest.SendRequest(theRequest, "QUERY_ASSET_TYPES")

		return strResponse
    }
// -----------------------------------------------------------------------------------------------
	// CREATE MARKET OFFER  -- TRANSACTION

    def OT_ME::create_market_offer(SERVER_ID, NYM_ID, ASSET_ACCT_ID, CURRENCY_ACCT_ID, scale, minIncrement, quantity, price, bSelling) 
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------
//def OTAPI_Func::OTAPI_Func(theType, p_serverID, p_nymID, assetTypeID, assetAccountID, currencyTypeID, currencyAcctID,
//								scale, minIncrement, quantity, price, bSelling)		// 12 args

		var theRequest := OTAPI_Func(ot_Msg.CREATE_MARKET_OFFER, SERVER_ID, NYM_ID, ASSET_ACCT_ID, CURRENCY_ACCT_ID, scale, minIncrement, quantity, price, bSelling)
		var	strResponse = theRequest.SendTransaction(theRequest, "CREATE_MARKET_OFFER")

		return strResponse
    }
	
	// --------------------------------------------------------------
	// CANCEL MARKET OFFER  -- TRANSACTION
	//	
    def OT_ME::cancel_market_offer(SERVER_ID, NYM_ID, ASSET_ACCT_ID, STR_TRANS_NUM) 
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------

		var theRequest := OTAPI_Func(ot_Msg.CANCEL_MARKET_OFFER, SERVER_ID, NYM_ID, ASSET_ACCT_ID, STR_TRANS_NUM)
		var	strResponse = theRequest.SendTransaction(theRequest, "CANCEL_MARKET_OFFER")

		return strResponse
    }

	// --------------------------------------------------------------
	// CANCEL PAYMENT PLAN  -- TRANSACTION
	//
    def OT_ME::cancel_payment_plan(SERVER_ID, NYM_ID, ACCT_ID, STR_TRANS_NUM) 
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------

		var theRequest := OTAPI_Func(ot_Msg.CANCEL_PAYMENT_PLAN, SERVER_ID, NYM_ID, ACCT_ID, STR_TRANS_NUM)
		var	strResponse = theRequest.SendTransaction(theRequest, "CANCEL_PAYMENT_PLAN")

		return strResponse
    }
// -----------------------------------------------------------------------------------------------

    // ACTIVATE SMART CONTRACT  -- TRANSACTION
    //
    def OT_ME::activate_smart_contract(SERVER_ID, NYM_ID, ACCT_ID, AGENT_NAME, THE_SMART_CONTRACT) 
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
                
//      int OT_API_activateSmartContract(SERVER_ID, NYM_ID, THE_SMART_CONTRACT)

        var theRequest := OTAPI_Func(ot_Msg.ACTIVATE_SMART_CONTRACT, SERVER_ID, NYM_ID, ACCT_ID, AGENT_NAME, THE_SMART_CONTRACT)
        var	strResponse = theRequest.SendTransaction(theRequest, "ACTIVATE_SMART_CONTRACT")
        
        return strResponse
    }
// -----------------------------------------------------------------------------------------------

// TRIGGER CLAUSE (on running smart contract)  -- TRANSACTION
//
def OT_ME::trigger_clause(SERVER_ID, NYM_ID, STR_TRANS_NUM, CLAUSE_NAME, STR_PARAM) 
{
    var ot_Msg := OTAPI_Func()
    // -------------------------
    
    //      int OT_API_triggerClause(const char * SERVER_ID,
    //                               const char * USER_ID,
    //                               const char * TRANSACTION_NUMBER,
    //                               const char * CLAUSE_NAME,
    //                               const char * STR_PARAM);
    
    var theRequest := OTAPI_Func(ot_Msg.TRIGGER_CLAUSE, SERVER_ID, NYM_ID, STR_TRANS_NUM, CLAUSE_NAME, STR_PARAM)
    var	strResponse = theRequest.SendTransaction(theRequest, "TRIGGER_CLAUSE")
    
    return strResponse
}
// -----------------------------------------------------------------------------------------------


// WITHDRAW CASH  -- TRANSACTION
//
def OT_ME::withdraw_cash(SERVER_ID, NYM_ID, ACCT_ID, STR_AMOUNT) 
{
    var ot_Msg := OTAPI_Func()
    // -------------------------
    var theRequest := OTAPI_Func(ot_Msg.WITHDRAW_CASH, SERVER_ID, NYM_ID, ACCT_ID, STR_AMOUNT)
    var	strResponse = theRequest.SendTransaction(theRequest, "WITHDRAW_CASH")
    
    return strResponse
}
// -----------------------------------------------------------------------------------------------


// WITHDRAW VOUCHER  -- TRANSACTION
//
def OT_ME::withdraw_voucher(SERVER_ID, NYM_ID, ACCT_ID, RECIP_NYM_ID, STR_MEMO, STR_AMOUNT) 
{
    var ot_Msg := OTAPI_Func()
    // -------------------------
    
//  static int withdrawVoucher(const std::string SERVER_ID,
//                             const std::string USER_ID,
//                             const std::string ACCT_ID,
//                             const std::string RECIPIENT_USER_ID,
//                             const std::string CHEQUE_MEMO,
//                             const std::string AMOUNT);
    
    var theRequest := OTAPI_Func(ot_Msg.WITHDRAW_VOUCHER, SERVER_ID, NYM_ID, ACCT_ID, RECIP_NYM_ID, STR_MEMO, STR_AMOUNT)
    var	strResponse = theRequest.SendTransaction(theRequest, "WITHDRAW_VOUCHER")
    
    return strResponse
}
// -----------------------------------------------------------------------------------------------

// PAY DIVIDEND  -- TRANSACTION
//
def OT_ME::pay_dividend(SERVER_ID, NYM_ID, SOURCE_ACCT_ID, SHARES_ASSET_ID, STR_MEMO, STR_AMOUNT_PER_SHARE) 
{
    var ot_Msg := OTAPI_Func()
    // -------------------------

    var theRequest := OTAPI_Func(ot_Msg.PAY_DIVIDEND, SERVER_ID, NYM_ID, SOURCE_ACCT_ID, SHARES_ASSET_ID, STR_MEMO, STR_AMOUNT_PER_SHARE)
    var	strResponse = theRequest.SendTransaction(theRequest, "PAY_DIVIDEND")
    
    return strResponse
}
// -----------------------------------------------------------------------------------------------


def OT_ME::deposit_cheque(SERVER_ID, NYM_ID, ACCT_ID, STR_CHEQUE)
{
    var ot_Msg := OTAPI_Func()
    // ---------------------------------------------------
    var theRequest  = OTAPI_Func(ot_Msg.DEPOSIT_CHEQUE, SERVER_ID, NYM_ID, ACCT_ID, STR_CHEQUE)
    var strResponse = theRequest.SendTransaction(theRequest, "DEPOSIT_CHEQUE") // <========================
    
    return strResponse
}

// -----------------------------------------------------------------------------------------------

def OT_ME::get_market_list(SERVER_ID, NYM_ID)
{
    var ot_Msg := OTAPI_Func()
    // ---------------------------------------------------
    var theRequest := OTAPI_Func(ot_Msg.GET_MARKET_LIST, SERVER_ID, NYM_ID)
    var strResponse = theRequest.SendRequest(theRequest, "GET_MARKET_LIST") // <========================
    
    return strResponse
}

//int OT_API_getMarketOffers(const char * SERVER_ID,
//                           const char * USER_ID,
//                           const char * MARKET_ID, 
//                           const char * MAX_DEPTH) 

def OT_ME::get_market_offers(SERVER_ID, NYM_ID, MARKET_ID, MAX_DEPTH)
{
    var ot_Msg := OTAPI_Func()
    // ---------------------------------------------------
    var theRequest := OTAPI_Func(ot_Msg.GET_MARKET_OFFERS, SERVER_ID, NYM_ID, MARKET_ID, MAX_DEPTH)
    var strResponse = theRequest.SendRequest(theRequest, "GET_MARKET_OFFERS") // <========================
    
    return strResponse
}

def OT_ME::get_nym_market_offers(SERVER_ID, NYM_ID)
{
    var ot_Msg := OTAPI_Func()
    // ---------------------------------------------------
    var theRequest := OTAPI_Func(ot_Msg.GET_NYM_MARKET_OFFERS, SERVER_ID, NYM_ID)
    var strResponse = theRequest.SendRequest(theRequest, "GET_NYM_MARKET_OFFERS") // <========================
    
    return strResponse
}


def OT_ME::get_market_recent_trades(SERVER_ID, NYM_ID, MARKET_ID)
{
    var ot_Msg := OTAPI_Func()
    // ---------------------------------------------------
    var theRequest := OTAPI_Func(ot_Msg.GET_MARKET_RECENT_TRADES, SERVER_ID, NYM_ID, MARKET_ID)
    var strResponse = theRequest.SendRequest(theRequest, "GET_MARKET_RECENT_TRADES") // <========================
    
    return strResponse
}


// *****************************************************************************************************************************



// public boolean 
//def importCashPurse(String serverID, String nymID, String assetID, String userInput, boolean isPurse) 

def importCashPurse(serverID, nymID, assetID, userInput, isPurse) 
{
    var isSuccess = true
    
//    OT_API_Output(0, "importCashPurse, serverID:" + serverID + " nymID:" + nymID + " assetID:" + assetID);
//    OT_API_Output(0, "importCashPurse, userInput purse:" + userInput);
    
    if (VerifyBoolVal(isPurse) && !isPurse) 
    {
//      OT_API_Output(0, "importCashPurse, isPurse:" + isPurse)
        
        var purse = OT_API_CreatePurse(serverID, assetID, nymID)
        
        if (!VerifyStringVal(purse)) 
        {
            OT_API_Output(0, "importCashPurse: Error: OT_API_CreatePurse returned null\n")
            return false
        }
//      OT_API_Output(0, "importCashPurse, OT_API_CreatePurse return :" + purse);
        
        var newPurse = OT_API_Purse_Push(serverID, assetID, nymID, purse, userInput)
        if (!VerifyStringVal(newPurse)) 
        {
            OT_API_Output(0, "importCashPurse: Error: OT_API_Purse_Push returned null\n")
            return false
        }
//      OT_API_Output(0, "importCashPurse, OT_API_Purse_Push returned :" + newPurse);
        userInput = newPurse
    }
//    OT_API_Output(0, "importCashPurse, Before calling OT_API_Wallet_ImportPurse, final purse:" + userInput);
//    OT_API_Output(0, "importCashPurse just before api , serverID:" + serverID + " nymID:" + nymID + " assetID:" + assetID);

    isSuccess = OT_API_Wallet_ImportPurse(serverID, assetID, nymID, userInput) == 1 ? true : false
    
    return isSuccess
}


// -----------------------------------------------------------------------------------------------


//private String 
//def processCashPurse(String serverID, String assetID, String nymID, String oldPurse, ArrayList selectedTokens, String recipientNymID)

def processCashPurse( serverID,  assetID,  nymID,  oldPurse,  selectedTokens,  recipientNymID) : serverID.is_type(string_type) && assetID.is_type(string_type) && nymID.is_type(string_type) && oldPurse.is_type(string_type) && recipientNymID.is_type(string_type)
{
    var newPurse
    
    // By this point, we know that "selected tokens" has a size of 0, or MORE THAN ONE. (But NOT 1 exactly.)
    // (At least, if this function was called by exportCashPurse.)

    
    // This block handles cases where NO TOKENS ARE SELECTED.
    // (Meaning "PROCESS" THEM ALL.)
    //
    if ((selectedTokens.is_var_null()) || (selectedTokens.size() < 1))
    {
//      OT_API_Output(0, "IN Entire Cash Purse")
        
        // newPurse is created, OWNED BY RECIPIENT.
        //
        newPurse = OT_API_CreatePurse(serverID, assetID, recipientNymID)
        
        if (!VerifyStringVal(newPurse))
        {
            OT_API_Output(0, "IN processCashPurse, OT_API_CreatePurse returned null\n");
            return ""
        }
        
        // Iterate through the OLD PURSE. (as tempPurse.)
        //
        var count = OT_API_Purse_Count(serverID, assetID, oldPurse)
        var tempPurse = oldPurse
        
        for (var i = 0; i < count; ++i) 
        {
            // Peek into TOKEN, from the top token on the stack. (And it's STILL on top after this call.)
            //
            var token = OT_API_Purse_Peek(serverID, assetID, nymID, tempPurse)
            
            // Now pop the token off of tempPurse (our iterator for the old purse).
            // Store updated copy of purse (sans token) into "str1".
            //
            var str1 = OT_API_Purse_Pop(serverID, assetID, nymID, tempPurse)
            
            if (!VerifyStringVal(token) || !VerifyStringVal(str1)) 
            {
                OT_API_Output(0, "IN processCashPurse, OT_API_Purse_Peek or OT_API_Purse_Pop returned null... SHOULD NEVER HAPPEN. Returning null.\n")
                return ""
            }
            
            // Since pop succeeded, copy the output to tempPurse (for next iteration, in case any continue's happen below.)
            // Now tempPurse contains what it did before, MINUS ONE TOKEN. (The exported one.)
            //
            tempPurse = str1
            
            // -----------------------
            
            // Change the OWNER on token, from NymID to RECIPIENT.
            // (In this block, we change ALL the tokens in the purse.)
            //
            var exportedToken = OT_API_Token_ChangeOwner(serverID, assetID, token, nymID, recipientNymID)
            
            // If change failed, then continue.
            //
            if (!VerifyStringVal(exportedToken))
            {
                OT_API_Output(0, "IN processCashPurse, OT_API_Token_ChangeOwner returned null...(should never happen) Returning null.\n")
                return ""
            }
            
            // PUSH the EXPORTED TOKEN (new owner) into the new purse (again, recipient is new owner) and save results in "str".
            // Results are, FYI, newPurse+exportedToken.
            //
            var str = OT_API_Purse_Push(serverID, assetID, recipientNymID, newPurse, exportedToken)
            
            // If push failed, then continue.
            if (!VerifyStringVal(str)) 
            {
                OT_API_Output(0, "IN processCashPurse, OT_API_Purse_Push returned null... (should never happen) Returning null.\n")
                return ""
            }
            
            // Since push succeeded, copy "str" (containing newPurse+exportedToken) into newPurse.
            //
            newPurse = str
        } // for
        
        // Save tempPurse to local storage. (For OLD Owner.)
        // By now, all of the tokens have been popped off of this purse, so it is EMPTY.
        // We're now saving the empty purse, since the user exported all of the tokens.
        //
        // THERE MAYBE SHOULD BE AN EXTRA MODAL HERE, that says,
        // "Moneychanger will now save your purse, EMPTY, back to local storage. Are you sure you want to do this?"
        //
//        bool OTAPI_Wrap::SavePurse(const std::string SERVER_ID,
//                                   const std::string ASSET_TYPE_ID,
//                                   const std::string USER_ID,
//                                   const std::string THE_PURSE)
        
        if (!OT_API_SavePurse(serverID, assetID, nymID, tempPurse)) // if FAILURE.
        {
            // No error message if saving fails??
            // No modal?
            //
            // FT: adding log.
            OT_API_Output(0, "IN processCashPurse, IF block OT_API_SavePurse FAILED. SHOULD NEVER HAPPEN!!!!!!\n")
        }
    } // -------------------------------------------------------------------------------------
    // Else, SPECIFIC TOKENS were selected, so process them...
    else 
    {
//      OT_API_Output(0, "Tokens in Cash Purse being processed");
        
        // ----------------------------------------------------------
        // newPurseSelectedTokens is created (CORRECTLY) with recipientNymID as owner.
        // newPurseUnSelectedTokens is created (CORRECTLY) with NymID as owner. (Unselected tokens aren't being exported...)
        //
        var newPurseSelectedTokens   = OT_API_CreatePurse(serverID, assetID, recipientNymID)
        var newPurseUnSelectedTokens = OT_API_CreatePurse(serverID, assetID, nymID)
        
        if (!VerifyStringVal(newPurseSelectedTokens) || !VerifyStringVal((newPurseUnSelectedTokens))) 
        {
            OT_API_Output(0, "IN processCashPurse, 1st or 2nd OT_API_CreatePurse returned null\n")
            return ""
        }
        
        // ----------------------------------------------------------
        // Iterate through oldPurse, using tempPurse as iterator.
        //
        var count = OT_API_Purse_Count(serverID, assetID, oldPurse)
        var tempPurse = oldPurse
        
        for (var i = 0; i < count; ++i) 
        {
            // Peek at the token on top of the stack.
            // (Without removing it.)
            //
            var token = OT_API_Purse_Peek(serverID, assetID, nymID, tempPurse)
            
            // Remove the top token from the stack, and return the updated stack in "str1".
            //
            var str1 = OT_API_Purse_Pop(serverID, assetID, nymID, tempPurse)
            
            if (!VerifyStringVal(str1) || !VerifyStringVal(token)) 
            {
                OT_API_Output(0, "IN processCashPurse, OT_API_Purse_Peek or OT_API_Purse_Pop returned null... returning Null. (SHOULD NEVER HAPPEN.)\n")
                return ""
            }
            
            // Putting updated purse into iterator, so any subsequent "continue"s will work properly.
            //
            tempPurse = str1
            
            // ----------------------------------------
            
            // Grab the TokenID for that token. (Token still has OLD OWNER.)
            //
            var tokenID = OT_API_Token_GetID(serverID, assetID, token)
            
            if (!VerifyStringVal(tokenID)) 
            {
                OT_API_Output(0, "IN processCashPurse, OT_API_Token_GetID returned null... SHOULD NEVER HAPPEN. Returning now.\n")
                return ""
            }
            
            // ----------------------------------------
            
            // At this point, we check TokenID (identifying the current token) to see if it's on the SELECTED LIST.
            //
            if (selectedTokens.range().contains(tokenID)) // We ARE exporting this token. (Its ID was on the list.)
            {
                // CHANGE OWNER from NYM to RECIPIENT
                // "token" now contains EXPORTED TOKEN, with NEW OWNER.
                //
                var exportedToken = OT_API_Token_ChangeOwner(serverID, assetID, token, nymID, recipientNymID)
                
                if (!VerifyStringVal(exportedToken))
                {
                    OT_API_Output(0, "IN processCashPurse, OT_API_Token_GetID or OT_API_Token_ChangeOwner returned null... SHOULD NEVER HAPPEN. Returning now.\n");
                    return ""
                }
                
                // Thus, push exported version of token into new purse for recipient (for selected tokens.)
                //
                var str = OT_API_Purse_Push(serverID, assetID, recipientNymID, newPurseSelectedTokens, exportedToken)
                if (!VerifyStringVal(str)) 
                {
                    OT_API_Output(0, "IN processCashPurse,OT_API_Purse_Push newPurseSelectedTokens returned null... SHOULD NEVER HAPPEN (returning.)\n")
                    return ""
                }
                newPurseSelectedTokens = str
            } 
            else // The token, this iteration, is NOT being exported, but is remaining with the original owner.
            {
                var str = OT_API_Purse_Push(serverID, assetID, nymID, newPurseUnSelectedTokens, token)
                
                if (!VerifyStringVal(str))
                {
                    OT_API_Output(0, "IN processCashPurse,OT_API_Purse_Push newPurseUnSelectedTokens returned null... SHOULD NEVER HAPPEN. Returning null.\n")
                    return ""
                }
                
                newPurseUnSelectedTokens = str
            }
        } // for
        
        // We SAVE newPurseUnSelectedTokens... These remain as the Nym's purse, in local storage.
        //
        if (!OT_API_SavePurse(serverID, assetID, nymID, newPurseUnSelectedTokens)) // if FAILURE.
        {
            // No error message if saving fails??
            // No modal?
            //
            // FT: adding log.
            OT_API_Output(0, "IN processCashPurse, OT_API_SavePurse FAILED. SHOULD NEVER HAPPEN!!!!!!\n")
        }
        
        // The SELECTED ones (with Recipient as owner of purse AND tokens within) are returned as the "newPurse".
        //
        newPurse = newPurseSelectedTokens
    }
    
    return newPurse
}


// -----------------------------------------------------------------------------------------------


// Input: server ID, assetID, Nym of current owner, existing purse, list of selected tokens, Nym of Recipient, and bool isPasted.
// Returns: "new Purse"
//
//public String 
//def exportCashPurse(String serverID, String assetID, String nymID, String oldPurse, ArrayList selectedTokens, String recipientNymID, boolean isPasted) 
def exportCashPurse( serverID,  assetID,  nymID,  oldPurse,  selectedTokens,  recipientNymID,  isPasted) 
{
//  OT_API_Output(0, "exportCashPurse starts, selectedTokens:" + selectedTokens + "\n");
//  Utility.setObj(null);

    // If no recipient, then recipient == Nym.
    //
    if (!VerifyStringVal(recipientNymID) || (recipientNymID.size() == 0))
    {
        OT_API_Output(0, "exportCashPurse: recipientNym empty--using NymID for recipient instead: " + nymID + "\n")
        recipientNymID = nymID
    }
    
    // if "isPasted" AND recipientNymID IS NOT EQUAL TO NymID,
    // Question: meaning of isPasted ?
    //
    if (isPasted && !recipientNymID.equals(nymID)) 
    {
        var recipientPubKey = OT_API_LoadPubkey(recipientNymID)
//      OT_API_Output(0, "recipientPubKey:" + recipientPubKey)
        
        // This whole block is all just about loading the pubkey for the recipient, (if I don't already have it.)
        //
        if (!VerifyStringVal(recipientPubKey)) 
        {
            // ----------------------------------------------------------
            var  ot_Msg := OTAPI_Func()
            var  theRequest   := OTAPI_Func(ot_Msg.CHECK_USER, serverID, nymID, recipientNymID)
            var  strResponse  = theRequest.SendRequest(theRequest, "CHECK_USER")
            
            if (!VerifyStringVal(strResponse))
            {
                OT_API_Output(0, "IN exportCashPurse: theRequest.SendRequest() failed. (I give up.) \n")
                return ""
            }
            // ----------------------------------------------------------
            
            recipientPubKey = OT_API_LoadPubkey(recipientNymID)              
        }
        
        // Still?
        if (!VerifyStringVal(recipientPubKey)) 
        {
            OT_API_Output(0, "exportCashPurse: recipientPubKey is null\n");
            return ""
        }
    }
    // --------------------------------------------------
    
    // By this point, we have verified that we can load the public key for the recipient.
    // (At least, as long as "isPasted" is true.)
    
    var token         = ""
    var exportedToken = ""
    
    // If a single token is selected, then execute this block.
    // Otherwise, go below, and processCashPurse.
    //
    if (selectedTokens.size() == 1) 
    {
        // New Purse is created with Nym as the owner (NOT!!!!!! recipient.)
        //
        var newPurse = OT_API_CreatePurse(serverID, assetID, nymID)
            
        if (!VerifyStringVal(newPurse)) 
        {
            OT_API_Output(0, "OT_API_CreatePurse returned null\n")
            return ""
        }
        
        // "int count" starts out containing the count of the tokens in OLD PURSE.
        //
        var count = OT_API_Purse_Count(serverID, assetID, oldPurse)
        
        var tempPurse = oldPurse // tempPurse now contains a COPY of OLD PURSE. (From old owner...)
        
        for (var i = 0; i < count; ++i) // iterate through tempPurse, all the tokens.
        {
            // "token" now contains the token for this iteration.
            token = OT_API_Purse_Peek(serverID, assetID, nymID, tempPurse) // DOESN'T POP!! Only peeks.
            
            // Here we explicitly "pop" as well, so we are positioned in case of any "continue"s.
            //
            var returnStringVal = OT_API_Purse_Pop(serverID, assetID, nymID, tempPurse)
            
            if (!VerifyStringVal(token) || !VerifyStringVal(returnStringVal)) // this should never happen
            {
                OT_API_Output(0, "IN export cash, OT_API_Purse_Peek returned null... (should never happen.) \n")
                return ""
            }
            
            // tempPurse now contains its former contents, MINUS the token being EXPORTED.
            //
            tempPurse = returnStringVal
            
            // -----------------------------------
            
            // We read the token's ID, so we can see if it is on the list of SELECTED tokens (to be exported...)
            var tokenID = OT_API_Token_GetID(serverID, assetID, token)
            
            // If the Token was selected for export, CHANGE OWNER from NYM to RECIPIENT.
            // "exportedToken" will contain the output version.
            //
            if (selectedTokens.range().contains(tokenID)) 
            {
                exportedToken = OT_API_Token_ChangeOwner(serverID, assetID, token, nymID, recipientNymID)
                // Normally I'd "break" here, since we were only looking to export a single token.
                // However, I still need to iterate the rest of the tokens onto the NEW PURSE, and then SAVE IT.
                // That's why I don't break here, and instead allow the loop to continue.
            } // If the token was NOT selected for export, just push it onto the new purse (for OLD owner, since he still owns it.)
            else // This will happen with ALL TOKENS except ONE.
            {
                returnStringVal = OT_API_Purse_Push(serverID, assetID, nymID, newPurse, token)
                if (!VerifyStringVal(returnStringVal)) // this should never happen
                {
                    OT_API_Output(0, "IN export cash, OT_API_Purse_Push returned null... (should never happen.) Returning null.\n")
                    return ""
                }
                newPurse = returnStringVal
            }
        }
        
        // By this point, we looped through all tokens in tempPurse (containing a copy of oldPurse), and we
        // removed the ONE token being exported, and we called ChangeOwner for that token, and as we looped,
        // we added all the other tokens (NOT being exported) to "newPurse".
        
        // Therefore now we save newPurse, which overwrites the oldPurse that was previously stored there,
        // and contains the remaining, non-exported tokens of the old owner.
        //
        if (!OT_API_SavePurse(serverID, assetID, nymID, newPurse))
        {
            // If SAVE FAILS (==0) then set Utility obj to OLD PURSE.
//          Utility.setObj(oldPurse);   // Displays on screen??
            return ""
        }
        
        // This is either null, or contains the "change owner"d (exported) token.
        //
        return exportedToken // This means a token is sometimes returned (here), and sometimes a purse (below.)
    }
    
    // By this point, we know that "selected tokens" has a size of 0, or MORE THAN ONE.
    
    // Next I create another "newPurse" by calling this function.
    // I pass it the server, asset, NYM ID, OLD PURSE, the selected tokens, and the RECIPIENT NYM.
    //
    var newPurse = processCashPurse(serverID, assetID, nymID, oldPurse, selectedTokens, recipientNymID)
    
    // Whatever is returned from that function, I return here also. Presumably a purse...
    //
    return newPurse
}


// -----------------------------------------------------------------------------------------------


//public boolean
//def depositCashPurse(String serverID, String assetID, String nymID, String oldPurse, ArrayList selectedTokens, String accountID) 
def depositCashPurse( serverID,  assetID,  nymID,  oldPurse,  selectedTokens,  accountID) 
{    
//  Utility.setObj(null);
//  OT_API_Output(0, "depositCashPurse starts, selectedTokens:" + selectedTokens + "\n")
            
    var recipientNymID  = OT_API_GetAccountWallet_NymID(accountID)
    if (!VerifyStringVal(recipientNymID)) 
    {
        OT_API_Output(0, "\ndepositCashPurse: Unable to find recipient Nym based on myacct. \n")
        return (-1)
    }
    // ----------------------------------------
    var newPurse   = processCashPurse(serverID, assetID, nymID, oldPurse, selectedTokens, recipientNymID)
    
    if (!VerifyStringVal(newPurse)) 
    {
        OT_API_Output(0, "Before server OT_API_exchangePurse call, new Purse is empty. \n")
        return (-1)
    }
    // ----------------------------------------
    var  ot_Msg       := OTAPI_Func()
    var  theRequest   := OTAPI_Func(ot_Msg.DEPOSIT_CASH, serverID, recipientNymID, accountID, newPurse)
    var  strResponse  = theRequest.SendTransaction(theRequest, "DEPOSIT_CASH") // <========================
    
    var strAttempt  = "deposit_cash"

    // ***************************************************************
    
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
            
            
    // HERE, WE INTERPRET THE SERVER REPLY, WHETHER SUCCESS, FAIL, OR ERROR...
    
    var nInterpretReply = InterpretTransactionMsgReply(serverID, recipientNymID, accountID, strAttempt, strResponse)
    
    if (1 == nInterpretReply)
    {    
            
        // Download all the intermediary files (account balance, inbox, outbox, etc)
        // since they have probably changed from this operation.
        //
        var bRetrieved = madeEasy.retrieve_account(serverID, recipientNymID, accountID, true) //bForceDownload defaults to false.
        
        OT_API_Output(0, "\nServer response ("+strAttempt+"): SUCCESS depositing cash!\n")
        OT_API_Output(0, (bRetrieved ? "Success" : "Failed") + " retrieving intermediary files for account.\n")
    }
    else // failure. (so we re-import the cash, so as not to lose it...)
    {
//      OT_API_Output(0, "IN depositCashPurse: theRequest.SendTransaction(() failed. (I give up.) \n"))
        // -------------------
        var importStatus = OT_API_Wallet_ImportPurse(serverID, assetID, recipientNymID, newPurse)
        OT_API_Output(0, "Since failure in depositCashPurse, OT_API_Wallet_ImportPurse called. Status of import: " + importStatus + "\n")
        
        if (VerifyBoolVal(importStatus) && !importStatus) 
        {
//          Utility.setObj(newPurse)
        }
        
        return (-1)
    }

    // ***************************************************************
    //
    // Return status to caller.
    //
    return nInterpretReply  
}


// -----------------------------------------------------------------------------------------------


//public boolean 
//def exchangeCashPurse(String serverID, String assetID, String nymID, String oldPurse, ArrayList selectedTokens)
def exchangeCashPurse( serverID,  assetID,  nymID,  oldPurse,  selectedTokens)
{
//  Utility.setObj(null);
//  OT_API_Output(0, " Cash Purse exchange starts, selectedTokens:" + selectedTokens + "\n")

    var newPurse = processCashPurse(serverID, assetID, nymID, oldPurse, selectedTokens, nymID)
    
    if (!VerifyStringVal(newPurse)) 
    {
        OT_API_Output(0, "exchangeCashPurse: Before server OT_API_exchangePurse call, new Purse is empty.. returning false \n")
        return false
    }
    // ------------------------
    var  ot_Msg := OTAPI_Func()
    var  theRequest  := OTAPI_Func(ot_Msg.EXCHANGE_CASH, serverID, nymID, assetID, newPurse)
    var  strResponse  = theRequest.SendTransaction(theRequest, "EXCHANGE_CASH") // <========================
    
    if (!VerifyStringVal(strResponse))
    {
        OT_API_Output(0, "IN exchangeCashPurse: theRequest.SendTransaction(() failed. (I give up.) \n")
        // -------------------
        var importStatus = OT_API_Wallet_ImportPurse(serverID, assetID, nymID, newPurse);
        OT_API_Output(0, "Since failure in exchangeCashPurse, OT_API_Wallet_ImportPurse called, status of import: " + importStatus + "\n")
        if (!importStatus) 
        {
//          Utility.setObj(newPurse)
        }
        
        return false
    }
    // ---------------------------------------        
//  OT_API_Output(0, "exchangeCashPurse ends, status: success.\n")
    
    return true
}




// -----------------------------------------------------------------------------------------------


def OT_ME::deposit_purse(SERVER_ID, NYM_ID, ACCT_ID, STR_PURSE)
{
    var ot_Msg := OTAPI_Func()
    // ---------------------------------------------------
    var theRequest := OTAPI_Func(ot_Msg.DEPOSIT_CASH, SERVER_ID, NYM_ID, ACCT_ID, STR_PURSE)
    var strResponse = theRequest.SendTransaction(theRequest, "DEPOSIT_CASH") // <========================
    
    return strResponse
}

// -----------------------------------------------------------------------------------------------


	 
	 
 /*
  
 DONE:  create nym, register nym, issue asset type, send transfer, accept entire inbox, write cheque.
  
  Next ones:  show purse, withdraw cash, deposit cash, withdraw voucher, deposit cheque.
  
 Need to add functions (like check_user above) for all of these:
 
 	attr OTAPI_Func::CREATE_USER_ACCT (register nym)DONE		
	attr OTAPI_Func::DELETE_USER_ACCT               
	attr OTAPI_Func::CHECK_USER						DONE
	attr OTAPI_Func::SEND_USER_MESSAGE				DONE
	attr OTAPI_Func::ISSUE_ASSET_TYPE               DONE
	attr OTAPI_Func::ISSUE_BASKET                   
	attr OTAPI_Func::CREATE_ASSET_ACCT				DONE			
	attr OTAPI_Func::DELETE_ASSET_ACCT              
	attr OTAPI_Func::EXCHANGE_BASKET                
	attr OTAPI_Func::PROCESS_INBOX                  DONE
	attr OTAPI_Func::DEPOSIT_CASH                   DONE
	attr OTAPI_Func::EXCHANGE_CASH                  
	attr OTAPI_Func::DEPOSIT_CHEQUE                 DONE
	attr OTAPI_Func::WITHDRAW_VOUCHER               DONE
    attr OTAPI_Func::WITHDRAW_CASH                  DONE
    attr OTAPI_Func::PAY_DIVIDEND                   DONE
	attr OTAPI_Func::GET_CONTRACT                   DONE
	attr OTAPI_Func::SEND_TRANSFER                  DONE
	attr OTAPI_Func::GET_MARKET_LIST                
	attr OTAPI_Func::CREATE_MARKET_OFFER			DONE
	attr OTAPI_Func::CANCEL_MARKET_OFFER			DONE
	attr OTAPI_Func::CANCEL_PAYMENT_PLAN			DONE
	attr OTAPI_Func::GET_NYM_MARKET_OFFERS          
	attr OTAPI_Func::GET_MARKET_OFFERS              
	attr OTAPI_Func::GET_MARKET_RECENT_TRADES       
	attr OTAPI_Func::GET_MINT						DONE
	attr OTAPI_Func::QUERY_ASSET_TYPES				DONE
	attr OTAPI_Func::GET_BOX_RECEIPT				DONE

  --- Activate Payment Plan
  
  ------ TANGENT -----------------------------------------
  Use cases that do not require a server message, and thus will have representative
  functions in ot_made_easy.ot EVEN WHEN there is no corresponding server message
  in ot.
  --- stat wallet               DONE
  --- Stat cash purse           
  --- Stat account              DONE
  --- Stat account inbox        DONE
  --- Stat account outbox       DONE
  --- Stat payment inbox        
  --- Stat record box           
  --- encode / decode           DONE
  --- encrypt/decrypt           DONE
  --- Password encrypt/decrypt  DONE
  --- Sign / Verify             DONE
  --- Create asset contract     DONE
  --- Create server contract    DONE
  --- Create symmetric key      DONE
  --- Create pseudonym          DONE
  --- Write cheque              DONE
  --- Verify last acct receipt  
  --- Refresh (download latest) DONE
  --- Refresh Nym               
  --- Propose Payment Plan      
  --- Confirm Payment Plan      
  --- Balance                   DONE
  --- 
  
  ------ END TANGENT -------------------------------------
  
  
Here are parameters for the first group above.
  (They are called in OTAPI_Func, this code is from there):

		else if (this.funcType == this.DELETE_USER_ACCT)
		{	OT_API_deleteUserAccount(this.serverID, this.nymID);	}
		else if (this.funcType == this.GET_NYM_MARKET_OFFERS)
		{	OT_API_getNym_MarketOffers(this.serverID, this.nymID);	}
		else if (this.funcType == this.CREATE_ASSET_ACCT)
		{	OT_API_createAssetAccount(this.serverID, this.nymID, this.assetID);	}
		else if (this.funcType == this.DELETE_ASSET_ACCT)
		{	OT_API_deleteAssetAccount(this.serverID, this.nymID, this.accountID);	}
		else if (this.funcType == this.EXCHANGE_BASKET)
		{	OT_API_exchangeBasket(this.serverID, this.nymID, this.assetID, this.basket, this.bBool);	}
		else if (this.funcType == this.GET_CONTRACT)
		{	OT_API_getContract(this.serverID, this.nymID, this.assetID);	}
		else if (this.funcType == this.ISSUE_ASSET_TYPE)
		{	OT_API_issueAssetType(this.serverID, this.nymID, this.strData);	}
		else if (this.funcType == this.ISSUE_BASKET)
		{	OT_API_issueBasket(this.serverID, this.nymID, this.basket);	}
		else if (this.funcType == this.EXCHANGE_CASH)
		{	OT_API_exchangePurse(this.serverID, this.assetID, this.nymID, this.strData);	}
		else if (this.funcType == this.CANCEL_MARKET_OFFER)
		{	OT_API_cancelMarketOffer(this.serverID, this.nymID, this.accountID, this.strData);	}
		else if (this.funcType == this.PROCESS_INBOX)
		{	OT_API_processInbox(this.serverID, this.nymID, this.accountID, this.strData);	}
		else if (this.funcType == this.DEPOSIT_CASH)
		{	OT_API_notarizeDeposit(this.serverID, this.nymID, this.accountID, this.strData);	}
		else if (this.funcType == this.DEPOSIT_CHEQUE)
		{	OT_API_depositCheque(this.serverID, this.nymID, this.accountID, this.strData);	}
		else if (this.funcType == this.WITHDRAW_CASH)
		{	OT_API_notarizeWithdrawal(this.serverID, this.nymID, this.accountID, this.strData);	}
		else if (this.funcType == this.WITHDRAW_VOUCHER)
		{	OT_API_withdrawVoucher(this.serverID, this.nymID, this.accountID, this.nymID2, this.strData, this.strData2);	}
		else if (this.funcType == this.SEND_TRANSFER)
		{	OT_API_notarizeTransfer(this.serverID, this.nymID, this.accountID, this.accountID2,   this.strData, this.strData2); } // amount and note, for the last two.
		else if (this.funcType == this.GET_MARKET_LIST)
		{	OT_API_getMarketList(this.serverID, this.nymID);	}
		else if (this.funcType == this.GET_MARKET_OFFERS)
		{	OT_API_getMarketOffers(this.serverID, this.nymID, this.strData, this.strData2);	}
		else if (this.funcType == this.GET_MARKET_RECENT_TRADES)
		{	OT_API_getMarketRecentTrades(this.serverID, this.nymID, this.strData);	}
		else if (this.funcType == this.CREATE_MARKET_OFFER)
		{	OT_API_issueMarketOffer(this.serverID, this.nymID, this.assetID, this.accountID, this.assetID2, this.accountID2, 
                        this.strData, this.strData2, this.strData3, this.strData4, this.bBool);
		}

 */
 

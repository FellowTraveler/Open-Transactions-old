// ------------------------------------------------------------------
// This is a library written in OTScript, which makes the OT-API
// much easier to use from inside your own OTScripts, by providing
// a higher-level layer.
//
// Think of it as the "standard header" for using OT from a script.
//
// There is similar code to this in Java also, in the OTAPI_Func and
// Utility classes, in the Moneychanger project. They also make the 
// OTAPI much easier to use, by providing a higher-level layer.
//
//  http://www.chaiscript.com/doxygen/namespace_chai_script___language.html
//

// *************************************************************************************

// This is even HIGHER level than otapi.ot!!  This uses those calls to provide a
// single function interface to most of OT.  Like, "WithdrawVoucher" would go here,
// and basically copy the Moneychanger code.
 
 
// -----------------------------------------------------------------------------------------------

    def OT_ME::OT_ME() // constructor.
	{
	
    }

    // Returns:
    //  True if I have enough numbers, or if there was success getting more transaction numbers.
    //  False if I didn't have enough numbers, tried to get more, and failed somehow.
    //
    def OT_ME::insure_enough_nums(nNumberNeeded, strMyServerID, strMyNymID)
    {
        var MsgUtil    = Utility()
        var bReturnVal = true
        // ------------------------------------------
        if (!VerifyIntVal(nNumberNeeded))
        {
            OT_API_Output(0, "insure_enough_nums: expected nNumberNeeded to be an integer. (Should never happen.)\n")
            return false
        }
        // -------------------------------------------------------
        // Make sure we have at least one transaction number (to write the cheque...)
        //
        var nTransCount = OT_API_GetNym_TransactionNumCount(strMyServerID, strMyNymID)
        
        if (nTransCount < nNumberNeeded)
        {
            OT_API_Output(0, "insure_enough_nums: I don't have enough transaction numbers. Grabbing more now...\n")
            // ---------------------------------------
            var bGotten = MsgUtil.getTransactionNumbers(strMyServerID, strMyNymID, true)
            // -------------------------------------------------------
            var bWasMsgSent    = OTBool(false)
            var bForceDownload = false

            var bRefresh = details_refresh_nym(strMyServerID, strMyNymID, bWasMsgSent, bForceDownload)
            
            if (!bRefresh)
            {
                return false
            }
            // ---------------------------------------
            // Try again.
            //            
            nTransCount = OT_API_GetNym_TransactionNumCount(strMyServerID, strMyNymID)
            
            if (nTransCount < nNumberNeeded)
            {
                OT_API_Output(0, "insure_enough_nums: I still don't have enough transaction numbers (I have "+nTransCount.to_string()+", but I need "+nNumberNeeded.to_string()+".)\n(Tried grabbing some, but failed somehow.)\n")
                return false
            }
            else { bReturnVal = true }
        }
        // -------------------------------------------------------        
        bReturnVal
    }



// -----------------------------------------------------------------------------------------------
//	REGISTER NYM AT SERVER (or download nymfile, if nym already registered.)
//
    def OT_ME::register_nym(SERVER_ID, NYM_ID) 
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------
		var theRequest := OTAPI_Func(ot_Msg.CREATE_USER_ACCT, SERVER_ID, NYM_ID)
		var	strResponse = theRequest.SendRequest(theRequest, "CREATE_USER_ACCT")
        var nSuccess    = VerifyMessageSuccess(strResponse)

        switch(nSuccess)
        {
            case (1)
            {
                var MsgUtil	= Utility()
                
                //	Use the getRequest command, thus insuring that the request number is in sync.
                //
                if (1 != MsgUtil.getRequestNumber(SERVER_ID, NYM_ID))
                {
                    OT_API_Output(0, "\n Succeeded in register_nym, but strange: then failed calling getRequest, to sync the request number for the first time.\n")
                    return ""
                }
                break
            }

            default
            {
                break
            }
        }
        
		return strResponse
    }
	
    
// -------------------------------
// RETRIEVE NYM INTERMEDIARY FILES

    def OT_ME::retrieve_nym(strServerID, strMyNymID, bWasMsgSent, bForceDownload)
    {
        // --------------------------------------------------------------------
        var MsgUtil	= Utility()
        // --------------------------------------------------------------------
        if (1 != MsgUtil.getRequestNumber(strServerID, strMyNymID)) 
        {
            OT_API_Output(0, "\n Failed calling getRequest, to sync the request number. (Finished.)\n")
            return (-1)
        }
        else // If it returns 1, we know for sure that the request number is in sync.
        {
            OT_API_Output(0, "\n\n SUCCESS syncronizing the request number.\n")
        }
        // -------------------------------------------------------
        var nGetAndProcessNymbox = MsgUtil.getAndProcessNymbox_4(strServerID, strMyNymID, bWasMsgSent, bForceDownload)
            
        return nGetAndProcessNymbox
    }

// -----------------------------------------------------------------------------------------------
//	CHECK USER (download a public key)
//
    def OT_ME::check_user(SERVER_ID, NYM_ID, TARGET_NYM_ID) 
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var theRequest := OTAPI_Func(ot_Msg.CHECK_USER, SERVER_ID, NYM_ID, TARGET_NYM_ID)
        var	strResponse = theRequest.SendRequest(theRequest, "CHECK_USER")
        
        return strResponse
    }

// -----------------------------------------------------------------------------------------------
//  CREATE NYM (pseudonym)
//  returns new Nym ID
//
    def OT_ME::create_pseudonym(nKeybits, strNymIDSource, strAltLocation)
    {
        var strLocation = "OT_ME::create_pseudonym"
        // -------------------        
        var strNymID = OT_API_CreateNym(nKeybits, strNymIDSource, strAltLocation)  // returns new Nym ID
        
        if (!VerifyStringVal(strNymID))
        {
            OT_API_Output(0, strLocation+": Failed in OT_API_CreateNym(keybits == " + nKeybits.to_string() + ")\n")
        }
        // -------------------    
        return strNymID
    }

// -----------------------------------------------------------------------------------------------
//  ISSUE ASSET TYPE
//
    def OT_ME::issue_asset_type(SERVER_ID, NYM_ID, THE_CONTRACT) 
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var theRequest := OTAPI_Func(ot_Msg.ISSUE_ASSET_TYPE, SERVER_ID, NYM_ID, THE_CONTRACT)
        var	strResponse = theRequest.SendRequest(theRequest, "ISSUE_ASSET_TYPE")
        
        return strResponse
    }

// -----------------------------------------------------------------------------------------------
//  RETRIEVE CONTRACT
//

    def OT_ME::retrieve_contract(SERVER_ID, NYM_ID, CONTRACT_ID)
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var theRequest := OTAPI_Func(ot_Msg.GET_CONTRACT, SERVER_ID, NYM_ID, CONTRACT_ID)
        var	strResponse = theRequest.SendRequest(theRequest, "GET_CONTRACT")
        
        return strResponse
    }

// -----------------------------------------------------------------------------------------------
//  LOAD OR RETRIEVE CONTRACT
//
    def OT_ME::load_or_retrieve_contract(SERVER_ID, NYM_ID, CONTRACT_ID)
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var strContract = OT_API_LoadAssetContract(CONTRACT_ID)
        // -------------------------
        if (!VerifyStringVal(strContract))
        {
            var strResponse = this.retrieve_contract(SERVER_ID, NYM_ID, CONTRACT_ID)
            
            if (1 == VerifyMessageSuccess(strResponse))
            {
                strContract = OT_API_LoadAssetContract(CONTRACT_ID)
            }
        }
        
        return strContract; // might be null.
    }

// -----------------------------------------------------------------------------------------------
//  CREATE ASSET ACCOUNT
//
    def OT_ME::create_asset_acct(SERVER_ID, NYM_ID, ASSET_TYPE_ID) 
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var theRequest := OTAPI_Func(ot_Msg.CREATE_ASSET_ACCT, SERVER_ID, NYM_ID, ASSET_TYPE_ID)
        var	strResponse = theRequest.SendRequest(theRequest, "CREATE_ASSET_ACCT")
        
        return strResponse
    }

// -----------------------------------------------------------------------------------------------

    def OT_ME::stat_asset_account(ACCOUNT_ID)
    {    
        var strName          = OT_API_GetAccountWallet_Name(ACCOUNT_ID)
        var strNymID         = OT_API_GetAccountWallet_NymID(ACCOUNT_ID)
        var strServerID      = OT_API_GetAccountWallet_ServerID(ACCOUNT_ID)
        var strAssetID       = OT_API_GetAccountWallet_AssetTypeID(ACCOUNT_ID)
        var lBalance		 = OT_API_GetAccountWallet_Balance(ACCOUNT_ID)
        var strAssetTypeName = OT_API_GetAssetType_Name(strAssetID)
        var strNymName       = OT_API_GetNym_Name(strNymID)
        var strServerName    = OT_API_GetServer_Name(strServerID)
        
        return("   Balance: " + lBalance.to_string() + "   (" + strName + ")\nAccount ID: " + ACCOUNT_ID + " ( " + strName + " )\nAsset Type: " + strAssetID + " ( " + strAssetTypeName + " )\nOwner Nym:  " + strNymID + " ( " + strNymName + " )\nServer:     " + strServerID + " ( " + strServerName + " )")
    }


// -----------------------------------------------------------------------------------------------
// DOWNLOAD ACCOUNT FILES  (account balance, inbox, outbox, etc)
//

    // returns true/false
    def OT_ME::retrieve_account(SERVER_ID, NYM_ID, ACCOUNT_ID) 
    {
        var bForceDownload = false
        return this.retrieve_account(SERVER_ID, NYM_ID, ACCOUNT_ID, bForceDownload)
    }

    // returns true/false
    def OT_ME::retrieve_account(SERVER_ID, NYM_ID, ACCOUNT_ID, bForceDownload) // bForceDownload=false
    {
        var MsgUtil	= Utility()
        // -------------------------
        var bResponse = MsgUtil.getIntermediaryFiles(SERVER_ID, NYM_ID, ACCOUNT_ID, bForceDownload)
        return bResponse
    }

// --------------------------------------------------------------
// SEND TRANSFER  -- TRANSACTION

    def OT_ME::send_transfer(SERVER_ID, NYM_ID, ACCT_FROM, ACCT_TO, AMOUNT, NOTE) 
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var theRequest := OTAPI_Func(ot_Msg.SEND_TRANSFER, SERVER_ID, NYM_ID, ACCT_FROM, ACCT_TO, AMOUNT, NOTE)
        var	strResponse = theRequest.SendTransaction(theRequest, "SEND_TRANSFER")
        
        return strResponse
    }

// -----------------------------------------------------------------------------------------------
// PROCESS INBOX  -- TRANSACTION

    def OT_ME::process_inbox(SERVER_ID, NYM_ID, ACCOUNT_ID, RESPONSE_LEDGER) 
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var theRequest := OTAPI_Func(ot_Msg.PROCESS_INBOX, SERVER_ID, NYM_ID, ACCOUNT_ID, RESPONSE_LEDGER)
        var	strResponse = ""
        
        strResponse = theRequest.SendTransaction(theRequest, "PROCESS_INBOX")

        return strResponse
    }

// -----------------------------------------------------------------------------------------------
    // load_public_key():
    //
    // Load a public key from local storage, and return it (or null).
    //
    def OT_ME::load_public_encryption_key(NYM_ID)	// from local storage.
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var strPubkey = OT_API_LoadPubkey_Encryption(NYM_ID)		// This version is for "other people"
        // -------------------------
        if (!VerifyStringVal(strPubkey))
        {
            strPubkey = OT_API_LoadUserPubkey_Encryption(NYM_ID)	// This version is for "the user sitting at the machine."
        }
        return strPubkey // might be null.
    }
    // -------------------------------------------------------
    // load_public_key():
    //
    // Load a public key from local storage, and return it (or null).
    //
    def OT_ME::load_public_signing_key(NYM_ID)	// from local storage.
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var strPubkey = OT_API_LoadPubkey_Signing(NYM_ID)		// This version is for "other people"
        // -------------------------
        if (!VerifyStringVal(strPubkey))
        {
            strPubkey = OT_API_LoadUserPubkey_Signing(NYM_ID)	// This version is for "the user sitting at the machine."
        }
        return strPubkey // might be null.
    }
// -------------------------------------------------------
    //
	// load_or_retrieve_pubkey()
	//
	// Load TARGET_NYM_ID from local storage. 
	// If not there, then retrieve TARGET_NYM_ID from server,
	// using NYM_ID to send check_user request. Then re-load
	// and return. (Might still return null.)
	//
    def OT_ME::load_or_retrieve_encrypt_key(SERVER_ID, NYM_ID, TARGET_NYM_ID)
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var strPubkey = this.load_public_encryption_key(TARGET_NYM_ID)
        // -------------------------
        if (!VerifyStringVal(strPubkey))
        {
            var strResponse = this.check_user(SERVER_ID, NYM_ID, TARGET_NYM_ID)
            
            if (1 == VerifyMessageSuccess(strResponse))
            {
                strPubkey = this.load_public_encryption_key(TARGET_NYM_ID)
            }
        }
        return strPubkey; // might be null.
    }

    def OT_ME::load_or_retrieve_signing_key(SERVER_ID, NYM_ID, TARGET_NYM_ID)
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var strPubkey = this.load_public_signing_key(TARGET_NYM_ID)
        // -------------------------
        if (!VerifyStringVal(strPubkey))
        {
            var strResponse = this.check_user(SERVER_ID, NYM_ID, TARGET_NYM_ID)
            
            if (1 == VerifyMessageSuccess(strResponse))
            {
                strPubkey = this.load_public_signing_key(TARGET_NYM_ID)
            }
        }
        return strPubkey; // might be null.
    }
// -----------------------------------------------------------------------------------------------
	
	// SEND USER MESSAGE  (requires recipient public key)
	//
    def OT_ME::send_user_msg_pubkey(SERVER_ID, NYM_ID, RECIPIENT_NYM_ID, RECIPIENT_PUBKEY, THE_MESSAGE) 
	{
		var ot_Msg := OTAPI_Func()      
		// -------------------------
		var theRequest := OTAPI_Func(ot_Msg.SEND_USER_MESSAGE, SERVER_ID, NYM_ID, RECIPIENT_NYM_ID, RECIPIENT_PUBKEY, THE_MESSAGE)
		var	strResponse = theRequest.SendRequest(theRequest, "SEND_USER_MESSAGE")

		return strResponse
    }
    // ---------------------------
    // SEND USER INSTRUMENT  (requires recipient public key)
    //
    def OT_ME::send_user_pmnt_pubkey(SERVER_ID, NYM_ID, RECIPIENT_NYM_ID, RECIPIENT_PUBKEY, THE_INSTRUMENT)
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var theRequest := OTAPI_Func(ot_Msg.SEND_USER_INSTRUMENT, SERVER_ID, NYM_ID, RECIPIENT_NYM_ID, RECIPIENT_PUBKEY, THE_INSTRUMENT)
        var	strResponse = theRequest.SendRequest(theRequest, "SEND_USER_INSTRUMENT")
        
        return strResponse
    }
    // ---------------------------
    // SEND USER CASH  (requires recipient public key)
    //
    def OT_ME::send_user_cash_pubkey(SERVER_ID, NYM_ID, RECIPIENT_NYM_ID, RECIPIENT_PUBKEY, THE_INSTRUMENT, INSTRUMENT_FOR_SENDER)
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        var theRequest := OTAPI_Func(ot_Msg.SEND_USER_INSTRUMENT, SERVER_ID, NYM_ID, RECIPIENT_NYM_ID, RECIPIENT_PUBKEY, THE_INSTRUMENT, INSTRUMENT_FOR_SENDER)
        var	strResponse = theRequest.SendRequest(theRequest, "SEND_USER_INSTRUMENT")
        
        return strResponse
    }
	// ---------------------------
	// SEND USER MESSAGE  (only requires recipient's ID, and retrieves pubkey automatically)
	//
    def OT_ME::send_user_msg(SERVER_ID, NYM_ID, RECIPIENT_NYM_ID, THE_MESSAGE) 
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------
		var strRecipientPubkey = this.load_or_retrieve_encrypt_key(SERVER_ID, NYM_ID, RECIPIENT_NYM_ID)
		// -------------------------
		if (!VerifyStringVal(strRecipientPubkey))
		{
			OT_API_Output(0, "OT_ME::send_user_msg: Unable to load or retrieve public encryption key for recipient: ")
			OT_API_Output(0, concat(RECIPIENT_NYM_ID,"\n"))
			return strRecipientPubkey; // basically this means "return null".
		}
		// -------------------------
        
        var strResponse = this.send_user_msg_pubkey(SERVER_ID, NYM_ID, RECIPIENT_NYM_ID, strRecipientPubkey, THE_MESSAGE)

		return strResponse
    }	
	// ---------------------------
	// SEND USER PAYMENT  (only requires recipient's ID, and retrieves pubkey automatically)
	//
    def OT_ME::send_user_payment(SERVER_ID, NYM_ID, RECIPIENT_NYM_ID, THE_PAYMENT)
	{
		var ot_Msg := OTAPI_Func()        
		// -------------------------
		var strRecipientPubkey = this.load_or_retrieve_encrypt_key(SERVER_ID, NYM_ID, RECIPIENT_NYM_ID)
		// -------------------------
		if (!VerifyStringVal(strRecipientPubkey))
		{
			OT_API_Output(0, "OT_ME::send_user_payment: Unable to load or retrieve public encryption key for recipient: ")
			OT_API_Output(0, concat(RECIPIENT_NYM_ID,"\n"))
			return strRecipientPubkey; // basically this means "return null".
		}
		// -------------------------
        var strResponse = this.send_user_pmnt_pubkey(SERVER_ID, NYM_ID, RECIPIENT_NYM_ID, strRecipientPubkey, THE_PAYMENT)

		return strResponse
    }	
	// ---------------------------
	// SEND USER CASH  (only requires recipient's ID, and retrieves pubkey automatically)
	//
    def OT_ME::send_user_cash(SERVER_ID, NYM_ID, RECIPIENT_NYM_ID, THE_PAYMENT, SENDERS_COPY)
	{
		var ot_Msg := OTAPI_Func()        
		// -------------------------
		var strRecipientPubkey = this.load_or_retrieve_encrypt_key(SERVER_ID, NYM_ID, RECIPIENT_NYM_ID)
		// -------------------------
		if (!VerifyStringVal(strRecipientPubkey))
		{
			OT_API_Output(0, "OT_ME::send_user_payment: Unable to load or retrieve public encryption key for recipient: ")
			OT_API_Output(0, concat(RECIPIENT_NYM_ID,"\n"))
			return strRecipientPubkey; // basically this means "return null".
		}
		// -------------------------
        var strResponse = this.send_user_cash_pubkey(SERVER_ID, NYM_ID, RECIPIENT_NYM_ID, strRecipientPubkey, THE_PAYMENT, SENDERS_COPY)

		return strResponse
    }	
	// --------------------------------------------------------------
	// GET PAYMENT INSTRUMENT (from payments inbox, by index.)
	//
    def OT_ME::get_payment_instrument(SERVER_ID, NYM_ID, nIndex)
    {
        var PRELOADED_INBOX = ""
        var strInstrument = this.get_payment_instrument(SERVER_ID, NYM_ID, nIndex, PRELOADED_INBOX)
        return strInstrument
    }

    def OT_ME::get_payment_instrument(SERVER_ID, NYM_ID, nIndex, PRELOADED_INBOX) // PRELOADED_INBOX is optional.
	{
        var strInstrument
        var strInbox = VerifyStringVal(PRELOADED_INBOX) ? PRELOADED_INBOX : OT_API_LoadPaymentInbox(SERVER_ID, NYM_ID); // Returns NULL, or an inbox.
        
        if (!VerifyStringVal(strInbox))
        {
            OT_API_Output(1, "\n\n get_payment_instrument:  OT_API_LoadPaymentInbox Failed. (Probably just doesn't exist yet.)\n\n")
            return ""
        }
        else	// Success!
        {
            var nCount = OT_API_Ledger_GetCount(SERVER_ID, NYM_ID, NYM_ID, strInbox)
            
            if (VerifyIntVal(nCount))
            {
                if (nIndex > (nCount - 1))
                {
                    OT_API_Output(0, "Index "+nIndex.to_string()+" out of bounds. (The last index is: " + (nCount-1).to_string() + ". The first is 0.)\n")
                    return ""
                }
            }
            // ------------------------------------------------------------------------
            else
            {
                OT_API_Output(0, "Unable to retrieve size of payments inbox ledger. (Failure.)\n")
                return ""
            }
            // ------------------------------------------------------------------------
            strInstrument = OT_API_Ledger_GetInstrument(SERVER_ID, NYM_ID, NYM_ID, strInbox, nIndex)
            
            if (!VerifyStringVal(strInstrument))
            {
                OT_API_Output(0, "Failed trying to get payment instrument from payments box.\n")
                return ""
            }
            else
            {
                return strInstrument
            }
        }
        return ""
    }
	// --------------------------------------------------------------
	// GET BOX RECEIPT
	// Note: nBoxType is 0 for Nymbox, 1 for Inbox, and 2 for Outbox.
	// Also, if nBoxType is 0 (nymbox) then you have to pass the NymID in the ACCT_ID 
	// argument, as well as the NYM_ID argument (you have to pass it twice...)
	// Otherwise for inbox/outbox, pass the actual ACCT_ID there as normal.
	//
    def OT_ME::get_box_receipt(SERVER_ID, NYM_ID, ACCT_ID, nBoxType, STR_TRANS_NUM) 
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------
		var theRequest := OTAPI_Func(ot_Msg.GET_BOX_RECEIPT, SERVER_ID, NYM_ID, ACCT_ID, nBoxType.to_string(), STR_TRANS_NUM)
		var	strResponse = theRequest.SendRequest(theRequest, "GET_BOX_RECEIPT")

		return strResponse;
    }
	
// -----------------------------------------------------------------------------------------------
	// DOWNLOAD PUBLIC MINT
	//
    def OT_ME::retrieve_mint(SERVER_ID, NYM_ID, ASSET_ID) 
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------
		var theRequest := OTAPI_Func(ot_Msg.GET_MINT, SERVER_ID, NYM_ID, ASSET_ID)
		var	strResponse = theRequest.SendRequest(theRequest, "GET_MINT")

		return strResponse
    }
	
	// --------------------------------------------------------------
	// LOAD MINT (from local storage)
	//
	// To load a mint withOUT retrieving it from server, call:
	//
	// var strMint = OT_API_LoadMint(SERVER_ID, ASSET_ID);
	// It returns the mint, or null.
	// --------------------------------------------------------------
	// LOAD MINT (from local storage).
	// Also, if necessary, RETRIEVE it from the server first.
	//
	// Returns the mint, or null.
	
    def OT_ME::load_or_retrieve_mint(SERVER_ID, NYM_ID, ASSET_ID) 
	{
        // ---------------------------------------------------------
        // HERE, WE MAKE SURE WE HAVE THE PROPER MINT...
        //
        // Download the public mintfile if it's not there, or if it's expired.
        // Also load it up into memory as a string (just to make sure it works.)
        //
        var strMint = ""
        
        // expired or missing.
        if (!OT_API_Mint_IsStillGood(SERVER_ID, ASSET_ID)) 
        {
            OT_API_Output(1, "OT_ME::load_or_retrieve_mint: Mint file is missing or expired. Downloading from server...\n")
            // ----------------------------------------            
            var	strResponse = this.retrieve_mint(SERVER_ID, NYM_ID, ASSET_ID)
            
            if (1 != VerifyMessageSuccess(strResponse)) 
            {
				OT_API_Output(0, "OT_ME::load_or_retrieve_mint: Unable to retrieve mint for IDs: \n")
				OT_API_Output(0, "  Server ID: " + SERVER_ID  + "\n")
				OT_API_Output(0, "   Asset ID: " + ASSET_ID + "\n")
				return strMint // basically this means "return null".			
            }
            // ----------------------------------------
            if (!OT_API_Mint_IsStillGood(SERVER_ID, ASSET_ID))
            {
				OT_API_Output(0, "OT_ME::load_or_retrieve_mint: Retrieved mint, but still 'not good' for IDs: \n")
				OT_API_Output(0, "  Server ID: " + SERVER_ID  + "\n")
				OT_API_Output(0, "   Asset ID: " + ASSET_ID + "\n")
				return strMint // basically this means "return null".			
            }
        }
        //else // current mint IS available already on local storage (and not expired.)
        // ----------------------------------------
        // By this point, the mint is definitely good, whether we had to download it or not.
        // It's here, and it's NOT expired. (Or we would have returned already.)
        // ----------------------------------------
        strMint		= OT_API_LoadMint(SERVER_ID, ASSET_ID)
        
        if (!VerifyStringVal(strMint)) {
            OT_API_Output(0, "OT_ME::load_or_retrieve_mint: Unable to load mint for IDs: \n")
            OT_API_Output(0, concat("Server ID: ", SERVER_ID));	OT_API_Output(0,"\n")
            OT_API_Output(0, concat(" Asset ID: ", ASSET_ID));	OT_API_Output(0,"\n")
        }
        // ----------------------------------------
		return strMint
	}
// -----------------------------------------------------------------------------------------------
	// QUERY ASSET TYPES
	//
	// See if some asset types are issued on the server.
	//
	def OT_ME::query_asset_types(SERVER_ID, NYM_ID, ENCODED_MAP)
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------
		var theRequest := OTAPI_Func(ot_Msg.QUERY_ASSET_TYPES, SERVER_ID, NYM_ID, ENCODED_MAP)
		var	strResponse = theRequest.SendRequest(theRequest, "QUERY_ASSET_TYPES")

		return strResponse
    }
// -----------------------------------------------------------------------------------------------
	// CREATE MARKET OFFER  -- TRANSACTION

    def OT_ME::create_market_offer(SERVER_ID, NYM_ID, ASSET_ACCT_ID, CURRENCY_ACCT_ID, scale, minIncrement, quantity, price, bSelling, strLifespanInSeconds)
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------
//def OTAPI_Func::OTAPI_Func(theType, p_serverID, p_nymID, assetTypeID, assetAccountID, currencyTypeID, currencyAcctID,
//								scale, minIncrement, quantity, price, bSelling)		// 12 args

		var theRequest := OTAPI_Func(ot_Msg.CREATE_MARKET_OFFER, SERVER_ID, NYM_ID, ASSET_ACCT_ID, CURRENCY_ACCT_ID, scale, minIncrement, quantity, price, bSelling)
        
        
        // Cannot have more than 10 parameters in a function call, in this script.
        // So I am forced to set the final parameter by hand, before sending the transaction:
        //
        if (VerifyStringVal(strLifespanInSeconds))
        {
            theRequest.tData = strLifespanInSeconds.to_int()            
        }

		var	strResponse = theRequest.SendTransaction(theRequest, "CREATE_MARKET_OFFER")

		return strResponse
    }
	
	// --------------------------------------------------------------
	// CANCEL MARKET OFFER  -- TRANSACTION
	//	
    def OT_ME::cancel_market_offer(SERVER_ID, NYM_ID, ASSET_ACCT_ID, STR_TRANS_NUM) 
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------

		var theRequest := OTAPI_Func(ot_Msg.CANCEL_MARKET_OFFER, SERVER_ID, NYM_ID, ASSET_ACCT_ID, STR_TRANS_NUM)
		var	strResponse = theRequest.SendTransaction(theRequest, "CANCEL_MARKET_OFFER")

		return strResponse
    }

	// --------------------------------------------------------------
	// CANCEL PAYMENT PLAN  -- TRANSACTION
	//
    def OT_ME::cancel_payment_plan(SERVER_ID, NYM_ID, ACCT_ID, STR_TRANS_NUM) 
	{
		var ot_Msg := OTAPI_Func()
		// -------------------------

		var theRequest := OTAPI_Func(ot_Msg.CANCEL_PAYMENT_PLAN, SERVER_ID, NYM_ID, ACCT_ID, STR_TRANS_NUM)
		var	strResponse = theRequest.SendTransaction(theRequest, "CANCEL_PAYMENT_PLAN")

		return strResponse
    }
// -----------------------------------------------------------------------------------------------

    // ACTIVATE SMART CONTRACT  -- TRANSACTION
    //
    def OT_ME::activate_smart_contract(SERVER_ID, NYM_ID, ACCT_ID, AGENT_NAME, THE_SMART_CONTRACT) 
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
//      int OT_API_activateSmartContract(SERVER_ID, NYM_ID, THE_SMART_CONTRACT)

        var theRequest := OTAPI_Func(ot_Msg.ACTIVATE_SMART_CONTRACT, SERVER_ID, NYM_ID, ACCT_ID, AGENT_NAME, THE_SMART_CONTRACT)
        var	strResponse = theRequest.SendTransaction(theRequest, "ACTIVATE_SMART_CONTRACT")
        
        return strResponse
    }
// -----------------------------------------------------------------------------------------------

    // DEPOSIT PAYMENT PLAN  -- TRANSACTION
    //
    def OT_ME::deposit_payment_plan(SERVER_ID, NYM_ID, THE_PAYMENT_PLAN)
    {
        var ot_Msg := OTAPI_Func()
        // -------------------------
        // NOTE: We have to include the account ID as well. Even though the API call itself
        // doesn't need it (it retrieves it from the plan itself, as we are about to do here)
        // we still have to provide the accountID for OTAPI_Func, which uses it to grab the
        // intermediary files, as part of its automated sync duties. (FYI.)
        //
        var strSenderAcctID = OT_API_Instrmnt_GetSenderAcctID(THE_PAYMENT_PLAN)
        
//      int OT_API_depositPaymentPlan(SERVER_ID, NYM_ID, THE_PAYMENT_PLAN)
        var theRequest := OTAPI_Func(ot_Msg.DEPOSIT_PAYMENT_PLAN, SERVER_ID, NYM_ID, strSenderAcctID, THE_PAYMENT_PLAN)
        var	strResponse = theRequest.SendTransaction(theRequest, "DEPOSIT_PAYMENT_PLAN")
        return strResponse
    }
// -----------------------------------------------------------------------------------------------

// TRIGGER CLAUSE (on running smart contract)  -- TRANSACTION
//
def OT_ME::trigger_clause(SERVER_ID, NYM_ID, STR_TRANS_NUM, CLAUSE_NAME, STR_PARAM) 
{
    var ot_Msg := OTAPI_Func()
    // -------------------------
    
    //      int OT_API_triggerClause(const char * SERVER_ID,
    //                               const char * USER_ID,
    //                               const char * TRANSACTION_NUMBER,
    //                               const char * CLAUSE_NAME,
    //                               const char * STR_PARAM);
    
    var theRequest := OTAPI_Func(ot_Msg.TRIGGER_CLAUSE, SERVER_ID, NYM_ID, STR_TRANS_NUM, CLAUSE_NAME, STR_PARAM)
    var	strResponse = theRequest.SendRequest(theRequest, "TRIGGER_CLAUSE")
    
    return strResponse
}
// -----------------------------------------------------------------------------------------------


// WITHDRAW CASH  -- TRANSACTION
//
def OT_ME::withdraw_cash(SERVER_ID, NYM_ID, ACCT_ID, AMOUNT) 
{
    var ot_Msg := OTAPI_Func()
    // -------------------------
    var theRequest := OTAPI_Func(ot_Msg.WITHDRAW_CASH, SERVER_ID, NYM_ID, ACCT_ID, AMOUNT)
    var	strResponse = theRequest.SendTransaction(theRequest, "WITHDRAW_CASH")
    
    return strResponse
}
// -----------------------------------------------------------------------------------------------


// WITHDRAW VOUCHER  -- TRANSACTION
//
def OT_ME::withdraw_voucher(SERVER_ID, NYM_ID, ACCT_ID, RECIP_NYM_ID, STR_MEMO, AMOUNT) 
{
    var ot_Msg := OTAPI_Func()
    // -------------------------
    
    var theRequest := OTAPI_Func(ot_Msg.WITHDRAW_VOUCHER, SERVER_ID, NYM_ID, ACCT_ID, RECIP_NYM_ID, STR_MEMO, AMOUNT)
    var	strResponse = theRequest.SendTransaction(theRequest, "WITHDRAW_VOUCHER")
    
    return strResponse
}
// -----------------------------------------------------------------------------------------------

// PAY DIVIDEND  -- TRANSACTION
//
def OT_ME::pay_dividend(SERVER_ID, NYM_ID, SOURCE_ACCT_ID, SHARES_ASSET_ID, STR_MEMO, AMOUNT_PER_SHARE) 
{
    var ot_Msg := OTAPI_Func()
    // -------------------------
    var theRequest := OTAPI_Func(ot_Msg.PAY_DIVIDEND, SERVER_ID, NYM_ID, SOURCE_ACCT_ID, SHARES_ASSET_ID, STR_MEMO, AMOUNT_PER_SHARE)
    var	strResponse = theRequest.SendTransaction(theRequest, "PAY_DIVIDEND")
    
    return strResponse
}
// -----------------------------------------------------------------------------------------------


def OT_ME::deposit_cheque(SERVER_ID, NYM_ID, ACCT_ID, STR_CHEQUE)
{
    var ot_Msg := OTAPI_Func()
    // ---------------------------------------------------
    var theRequest  = OTAPI_Func(ot_Msg.DEPOSIT_CHEQUE, SERVER_ID, NYM_ID, ACCT_ID, STR_CHEQUE)
    var strResponse = theRequest.SendTransaction(theRequest, "DEPOSIT_CHEQUE") // <========================
    
    return strResponse
}

// -----------------------------------------------------------------------------------------------

def OT_ME::get_market_list(SERVER_ID, NYM_ID)
{
    var ot_Msg := OTAPI_Func()
    // ---------------------------------------------------
    var theRequest := OTAPI_Func(ot_Msg.GET_MARKET_LIST, SERVER_ID, NYM_ID)
    var strResponse = theRequest.SendRequest(theRequest, "GET_MARKET_LIST") // <========================
    
    return strResponse
}

//int OT_API_getMarketOffers(const char * SERVER_ID,
//                           const char * USER_ID,
//                           const char * MARKET_ID, 
//                           const char * MAX_DEPTH) 

def OT_ME::get_market_offers(SERVER_ID, NYM_ID, MARKET_ID, MAX_DEPTH)
{
    var ot_Msg := OTAPI_Func()
    // ---------------------------------------------------
    var theRequest := OTAPI_Func(ot_Msg.GET_MARKET_OFFERS, SERVER_ID, NYM_ID, MARKET_ID, MAX_DEPTH)
    var strResponse = theRequest.SendRequest(theRequest, "GET_MARKET_OFFERS") // <========================
    
    return strResponse
}

def OT_ME::get_nym_market_offers(SERVER_ID, NYM_ID)
{
    var ot_Msg := OTAPI_Func()
    // ---------------------------------------------------
    var theRequest := OTAPI_Func(ot_Msg.GET_NYM_MARKET_OFFERS, SERVER_ID, NYM_ID)
    var strResponse = theRequest.SendRequest(theRequest, "GET_NYM_MARKET_OFFERS") // <========================
    
    return strResponse
}


def OT_ME::get_market_recent_trades(SERVER_ID, NYM_ID, MARKET_ID)
{
    var ot_Msg := OTAPI_Func()
    // ---------------------------------------------------
    var theRequest := OTAPI_Func(ot_Msg.GET_MARKET_RECENT_TRADES, SERVER_ID, NYM_ID, MARKET_ID)
    var strResponse = theRequest.SendRequest(theRequest, "GET_MARKET_RECENT_TRADES") // <========================
    
    return strResponse
}



def OT_ME::adjust_usage_credits(SERVER_ID, USER_NYM_ID, TARGET_NYM_ID, ADJUSTMENT)
{
    var ot_Msg := OTAPI_Func()
    // ---------------------------------------------------
    var theRequest := OTAPI_Func(ot_Msg.ADJUST_USAGE_CREDITS, SERVER_ID, USER_NYM_ID, TARGET_NYM_ID, ADJUSTMENT)
    var strResponse = theRequest.SendRequest(theRequest, "ADJUST_USAGE_CREDITS") // <========================
    
    return strResponse
}




// ******************************************************************************************
// Imports a purse into the wallet.

// NOTE:   UNUSED currently.
def importCashPurse(serverID, nymID, assetID, userInput, isPurse) 
{
    var isSuccess = true
    
//    OT_API_Output(0, "importCashPurse, serverID:" + serverID + " nymID:" + nymID + " assetID:" + assetID);
//    OT_API_Output(0, "importCashPurse, userInput purse:" + userInput);
    
    if (VerifyBoolVal(isPurse) && !isPurse) // it's not a purse. Must be a token, so let's create a purse for it.
    {
//      OT_API_Output(0, "importCashPurse, isPurse:" + isPurse)
        
        var purse = OT_API_CreatePurse(serverID, assetID, nymID, nymID) // nymID, nymID == owner, signer
        
        if (!VerifyStringVal(purse)) 
        {
            OT_API_Output(0, "importCashPurse: Error: OT_API_CreatePurse returned null\n")
            return false
        }
//      OT_API_Output(0, "importCashPurse, OT_API_CreatePurse return :" + purse);
        
        var newPurse = OT_API_Purse_Push(serverID, assetID, nymID, nymID, purse, userInput)
        if (!VerifyStringVal(newPurse)) 
        {
            OT_API_Output(0, "importCashPurse: Error: OT_API_Purse_Push returned null\n")
            return false
        }
//      OT_API_Output(0, "importCashPurse, OT_API_Purse_Push returned :" + newPurse);
        userInput = newPurse
    }
//    OT_API_Output(0, "importCashPurse, Before calling OT_API_Wallet_ImportPurse, final purse:" + userInput);
//    OT_API_Output(0, "importCashPurse just before api , serverID:" + serverID + " nymID:" + nymID + " assetID:" + assetID);

    // Here we have either a purse that was passed in, or a purse that we created so
    // we could add the token that was passed in. Either way, we have a purse now, so
    // let's import it into the wallet.
    //
    isSuccess = OT_API_Wallet_ImportPurse(serverID, assetID, nymID, userInput) == 1 ? true : false
    
    return isSuccess
}


// -----------------------------------------------------------------------------------------------




// processCashPurse pops the selected tokens off of oldPurse, changes their owner to recipientNymID,
// and pushes them onto newPurse, owned by recipientNymID. Meanwhile any unselected tokens are pushed
// onto newPurseUnselectedTokens, owned by nymID, which is saved to local storage (overwriting...)
// newPurse is returned from this function.
//
// Thus, for example, if there's a problem depositing/exporting/exchanging newPurse, then it needs
// to be merged back into the old purse again, which is otherwise still missing those tokens. (We
// should keep a copy of them in the payments outbox or something like that, in the meantime.)
//
// What is newPurseForSender for?
// Sometimes when processCashPurse is called, a Nym is just removing tokens from his purse so he can
// deposit them into his own account. Meaning the "sender" Nym (who owns the purse) is the same as the
// "recipient" Nym (who owns the account.) In which case, newPurse (for recipient) and newPurseForSender
// will contain the exact same thing. But in the case where they are different Nyms (like if I am
// exporting these tokens from my purse in order to give them to someone else) then I will want a copy
// of the exported purse for the recipient, and a copy of the same exported purse for the sender.
// processCashPurse returns both of those for me. The reason is because otherwise, if I just encrypted
// some of my cash tokens to some external Nym, then only THAT Nym's private key will ever open them up
// again. Even if I have them in my outpayments box, I can never recover them because I can never again
// decrypt them. Therefore I make a special copy of the outgoing purse which is encrypted to my own key,
// and put that into my outpayments box instead of the one I sent to the recipient (or including both
// of them.) That way the cash can still be recovered if necessary, from my outpayments box, and re-imported
// back into my cash purse again.
//
def processCashPurse(newPurse, newPurseForSender, serverID,  assetID,  nymID,  oldPurse,  selectedTokens,  recipientNymID, bPWProtectOldPurse, bPWProtectNewPurse) : serverID.is_type(string_type) && assetID.is_type(string_type) && nymID.is_type(string_type) && oldPurse.is_type(string_type) && recipientNymID.is_type(string_type)
{
    // By this point, we know that "selected tokens" has a size of 0, or MORE THAN ONE. (But NOT 1 exactly.)
    // (At least, if this function was called by exportCashPurse.)
    var strLocation = "processCashPurse"
    // ------------------------------------------------------------
    // This block handles cases where NO TOKENS ARE SELECTED.
    //
    // (Meaning: "PROCESS" THEM ALL.)
    //
    if ((selectedTokens.is_var_null()) || (selectedTokens.size() < 1))
    {
        // newPurse is created, OWNED BY RECIPIENT.
        //
        newPurse = (bPWProtectNewPurse ? OT_API_CreatePurse_Passphrase(serverID, assetID, nymID) : OT_API_CreatePurse(serverID, assetID, recipientNymID, nymID)) // recipientNymID is owner, nymID is signer
        
        if (!VerifyStringVal(newPurse))
        {
            OT_API_Output(0, strLocation+": "+(bPWProtectNewPurse ? "OT_API_CreatePurse_Passphrase" : "OT_API_CreatePurse")+" returned null\n");
            return false
        }
        // -----------------------------------------------------------
        // We'll create an extra copy of the newPurse, which is encrypted to the sender (instead of the recipient or
        // some passphrase.) We'll call it newPurseForSender. This way the sender can later have the option to recover
        // the cash from his outbox.
        //
        newPurseForSender = OT_API_CreatePurse(serverID, assetID, nymID, nymID) // nymID is owner, nymID is signer
        
        if (!VerifyStringVal(newPurseForSender))
        {
            OT_API_Output(0, strLocation+": Failure: OT_API_CreatePurse returned null\n");
            return false
        }
        // -----------------------------------------------------------
        // Iterate through the OLD PURSE. (as tempOldPurse.)
        //
        var count        = OT_API_Purse_Count(serverID, assetID, oldPurse)
        var tempOldPurse = oldPurse
        
        for (var i = 0; i < count; ++i)
        {
            // Peek into TOKEN, from the top token on the stack. (And it's STILL on top after this call.)
            //
            var token = OT_API_Purse_Peek(serverID, assetID, nymID, tempOldPurse)
            
            // Now pop the token off of tempOldPurse (our iterator for the old purse).
            // Store updated copy of purse (sans token) into "str1".
            //
            var str1 = OT_API_Purse_Pop(serverID, assetID, nymID, tempOldPurse)
            
            if (!VerifyStringVal(token) || !VerifyStringVal(str1)) 
            {
                OT_API_Output(0, strLocation+": OT_API_Purse_Peek or OT_API_Purse_Pop returned null... SHOULD NEVER HAPPEN. Returning null.\n")
                return false
            }
            
            // Since pop succeeded, copy the output to tempOldPurse
            // (for next iteration, in case any continues happen below.)
            // Now tempOldPurse contains what it did before, MINUS ONE TOKEN. (The exported one.)
            //
            tempOldPurse = str1
            // -----------------------
            var strSender    = bPWProtectOldPurse ? oldPurse : nymID
            var strRecipient = bPWProtectNewPurse ? newPurse : recipientNymID
            
            var strSenderAsRecipient = nymID  // Used as the "owner" of newPurseForSender. (So the sender can recover his sent coins that got encrypted to someone else's key.)
            // -----------------------            
            // Change the OWNER on token, from NymID to RECIPIENT.
            // (In this block, we change ALL the tokens in the purse.)
            //
            var exportedToken = OT_API_Token_ChangeOwner(serverID, assetID, token,
                                                         nymID,        // signer ID
                                                         strSender,    // old owner
                                                         strRecipient) // new owner
            // If change failed, then continue.
            //
            if (!VerifyStringVal(exportedToken))
            {
                OT_API_Output(0, strLocation+": 1, OT_API_Token_ChangeOwner returned null...(should never happen) Returning null.\n")
                return false
            }
            // -----------------------
            // SAVE A COPY FOR THE SENDER...
            //
            var retainedToken = OT_API_Token_ChangeOwner(serverID, assetID, token,
                                                         nymID,                // signer ID
                                                         strSender,            // old owner
                                                         strSenderAsRecipient) // new owner
            // If change failed, then continue.
            //
            if (!VerifyStringVal(retainedToken))
            {
                OT_API_Output(0, strLocation+":  2, OT_API_Token_ChangeOwner returned null...(should never happen) Returning null.\n")
                return false
            }
            // -----------------------
            
//          strSender    = bPWProtectOldPurse ? "" : nymID // unused here. not needed.
            strRecipient = bPWProtectNewPurse ? "" : recipientNymID
            
            // PUSH the EXPORTED TOKEN (new owner) into the new purse (again, recipient/newPurse is new owner) and save results in "strPushedForRecipient".
            // Results are, FYI, newPurse+exportedToken.
            //
            var strPushedForRecipient = OT_API_Purse_Push(serverID, assetID, nymID, // server, asset, signer
                                                          strRecipient, // owner is either NULL (for password-protected purse) or recipientNymID
                                                          newPurse, exportedToken)  // purse, token
            
            // If push failed, then continue.
            if (!VerifyStringVal(strPushedForRecipient))
            {
                OT_API_Output(0, strLocation+":  OT_API_Purse_Push 1 returned null... (should never happen) Returning null.\n")
                return false
            }
            // -----------------------
            // PUSH the RETAINED TOKEN (copy for original owner) into the newPurseForSender and save results in "strPushedForRetention".
            // Results are, FYI, newPurseForSender+retainedToken.
            //
            var strPushedForRetention = OT_API_Purse_Push(serverID, assetID, nymID, // server, asset, signer
                                                          strSenderAsRecipient, // This version of the purse is the outgoing copy (for the SENDER's notes). Thus strSenderAsRecipient.
                                                          newPurseForSender, retainedToken)  // purse, token
            
            // If push failed, then continue.
            if (!VerifyStringVal(strPushedForRetention))
            {
                OT_API_Output(0, strLocation+":  OT_API_Purse_Push 2 returned null... (should never happen) Returning null.\n")
                return false
            }
            // -----------------------
            // Since push succeeded, copy "strPushedForRecipient" (containing newPurse         +exportedToken) into newPurse.
            // Since push succeeded, copy "strPushedForRetention" (containing newPurseForSender+retainedToken) into newPurseForSender.
            //
            newPurse          = strPushedForRecipient
            newPurseForSender = strPushedForRetention
        } // for
        
        // Save tempOldPurse to local storage. (For OLD Owner.)
        // By now, all of the tokens have been popped off of this purse, so it is EMPTY.
        // We're now saving the empty purse, since the user exported all of the tokens.
        //
        // THERE MAYBE SHOULD BE AN EXTRA MODAL HERE, that says,
        // "Moneychanger will now save your purse, EMPTY, back to local storage. Are you sure you want to do this?"
        //
        // -----------------------------
        if (!bPWProtectOldPurse)  // If old purse is NOT password-protected (that is, it's encrypted to a Nym.)
        {
            if (!OT_API_SavePurse(serverID, assetID, nymID, tempOldPurse)) // if FAILURE.
            {
                // No error message if saving fails??
                // No modal?
                //
                // FT: adding log.
                OT_API_Output(0, strLocation+":  OT_API_SavePurse FAILED. SHOULD NEVER HAPPEN!!!!!!\n")
                return false;
            }
        }
        else // old purse IS password protected. (So return its updated version.)
        {
            oldPurse = tempOldPurse // We never cared about this with Nym-owned old purse, since it saves to storage anyway, in the above block. But now in the case of password-protected purses, we set the oldPurse to contain the new version of itself (containing the tokens that had been left unselected) so the caller can do what he wills with it.
        }
    }
    // -------------------------------------------------------------------------------------
    // Else, SPECIFIC TOKENS were selected, so process those only...
    //
    else 
    {
//      OT_API_Output(0, "Tokens in Cash Purse being processed");
        
        // ----------------------------------------------------------
        // newPurseSelectedTokens is created (CORRECTLY) with recipientNymID as owner. (Or with a symmetric key / passphrase.)
        // newPurseUnSelectedTokens is created (CORRECTLY) with NymID as owner. (Unselected tokens aren't being exported...)
        //
        var newPurseUnSelectedTokens  = OT_API_Purse_Empty(serverID, assetID, nymID, oldPurse) // Creates an empty copy of oldPurse.
        var newPurseSelectedTokens    = (bPWProtectNewPurse ? OT_API_CreatePurse_Passphrase(serverID, assetID, nymID) : OT_API_CreatePurse(serverID, assetID, recipientNymID, nymID)) // recipientNymID = owner, nymID = signer
        var newPurseSelectedForSender = OT_API_CreatePurse(serverID, assetID, nymID, nymID) // nymID = owner, nymID = signer. This is a copy of newPurseSelectedTokens that's encrypted to the SENDER (for putting in his outpayments box, so he can still decrypt if necessary.)
        
        if (!VerifyStringVal(newPurseSelectedForSender))
        {
            OT_API_Output(0, strLocation+":  OT_API_CreatePurse returned null\n")
            return false
        }
        if (!VerifyStringVal(newPurseSelectedTokens))
        {
            OT_API_Output(0, strLocation+":  OT_API_CreatePurse or OT_API_CreatePurse_Passphrase returned null\n")
            return false
        }
        if (!VerifyStringVal((newPurseUnSelectedTokens)))
        {
            OT_API_Output(0, strLocation+":  OT_API_Purse_Empty returned null\n")
            return false
        }
        // ----------------------------------------------------------
        // Iterate through oldPurse, using tempOldPurse as iterator.
        //
        var count = OT_API_Purse_Count(serverID, assetID, oldPurse)
        var tempOldPurse = oldPurse
        
        for (var i = 0; i < count; ++i) 
        {
            // Peek at the token on top of the stack.
            // (Without removing it.)
            //
            var token = OT_API_Purse_Peek(serverID, assetID, nymID, tempOldPurse)
            
            // Remove the top token from the stack, and return the updated stack in "str1".
            //
            var str1 = OT_API_Purse_Pop(serverID, assetID, nymID, tempOldPurse)
            
            if (!VerifyStringVal(str1) || !VerifyStringVal(token)) 
            {
                OT_API_Output(0, strLocation+":  OT_API_Purse_Peek or OT_API_Purse_Pop returned null... returning Null. (SHOULD NEVER HAPPEN.)\n")
                return false
            }
            
            // Putting updated purse into iterator, so any subsequent continues will work properly.
            //
            tempOldPurse = str1
            // ----------------------------------------
            
            // Grab the TokenID for that token. (Token still has OLD OWNER.)
            //
            var tokenID = OT_API_Token_GetID(serverID, assetID, token)
            
            if (!VerifyStringVal(tokenID)) 
            {
                OT_API_Output(0, strLocation+":  OT_API_Token_GetID returned null... SHOULD NEVER HAPPEN. Returning now.\n")
                return false
            }
            // ----------------------------------------
            // At this point, we check TokenID (identifying the current token) to see if it's on the SELECTED LIST.
            //
            if (selectedTokens.range().contains(tokenID)) // We ARE exporting this token. (Its ID was on the list.)
            {
                // CHANGE OWNER from NYM to RECIPIENT
                // "token" will now contain the EXPORTED TOKEN, with the NEW OWNER.
                //
                var strSender    = bPWProtectOldPurse ? oldPurse               : nymID
                var strRecipient = bPWProtectNewPurse ? newPurseSelectedTokens : recipientNymID
                
                var strSenderAsRecipient = nymID  // Used as the "owner" of newPurseSelectedForSender. (So the sender can recover his sent coins that got encrypted to someone else's key.)
                // ----------------------------------------
                var exportedToken = OT_API_Token_ChangeOwner(serverID, assetID, token, // server, asset, token,
                                                             nymID,        // signer nym
                                                             strSender,    // old owner
                                                             strRecipient) // new owner
                if (!VerifyStringVal(exportedToken))
                {
                    OT_API_Output(0, strLocation+": 1  OT_API_Token_ChangeOwner returned null... SHOULD NEVER HAPPEN. Returning now.\n");
                    return false
                }
                // ----------------------------------------
                var retainedToken = OT_API_Token_ChangeOwner(serverID, assetID, token, // server, asset, token,
                                                             nymID,                // signer nym
                                                             strSender,            // old owner
                                                             strSenderAsRecipient) // new owner
                if (!VerifyStringVal(retainedToken))
                {
                    OT_API_Output(0, strLocation+": 2  OT_API_Token_ChangeOwner returned null... SHOULD NEVER HAPPEN. Returning now.\n");
                    return false
                }
                // ----------------------------------------
                // Push exported version of token into new purse for recipient (for selected tokens.)
                //
//              strSender    = bPWProtectOldPurse ? "" : nymID  // unused here. Not needed.
                strRecipient = bPWProtectNewPurse ? "" : recipientNymID
                
                var strPushedForRecipient = OT_API_Purse_Push(serverID, assetID, nymID, // server, asset, signer
                                                              strRecipient, // owner is either NULL (for password-protected purse) or recipientNymID
                                                              newPurseSelectedTokens, exportedToken) // purse, token
                if (!VerifyStringVal(strPushedForRecipient)) 
                {
                    OT_API_Output(0, strLocation+":  OT_API_Purse_Push newPurseSelectedTokens returned null... SHOULD NEVER HAPPEN (returning.)\n")
                    return false
                }
                // ----------------------------------------
                // Done: push a copy of these into a purse for the original owner as well, so he has his OWN copy
                // to save in his payments outbox (that HE can decrypt...) so if the cash is lost, for example, he can still
                // recover it. If the recipient receives it and deposits it correctly, the cash in your payment outbox is now
                // worthless and can be discarded, although its existence may be valuable to you as a receipt.
                //
                var strPushedForRetention = OT_API_Purse_Push(serverID, assetID, nymID, // server, asset, signer
                                                              strSenderAsRecipient,
                                                              newPurseSelectedForSender, retainedToken) // purse, token
                if (!VerifyStringVal(strPushedForRetention))
                {
                    OT_API_Output(0, strLocation+":  OT_API_Purse_Push newPurseSelectedForSender returned null... SHOULD NEVER HAPPEN (returning.)\n")
                    return false
                }
                // ----------------------------------------
                newPurseSelectedTokens    = strPushedForRecipient
                newPurseSelectedForSender = strPushedForRetention
                // ----------------------------------------
            }
            else // The token, this iteration, is NOT being exported, but is remaining with the original owner.
            {
                var strSender = bPWProtectOldPurse ? "" : nymID

                var str = OT_API_Purse_Push(serverID, assetID, nymID, // server, asset, signer
                                            strSender, // owner is either NULL (for password-protected purse) or nymID
                                            newPurseUnSelectedTokens, token) // purse, token
                if (!VerifyStringVal(str))
                {
                    OT_API_Output(0, strLocation+": OT_API_Purse_Push newPurseUnSelectedTokens returned null... SHOULD NEVER HAPPEN. Returning false.\n")
                    return false
                }
                
                newPurseUnSelectedTokens = str
            }
        } // for
        // -----------------------------
        if (!bPWProtectOldPurse)  // If old purse is NOT password-protected (that is, it's encrypted to a Nym.)
        {
            if (!OT_API_SavePurse(serverID, assetID, nymID, newPurseUnSelectedTokens)) // if FAILURE.
            {
                // No error message if saving fails??
                // No modal?
                //
                // FT: adding log.
                OT_API_Output(0, strLocation+":  OT_API_SavePurse FAILED. SHOULD NEVER HAPPEN!!!!!!\n")
                return false;
            }
        }
        else // old purse IS password protected. (So return its updated version.)
        {
            oldPurse = newPurseUnSelectedTokens // We never cared about this with Nym-owned old purse, since it saves to storage anyway, in the above block. But now in the case of password-protected purses, we set the oldPurse to contain the new version of itself (containing the tokens that had been left unselected) so the caller can do what he wills with it.
        }
        
        // The SELECTED tokens (with Recipient as owner of purse AND tokens within) are returned as the "newPurse".
        // The SELECTED tokens (with Sender as owner of purse AND tokens within) are returned as "newPurseForSender".
        //
        newPurse          = newPurseSelectedTokens
        newPurseForSender = newPurseSelectedForSender
    }
    
    return true
}


// -----------------------------------------------------------------------------------------------


// Input: server ID, assetID, Nym of current owner, existing purse, list of selected tokens, Nym of Recipient, and bool bPasswordProtected.
// Returns: "new Purse"
//
def exportCashPurse( serverID,  assetID,  nymID,  oldPurse,  selectedTokens,  recipientNymID, bPasswordProtected, strRetainedCopy)
{
//  OT_API_Output(0, "exportCashPurse starts, selectedTokens:" + selectedTokens + "\n");
//  Utility.setObj(null);

    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // --------------------------------------------------------------------
    if (!bPasswordProtected)
    {
        // If no recipient, then recipient == Nym.
        //
        if (!VerifyStringVal(recipientNymID) || (recipientNymID.size() == 0))
        {
            OT_API_Output(0, "exportCashPurse: recipientNym empty--using NymID for recipient instead: " + nymID + "\n")
            recipientNymID = nymID
        }
        // --------------------------------------------------------------------
        if (!(recipientNymID == nymID))
        {
            // Even though we don't use this variable after this point,
            // we've still done something important: loaded and possibly
            // downloaded the recipient Nym, so that later in this function
            // we can reference that recipientNymID in other calls and we know
            // it will work.
            //
            var recipientPubKey = madeEasy.load_or_retrieve_encrypt_key(serverID, nymID, recipientNymID)  // this function handles partial IDs for recipient.

            if (!VerifyStringVal(recipientPubKey)) 
            {
                OT_API_Output(0, "exportCashPurse: recipientPubKey is null\n");
                return ""
            }
        }
    }
    // --------------------------------------------------    
    // By this point, we have verified that we can load the public key for the recipient.
    // (IF the exported purse isn't meant to be password-protected.)
    //
    var token         = ""
    var exportedToken = ""
    var exportedPurse = ""
        
    // Next I create another "newPurse" by calling this function.
    //
    var newPurse = "" // for recipient
    var newPurseForSender = ""
    var copyOfOldPurse  = oldPurse
    var bSuccessProcess = processCashPurse(newPurse, newPurseForSender, serverID, assetID, nymID, copyOfOldPurse, selectedTokens, recipientNymID, false, bPasswordProtected)
    
    if (bSuccessProcess)
    {
        strRetainedCopy = newPurseForSender
    }
    
    // Whatever is returned from that function, I return here also. Presumably a purse...
    //
    return newPurse
}


// -----------------------------------------------------------------------------------------------


def depositCashPurse(serverID,  assetID,  nymID,  oldPurse,  selectedTokens,  accountID)
{                
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ----------------------------------------
    var recipientNymID  = OT_API_GetAccountWallet_NymID(accountID)
    if (!VerifyStringVal(recipientNymID)) 
    {
        OT_API_Output(0, "\ndepositCashPurse: Unable to find recipient Nym based on myacct. \n")
        return (-1)
    }
    // ----------------------------------------
    var bPasswordProtected = OT_API_Purse_HasPassword(serverID, oldPurse)
    // ----------------------------------------
    var newPurse // being deposited.
    var newPurseForSender = "" // Probably unused in this case.
    var copyOfOldPurse  = oldPurse
    var bSuccessProcess = processCashPurse(newPurse, newPurseForSender, serverID, assetID, nymID, copyOfOldPurse, selectedTokens, recipientNymID,
                                           bPasswordProtected, false)
    
    if (!bSuccessProcess || !VerifyStringVal(newPurse))
    {
        OT_API_Output(0, "depositCashPurse: new Purse is empty, after processing it for deposit. \n")
        return (-1)
    }
    // ----------------------------------------
    var  ot_Msg       := OTAPI_Func()
    var  theRequest   := OTAPI_Func(ot_Msg.DEPOSIT_CASH, serverID, recipientNymID, accountID, newPurse)
    var  strResponse  = theRequest.SendTransaction(theRequest, "DEPOSIT_CASH") // <========================
    
    var strAttempt  = "deposit_cash"

    // ***************************************************************
            
    // HERE, WE INTERPRET THE SERVER REPLY, WHETHER SUCCESS, FAIL, OR ERROR...
    
    var nInterpretReply = InterpretTransactionMsgReply(serverID, recipientNymID, accountID, strAttempt, strResponse)
    
    if (1 == nInterpretReply)
    {
        // Download all the intermediary files (account balance, inbox, outbox, etc)
        // since they have probably changed from this operation.
        //
        var bRetrieved = madeEasy.retrieve_account(serverID, recipientNymID, accountID, true) //bForceDownload defaults to false.
        
        OT_API_Output(0, "\nServer response ("+strAttempt+"): SUCCESS depositing cash!\n")
        OT_API_Output(0, (bRetrieved ? "Success" : "Failed") + " retrieving intermediary files for account.\n")
    }
    else // failure. (so we re-import the cash, so as not to lose it...)
    {
        // -------------------
        if (!bPasswordProtected)
        {
            var importStatus = OT_API_Wallet_ImportPurse(serverID, assetID, recipientNymID, newPurse)
            OT_API_Output(0, "Since failure in depositCashPurse, OT_API_Wallet_ImportPurse called. Status of import: " + importStatus.to_string() + "\n")
            
            if (VerifyBoolVal(importStatus) && !importStatus)
            {
                // Raise the alarm here that we failed depositing the purse, and then we failed
                // importing it back into our wallet again.
                OT_API_Output(0, "Error: Failed depositing the cash purse, and then failed re-importing it back to wallet. Therefore YOU must copy the purse NOW and save it to a safe place! \n")
                
                print(newPurse)
                
                OT_API_Output(0, "AGAIN: Be sure to copy the above purse to a safe place, since it FAILED to deposit and FAILED to re-import back into the wallet. \n")
            }            
        }
        else
        {
            OT_API_Output(0, "Error: Failed depositing the cash purse. Therefore YOU must copy the purse NOW and save it to a safe place! \n")
            
            print(newPurse)
            
            OT_API_Output(0, "AGAIN: Be sure to copy the above purse to a safe place, since it FAILED to deposit. \n")
        }
        
        return (-1)
    }

    // ***************************************************************
    //
    // Return status to caller.
    //
    return nInterpretReply  
}


// -----------------------------------------------------------------------------------------------


//public boolean 
//def exchangeCashPurse(String serverID, String assetID, String nymID, String oldPurse, ArrayList selectedTokens)
def exchangeCashPurse( serverID,  assetID,  nymID,  oldPurse,  selectedTokens)
{
//  Utility.setObj(null);
//  OT_API_Output(0, " Cash Purse exchange starts, selectedTokens:" + selectedTokens + "\n")

    var newPurse
    var newPurseForSender = "" // Probably unused in this case.

    var bProcessSuccess = processCashPurse(newPurse, newPurseForSender, serverID, assetID, nymID, oldPurse, selectedTokens, nymID, false, false) // bIsPasswordProtected=false
    
    if (bProcessSuccess && !VerifyStringVal(newPurse))
    {
        OT_API_Output(0, "exchangeCashPurse: Before server OT_API_exchangePurse call, new Purse is empty. returning false \n")
        return false
    }
    // ------------------------
    var  ot_Msg := OTAPI_Func()
    var  theRequest  := OTAPI_Func(ot_Msg.EXCHANGE_CASH, serverID, nymID, assetID, newPurse)
    var  strResponse  = theRequest.SendTransaction(theRequest, "EXCHANGE_CASH") // <========================
    
    if (!VerifyStringVal(strResponse))
    {
        OT_API_Output(0, "IN exchangeCashPurse: theRequest.SendTransaction(() failed. (I give up.) \n")
        // -------------------
        var importStatus = OT_API_Wallet_ImportPurse(serverID, assetID, nymID, newPurse);
        OT_API_Output(0, "Since failure in exchangeCashPurse, OT_API_Wallet_ImportPurse called, status of import: " + importStatus + "\n")
        if (!importStatus) 
        {
//          Utility.setObj(newPurse)
        }
        
        return false
    }
    // ---------------------------------------        
//  OT_API_Output(0, "exchangeCashPurse ends, status: success.\n")
    
    return true
}




// -----------------------------------------------------------------------------------------------


def OT_ME::deposit_purse(SERVER_ID, NYM_ID, ACCT_ID, STR_PURSE)
{
    var ot_Msg := OTAPI_Func()
    // ---------------------------------------------------
    var theRequest := OTAPI_Func(ot_Msg.DEPOSIT_CASH, SERVER_ID, NYM_ID, ACCT_ID, STR_PURSE)
    var strResponse = theRequest.SendTransaction(theRequest, "DEPOSIT_CASH") // <========================
    
    return strResponse
}

// -----------------------------------------------------------------------------------------------


	 
	 
 /*
  
 DONE:  create nym, register nym, issue asset type, send transfer, accept entire inbox, write cheque.
  
  Next ones:  show purse, withdraw cash, deposit cash, withdraw voucher, deposit cheque.
  
 Need to add functions (like check_user above) for all of these:
 
 	attr OTAPI_Func::CREATE_USER_ACCT (register nym)DONE		
	attr OTAPI_Func::DELETE_USER_ACCT               
	attr OTAPI_Func::CHECK_USER						DONE
	attr OTAPI_Func::SEND_USER_MESSAGE				DONE
	attr OTAPI_Func::ISSUE_ASSET_TYPE               DONE
	attr OTAPI_Func::ISSUE_BASKET                   
	attr OTAPI_Func::CREATE_ASSET_ACCT				DONE			
	attr OTAPI_Func::DELETE_ASSET_ACCT              
	attr OTAPI_Func::EXCHANGE_BASKET                
	attr OTAPI_Func::PROCESS_INBOX                  DONE
	attr OTAPI_Func::DEPOSIT_CASH                   DONE
	attr OTAPI_Func::EXCHANGE_CASH                  
	attr OTAPI_Func::DEPOSIT_CHEQUE                 DONE
	attr OTAPI_Func::WITHDRAW_VOUCHER               DONE
    attr OTAPI_Func::WITHDRAW_CASH                  DONE
    attr OTAPI_Func::PAY_DIVIDEND                   DONE
	attr OTAPI_Func::GET_CONTRACT                   DONE
	attr OTAPI_Func::SEND_TRANSFER                  DONE
	attr OTAPI_Func::GET_MARKET_LIST                DONE
	attr OTAPI_Func::CREATE_MARKET_OFFER			DONE
	attr OTAPI_Func::CANCEL_MARKET_OFFER			DONE
	attr OTAPI_Func::CANCEL_PAYMENT_PLAN			DONE
	attr OTAPI_Func::GET_NYM_MARKET_OFFERS          DONE
	attr OTAPI_Func::GET_MARKET_OFFERS              DONE
	attr OTAPI_Func::GET_MARKET_RECENT_TRADES       
	attr OTAPI_Func::GET_MINT						DONE
	attr OTAPI_Func::QUERY_ASSET_TYPES				DONE
	attr OTAPI_Func::GET_BOX_RECEIPT				DONE

  --- Activate Payment Plan
  
  ------ TANGENT -----------------------------------------
  Use cases that do not require a server message, and thus will have representative
  functions in ot_made_easy.ot EVEN WHEN there is no corresponding server message
  in ot.
  --- stat wallet               DONE
  --- Stat cash purse           DONE
  --- Stat account              DONE
  --- Stat account inbox        DONE
  --- Stat account outbox       DONE
  --- Stat payment inbox        DONE
  --- Stat record box           DONE
  --- encode / decode           DONE
  --- encrypt/decrypt           DONE
  --- Password encrypt/decrypt  DONE
  --- Sign / Verify             DONE
  --- Create asset contract     DONE
  --- Create server contract    DONE
  --- Create symmetric key      DONE
  --- Create pseudonym          DONE
  --- Write cheque              DONE
  --- Verify last acct receipt  DONE
  --- Refresh (download latest) DONE
  --- Refresh Nym               DONE
  --- Propose Payment Plan      
  --- Confirm Payment Plan      
  --- Balance                   DONE
  --- 
  
  ------ END TANGENT -------------------------------------
  
  
Here are parameters for the first group above.
  (They are called in OTAPI_Func, this code is from there):

		else if (this.funcType == this.DELETE_USER_ACCT)
		{	OT_API_deleteUserAccount(this.serverID, this.nymID);	}
		else if (this.funcType == this.GET_NYM_MARKET_OFFERS)
		{	OT_API_getNym_MarketOffers(this.serverID, this.nymID);	}
		else if (this.funcType == this.CREATE_ASSET_ACCT)
		{	OT_API_createAssetAccount(this.serverID, this.nymID, this.assetID);	}
		else if (this.funcType == this.DELETE_ASSET_ACCT)
		{	OT_API_deleteAssetAccount(this.serverID, this.nymID, this.accountID);	}
		else if (this.funcType == this.EXCHANGE_BASKET)
		{	OT_API_exchangeBasket(this.serverID, this.nymID, this.assetID, this.basket, this.bBool);	}
		else if (this.funcType == this.GET_CONTRACT)
		{	OT_API_getContract(this.serverID, this.nymID, this.assetID);	}
		else if (this.funcType == this.ISSUE_ASSET_TYPE)
		{	OT_API_issueAssetType(this.serverID, this.nymID, this.strData);	}
		else if (this.funcType == this.ISSUE_BASKET)
		{	OT_API_issueBasket(this.serverID, this.nymID, this.basket);	}
		else if (this.funcType == this.EXCHANGE_CASH)
		{	OT_API_exchangePurse(this.serverID, this.assetID, this.nymID, this.strData);	}
		else if (this.funcType == this.CANCEL_MARKET_OFFER)
		{	OT_API_cancelMarketOffer(this.serverID, this.nymID, this.accountID, this.strData);	}
		else if (this.funcType == this.PROCESS_INBOX)
		{	OT_API_processInbox(this.serverID, this.nymID, this.accountID, this.strData);	}
		else if (this.funcType == this.DEPOSIT_CASH)
		{	OT_API_notarizeDeposit(this.serverID, this.nymID, this.accountID, this.strData);	}
		else if (this.funcType == this.DEPOSIT_CHEQUE)
		{	OT_API_depositCheque(this.serverID, this.nymID, this.accountID, this.strData);	}
		else if (this.funcType == this.WITHDRAW_CASH)
		{	OT_API_notarizeWithdrawal(this.serverID, this.nymID, this.accountID, this.strData);	}
		else if (this.funcType == this.WITHDRAW_VOUCHER)
		{	OT_API_withdrawVoucher(this.serverID, this.nymID, this.accountID, this.nymID2, this.strData, this.strData2);	}
		else if (this.funcType == this.SEND_TRANSFER)
		{	OT_API_notarizeTransfer(this.serverID, this.nymID, this.accountID, this.accountID2,   this.strData, this.strData2); } // amount and note, for the last two.
		else if (this.funcType == this.GET_MARKET_LIST)
		{	OT_API_getMarketList(this.serverID, this.nymID);	}
		else if (this.funcType == this.GET_MARKET_OFFERS)
		{	OT_API_getMarketOffers(this.serverID, this.nymID, this.strData, this.strData2);	}
		else if (this.funcType == this.GET_MARKET_RECENT_TRADES)
		{	OT_API_getMarketRecentTrades(this.serverID, this.nymID, this.strData);	}
		else if (this.funcType == this.CREATE_MARKET_OFFER)
		{	OT_API_issueMarketOffer(this.serverID, this.nymID, this.assetID, this.accountID, this.assetID2, this.accountID2, 
                        this.strData, this.strData2, this.strData3, this.strData4, this.bBool);
		}

 */
 



// NEW RETURN CODE CONVENTION!

// OT API already returns: -1 for error, 0 for "didn't need to do anything" and 1 for success (or larger.)
// All of the below functions follow that convention (they just return the same values.)
//
// But for the OT command line tool, we need to return 0 for success, and non-zero codes for errors.
// This is because it's a UNIX convention and will be expected by anyone writing bash scripts.
// 
// However, I don't want to physically change all the below functions, so I'm going to change the
// opentxs script itself, so that it translates the return value. That way I only have to change it
// in one spot, and we have access to use these scripts both ways.
//
// THE POINT? If you notice these scripts returning 1, which is then interpreted as 0 by bash scripts,
// it's because the script that CALLS these scripts, is doing that translation (for the above described
// reasons.)
//





def main_encode()
{
    OT_API_Output(0, "Please enter multiple lines of input to be encoded, followed by an EOF or a ~ by itself on a blank line:\n\n")

    // The reason we accept the tilde ~ on a blank line by itself, is because
    // the EOF, while it works, causes us not to be able to read any more input
    // from stdin. Stdin is considered "closed" for the duration of the run.
    // So the tilde allows us to read multiple times without closing stdin.
     
    var strInput = OT_CLI_ReadUntilEOF() 

    OT_API_Output(0, "\n\n--------------------------------------\n You entered:\n" + strInput + "\n\n") 

    var strOutput = OT_API_Encode(strInput, true)  // bLineBreaks=true 
     
    // stderr
    OT_API_Output(0, "-------------------------------------- \n Encoded:\n\n")

    // stdout
    if (VerifyStringVal(strOutput))
    {
        print(strOutput)
        // stderr
        OT_API_Output(0, "\n\n")
        return 1
    }

    // stderr
    OT_API_Output(0, "\n\n")

    -1
}


def main_decode()
{
    OT_API_Output(0, "Please enter multiple lines of OT-armored text to be decoded, followed by an EOF or a ~ by itself on a blank line:\n\n")
    
    // The reason we accept the tilde ~ on a blank line by itself, is because
    // the EOF, while it works, causes us not to be able to read any more input
    // from stdin. Stdin is considered "closed" for the duration of the run.
    // So the tilde allows us to read multiple times without closing stdin.
    
    var strInput = OT_CLI_ReadUntilEOF() 
    
    OT_API_Output(0, "\n\n--------------------------------------\n You entered:\n" + strInput + "\n\n") 
    
    var strOutput = OT_API_Decode(strInput, true)  // bLineBreaks=true 
    
    // stderr
    OT_API_Output(0, "--------------------------------------\n Decoded:\n\n")
    
    // stdout
    if (VerifyStringVal(strOutput))
    {
        print(strOutput)
        // stderr
        OT_API_Output(0, "\n\n")
        return 1
    }
    
    // stderr
    OT_API_Output(0, "\n\n")
    
    -1
}




def main_encrypt()
{
    if (VerifyExists("HisNym"))
    {
        
        OT_API_Output(0, "Please enter multiple lines of input to be encrypted,\nfollowed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        
        var strInput = OT_CLI_ReadUntilEOF() 
        
        OT_API_Output(0, "\n\n--------------------------------------\n You entered:\n" + strInput + "\n\n") 
        
        var strOutput = OT_API_Encrypt(HisNym, strInput)  // bLineBreaks=true 
                
        // stdout
        if (VerifyStringVal(strOutput))
        {
            // stderr
            OT_API_Output(0, "-------------------------------------- \n Encrypted:\n\n")
            
            print(strOutput)
            // stderr
            OT_API_Output(0, "\n\n")
            return 1
        }
    }
    
    // "return value"
    -1
}


def main_decrypt()
{
    if (VerifyExists("MyNym"))
    {
        
        OT_API_Output(0, "Please enter multiple lines of input to be decrypted, followed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        
        var strInput = OT_CLI_ReadUntilEOF() 
        
        OT_API_Output(0, "\n\n--------------------------------------\n You entered:\n" + strInput + "\n\n") 
        
        var strOutput = OT_API_Decrypt(MyNym, strInput)  // bLineBreaks=true 
        
        // stdout
        if (VerifyStringVal(strOutput))
        {
            // stderr
            OT_API_Output(0, "-------------------------------------- \n Decrypted:\n\n")
            
            print(strOutput)
            // stderr
            OT_API_Output(0, "\n\n")
            return 1
        }
    }
    
    // "return value"
    -1
}


def main_password_encrypt()
{
    OT_API_Output(0, "Please enter a symmetric key, followed by a ~ by itself on a blank line:\n\n")
    
	// The reason we accept the tilde ~ on a blank line by itself, is because
	// the EOF, while it works, causes us not to be able to read any more input
	// from stdin. Stdin is considered "closed" for the duration of the run.
	// So the tilde allows us to read multiple times without closing stdin.
    
	var strKey = OT_CLI_ReadUntilEOF() 
	
	OT_API_Output(0, "Please enter the plaintext, followed by a ~ by itself on a blank line:\n\n")
    
	var strPlaintext = OT_CLI_ReadUntilEOF() 
    
	if (VerifyStringVal(strKey) && VerifyStringVal(strPlaintext))
	{
		var strCiphertext = OT_API_SymmetricEncrypt(strKey, strPlaintext)
		
        // stdout
        if (VerifyStringVal(strCiphertext))
        {
            // stderr
            OT_API_Output(0, "-------------------------------------- \n strCiphertext:\n\n")
            
            print(strCiphertext)
            // stderr
            OT_API_Output(0, "\n\n")
            return 1
        }
	}
    
    // "return value"
    -1
}



def main_password_decrypt()
{
	OT_API_Output(0, "Please enter a symmetric key, followed by a ~ by itself on a blank line:\n\n")
    
	// The reason we accept the tilde ~ on a blank line by itself, is because
	// the EOF, while it works, causes us not to be able to read any more input
	// from stdin. Stdin is considered "closed" for the duration of the run.
	// So the tilde allows us to read multiple times without closing stdin.
    
	var strKey = OT_CLI_ReadUntilEOF() 
	
	OT_API_Output(0, "Please enter the symmetrically-encrypted ciphertext, followed by a ~ by itself on a blank line:\n\n")
    
	var strCiphertext = OT_CLI_ReadUntilEOF() 
    
	if (VerifyStringVal(strKey) && VerifyStringVal(strCiphertext))
	{
		var strPlaintext = OT_API_SymmetricDecrypt(strKey, strCiphertext)
		
        // stdout
        if (VerifyStringVal(strPlaintext))
        {
            // stderr
            OT_API_Output(0, "-------------------------------------- \n Plaintext:\n\n")
            
            print(strPlaintext)
            // stderr
            OT_API_Output(0, "\n\n")
            return 1
        }
	}
    
    // "return value"
    -1
}






def details_import_nym(strNymImportFile, strOutNymID)
{
    strOutNymID = OT_API_Wallet_ImportNym(strNymImportFile)
    
    var bVerified = VerifyStringVal(strOutNymID)
    
    return bVerified
}


def main_import_nym()
{
    var strUsage = "\n\n USAGE: importnym\n"
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    OT_API_Output(0, "Paste your exported Nym here (for import), followed by a ~ by itself on a blank line: \n")
    
    var strNymFile = OT_CLI_ReadUntilEOF() 
    
    if (!VerifyStringVal(strNymFile))
    {
        return (-1)
    }
    // -----------------------
    var strOutNymID
    var bDone = details_import_nym(strNymFile, strOutNymID)
    
    if (false == bDone)
    {
        OT_API_Output(0, "\n\n FAILED trying to import Nym.\n")
        return (-1)
    }
    else
    {
        OT_API_Output(0, "\n\n SUCCESS importing Nym: " + strOutNymID + "\n\n")
        return 1
    }
    // -----------------------
    return -1
}


def details_export_nym(strNymID)
{
    var strExportedNym = OT_API_Wallet_ExportNym(strNymID)
    
    return strExportedNym
}

def main_export_nym()
{
    var strUsage = "\n\n USAGE: exportnym --mynym NYM_ID\n"
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    if (VerifyExists("MyNym"))
    {	       
        var strExportedNym = details_export_nym(MyNym)
                
        if (!VerifyStringVal(strExportedNym))
        {
            OT_API_Output(0, "\n\n FAILED trying to export Nym: " + MyNym + "\n")
            return (-1)
        }
        else
        {
            OT_API_Output(0, "\n\n SUCCESS exporting Nym: " + MyNym + "\n\n") //stderr
            print(strExportedNym) // stdout
            OT_API_Output(0, "\n") //stderr
            return 1
        }
    }
    
    return -1
}


/*
    static const std::string Wallet_ExportNym (const std::string NYM_ID);
    static const std::string Wallet_ImportNym (const std::string FILE_CONTENTS);
    static const std::string Wallet_ImportCert(const std::string DISPLAY_NAME, 
                                               const std::string FILE_CONTENTS);
    static const std::string Wallet_ExportCert(const std::string NYM_ID);

 */



def details_import_cert(strCertfile, strDisplayName, strOutNymID)
{
    strOutNymID = OT_API_Wallet_ImportCert(strCertfile, strDisplayName)
    
    var bVerified = VerifyStringVal(strOutNymID)
    
    return bVerified
}

def main_import_cert()
{
    var strUsage = concat("\n\n USAGE:  importcert\n",
                              " OPTION:   --args \"name \\\"display name for new Nym in wallet\\\"\"\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    OT_API_Output(0, "Paste your public/private Certificate here (for import as a new Nym), followed by a ~ by itself on a blank line: \n")
    
    var strCertfile = OT_CLI_ReadUntilEOF() 
    
    if (!VerifyStringVal(strCertfile))
    {
        return (-1)
    }
    // -----------------------
    
    var strDisplayName
    var strDefaultName = "imported cert"
    
    if (VerifyExists("Args", false))
    {
        // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
        //                                  const std::string str_key)
        // 
        // OPTION:   --args "name \"display name for Nym in wallet\""
        // EXAMPLE:  --args "name Jimbob"
        //
        var strNewName = OT_CLI_GetValueByKey( Args, "name" ) 
        
        // ----------------------------------------------
        // Set the values based on the custom arguments, for those found.
        //
        if (VerifyStringVal(strNewName))
        {    strDisplayName = strNewName }
    }            
    // ------------------------------------
    // If the transfer parameters aren't provided, then we
    // ask the user to supply them at the command line.
    //
    if (!VerifyStringVal(strDisplayName))
    {
        OT_API_Output(0, "Enter the display name for the New Nym["+strDefaultName+"]: ")
        strDisplayName  = OT_CLI_ReadLine()
    }
    // ------------------------------------
    var strOutNymID
    var bDone = details_import_cert(strCertfile, strDisplayName, strOutNymID)
    
    if (false == bDone)
    {
        OT_API_Output(0, "\n\n FAILED trying to import Cert.\n")
        return (-1)
    }
    else
    {
        OT_API_Output(0, "\n\n SUCCESS importing Cert for NymID: " + strOutNymID + "\n\n")
        return 1
    }
    // -----------------------
    return -1
}

def details_export_cert(strNymID)
{
    var strExportedCert = OT_API_Wallet_ExportCert(strNymID)
    
    return strExportedCert
}

def main_export_cert()
{
    var strUsage = "\n\n USAGE: exportcert --mynym NYM_ID\n"
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    if (VerifyExists("MyNym"))
    {	       
        var strExportedCert = details_export_cert(MyNym)
        
        if (!VerifyStringVal(strExportedCert))
        {
            OT_API_Output(0, "\n\n FAILED trying to export Cert for NymID: " + MyNym + "\n")
            return (-1)
        }
        else
        {
            OT_API_Output(0, "\n\n SUCCESS exporting Cert for NymID: " + MyNym + "\n\n") //stderr
            print(strExportedCert) // stdout
            OT_API_Output(0, "\n") //stderr
            return 1
        }
    }
    
    return -1
}





def main_change_passphrase()
{
    if (OT_API_Wallet_ChangePassphrase())
    {
        return 1
    }
    
    return -1
}







// ------------------------------
//
// SEND TRANSFER (From one asset account to another.)
//


def details_send_transfer(lAmount, strNote)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()

    // ---------------------------------------------
    // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
    //
    var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
    
    if (!VerifyStringVal(strMyNymID))
    {
        OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
        return (-1)
    }
    // ***************************************************************

    // HERE, WE SEND THE TRANSFER REQUEST TO THE SERVER
    //
    var strResponse = madeEasy.send_transfer(Server, strMyNymID, MyAcct, HisAcct, strAmount, strNote) 
    var strAttempt  = "send_transfer"
    /*
     int notarizeTransfer(   const std::string SERVER_ID,
                             const std::string USER_ID,
                             const std::string ACCT_FROM,
                             const std::string ACCT_TO,
                             const std::string AMOUNT,
                             const std::string NOTE);
     */
    // ***************************************************************
    
    // HERE, WE INTERPRET THE SERVER REPLY, WHETHER SUCCESS, FAIL, OR ERROR...
    
    var nInterpretReply = InterpretTransactionMsgReply(Server, strMyNymID, MyAcct, strAttempt, strResponse)
    
    if (1 == nInterpretReply)
    {    
        // Download all the intermediary files (account balance, inbox, outbox, etc)
        // since they have probably changed from this operation.
        //
        var bRetrieved = madeEasy.retrieve_account(Server, strMyNymID, MyAcct, true) //bForceDownload defaults to false.
        
        OT_API_Output(0, "Server response ("+strAttempt+"): SUCCESS sending transfer!\n")
        OT_API_Output(0, (bRetrieved ? "Success" : "Failed") + " retrieving intermediary files for account.\n")
    }
    
    // ***************************************************************
    //
    // Return status to caller.
    //
    return nInterpretReply  
}


// HERE, WE GET ALL THE ARGUMENTS TOGETHER,
// and then call the above function.
//
def main_transfer()
{
    var strUsage1 = concat("\n\n  USAGE: transfer --myacct YOUR_ASSET_ACCT --hisacct RECIPIENT_ASSET_ACCT\n\n",
                           "Also NECESSARY: --args \"amount PUT_AMOUNT_HERE\"\n")
    var strUsage = concat(strUsage1,
                          "And OPTIONALLY: --args \"memo \\\"Just a memo for the transfer.\\\"\"\n\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server") && VerifyExists("MyAcct") && VerifyExists("HisAcct"))
    {	
        // strAmount and strNote...
        //
        var strAmount    = "0" // must be >= 1
        var strNote      = ""  // can be blank
        // ------------------------------------        
        var strDefaultAmount  = "10"  // must be >= 1
        var strDefaultNote    = "(blank memo field)"   // can be blank
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "amount 1"
            // EXAMPLE:  --args "amount 15 note \"Just a memo for the transfer.\""
            //
            var strNewAmount = OT_CLI_GetValueByKey( Args, "amount"    ) // any integer value
            var strNewNote   = OT_CLI_GetValueByKey( Args, "memo"  )     // optional memo field
            
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewAmount))
            {    strAmount = strNewAmount }
            if (VerifyStringVal(strNewNote))
            {    strNote = strNewNote }
        }            
        // ------------------------------------
        // If the transfer parameters aren't provided, then we
        // ask the user to supply them at the command line.
        //
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {
            OT_API_Output(0, "Enter the amount as integer["+strDefaultAmount+"]: ")
            strAmount        = OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strNote))
        {
            OT_API_Output(0, "Optionally, enter a memo on a single line["+strDefaultNote+"]: ")
            strNote	= OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {    strAmount = strDefaultAmount }
        if (!VerifyStringVal(strNote))
        {    strNote = strDefaultNote }
        // ----------------------------------------------    
        
        return details_send_transfer(strAmount, strNote)
    }
    
    return -1
}

// -----------------------


// SET NAME!!



def main_edit_nym()
{
    var strUsage = concat("\n\n USAGE: editnym --mynym YOUR_NYM_ID\n",
                              "Also optionally:         --args \"label \\\"PUT LABEL HERE\\\"\"\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("MyNym"))
    {	
        var strLabel    = ""
        // ------------------------------------        
        var strDefaultLabel    = "(blank label)"   // can be blank
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "label \"FT's test Nym\""
            //
            var strNewLabel   = OT_CLI_GetValueByKey( Args, "label"  )  // optional label field
            // ----------------------------------------------
            // Set the value based on the custom argument.
            //
            if (VerifyStringVal(strNewLabel))
            {    strLabel = strNewLabel }
        }            
        // ------------------------------------
        // If the label isn't provided, then we ask the
        // user to supply it at the command line.
        //
        if (!VerifyStringVal(strLabel))
        {
            OT_API_Output(0, "Enter MyNym's new label ["+strDefaultLabel+"]: ")
            strLabel        = OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strLabel))
        {    strLabel = strDefaultLabel }
        // ----------------------------------------------    
        
        var bSet = OT_API_SetNym_Name(MyNym, MyNym, strLabel)
        
        if (false == bSet)
        {
            OT_API_Output(0, "\n\n FAILED trying to set MyNym's label to: " + strLabel + "\n")
            OT_API_Output(0, "MyNym ID: " + MyNym + "\n\n")
            return (-1)
        }
        else
        {
            OT_API_Output(0, "\n\n SUCCESS setting MyNym's label to: " + strLabel + "\n")
            OT_API_Output(0, "MyNym ID: " + MyNym + "\n\n")
            return 1
        }
    }
    
    return -1
}

// -----------------------



def main_edit_account()
{
    var strUsage = concat("\n\n USAGE: editacct --myacct YOUR_ACCT_ID\n",
                              "Also optionally:          --args \"label \\\"PUT LABEL HERE\\\"\"\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        

    if (VerifyExists("MyAcct"))
    {	
        // ---------------------------------------------
        // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
        //
        var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
        
        if (!VerifyStringVal(strMyNymID))
        {
            OT_API_Output(0, "\n\nFailure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
            return (-1)
        }
        if (VerifyExists("MyNym") && !(MyNym == strMyNymID))
        {
            OT_API_Output(0, "\n\nFailure: MyNym was provided, but didn't match the Nym who owns MyAcct. To override, use: --mynym "+strMyNymID+"\n\n")
            return (-1)
        }
        // ***************************************************************
        //
        var strLabel    = ""
        // ------------------------------------        
        var strDefaultLabel    = "(blank label)"   // can be blank
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "label \"FT's issuer account\""
            //
            var strNewLabel   = OT_CLI_GetValueByKey( Args, "label"  )  // optional label field
            // ----------------------------------------------
            // Set the value based on the custom argument.
            //
            if (VerifyStringVal(strNewLabel))
            {    strLabel = strNewLabel }
        }            
        // ------------------------------------
        // If the label isn't provided, then we ask the
        // user to supply it at the command line.
        //
        if (!VerifyStringVal(strLabel))
        {
            OT_API_Output(0, "Enter MyAcct's new label ["+strDefaultLabel+"]: ")
            strLabel        = OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strLabel))
        {    strLabel = strDefaultLabel }
        // ----------------------------------------------    
        
        var bSet = OT_API_SetAccountWallet_Name(MyAcct, strMyNymID, strLabel)
        
        if (false == bSet)
        {
            OT_API_Output(0, "\n\n FAILED trying to set MyAcct's label to: " + strLabel + "\n")
            OT_API_Output(0, "MyAcct ID: " + MyAcct     + "\n")
            OT_API_Output(0, " MyNym ID: " + strMyNymID + "\n\n")
            return (-1)
        }
        else
        {
            OT_API_Output(0, "\n\n SUCCESS setting MyAcct's label to: " + strLabel + "\n")
            OT_API_Output(0, "MyAcct ID: " + MyAcct     + "\n")
            OT_API_Output(0, " MyNym ID: " + strMyNymID + "\n\n")
            return 1
        }
    }
    
    return -1
}

// -----------------------


def main_edit_asset()
{
    var strUsage = concat("\n\n USAGE: editasset --mypurse ASSET_TYPE_ID\n",
                              "Also optionally:           --args \"label \\\"PUT LABEL HERE\\\"\"\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("MyPurse"))
    {	
        var strLabel    = ""
        // ------------------------------------        
        var strDefaultLabel    = "(blank label)"   // can be blank
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "label \"Silver Grams\""
            //
            var strNewLabel   = OT_CLI_GetValueByKey( Args, "label"  )  // optional label field
            // ----------------------------------------------
            // Set the value based on the custom argument.
            //
            if (VerifyStringVal(strNewLabel))
            {    strLabel = strNewLabel }
        }            
        // ------------------------------------
        // If the label isn't provided, then we ask the
        // user to supply it at the command line.
        //
        if (!VerifyStringVal(strLabel))
        {
            OT_API_Output(0, "Enter MyPurse's new label ["+strDefaultLabel+"]: ")
            strLabel        = OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strLabel))
        {    strLabel = strDefaultLabel }
        // ----------------------------------------------    
        
        var bSet = OT_API_SetAssetType_Name(MyPurse, strLabel)
        
        if (false == bSet)
        {
            OT_API_Output(0, "\n\n FAILED trying to set MyPurse's label to: " + strLabel + "\n")
            OT_API_Output(0, "MyPurse (AssetTypeID): " + MyPurse + "\n\n")
            return (-1)
        }
        else
        {
            OT_API_Output(0, "\n\n SUCCESS setting MyPurse's label to: " + strLabel + "\n")
            OT_API_Output(0, "MyPurse (AssetTypeID): " + MyPurse + "\n\n")
            return 1
        }
    }
    
    return -1
}

// -----------------------


def main_edit_server()
{
    var strUsage = concat("\n\n USAGE: editserver --server SERVER_ID\n",
                              "Also optionally:            --args \"label \\\"PUT LABEL HERE\\\"\"\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server"))
    {	
        var strLabel    = ""
        // ------------------------------------        
        var strDefaultLabel    = "(blank label)"   // can be blank
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "label \"localhost server\""
            //
            var strNewLabel   = OT_CLI_GetValueByKey( Args, "label"  )  // optional label field
            // ----------------------------------------------
            // Set the value based on the custom argument.
            //
            if (VerifyStringVal(strNewLabel))
            {    strLabel = strNewLabel }
        }            
        // ------------------------------------
        // If the label isn't provided, then we ask the
        // user to supply it at the command line.
        //
        if (!VerifyStringVal(strLabel))
        {
            OT_API_Output(0, "Enter Server's new label ["+strDefaultLabel+"]: ")
            strLabel        = OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strLabel))
        {    strLabel = strDefaultLabel }
        // ----------------------------------------------    
        
        var bSet = OT_API_SetServer_Name(Server, strLabel)
        
        if (false == bSet)
        {
            OT_API_Output(0, "\n\n FAILED trying to set Server's label to: " + strLabel + "\n")
            OT_API_Output(0, "Server ID: " + Server + "\n\n")
            return (-1)
        }
        else
        {
            OT_API_Output(0, "\n\n SUCCESS setting Server's label to: " + strLabel + "\n")
            OT_API_Output(0, "Server ID: " + Server + "\n\n")
            return 1
        }
    }
    
    return -1
}

// -----------------------










def main_sendmsg()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------

    // Just to show how easy it is, let's try a "send_user_message" message.

    var strUsage = "\n\n FYI, USAGE: sendmsg --mynym <YOUR_NYM_ID> --hisnym <RECIPIENT_NYM_ID>\n\n"

    OT_API_Output(0, strUsage)

    if (VerifyExists("Server") && VerifyExists("MyNym") && VerifyExists("HisNym"))
    {
        OT_API_Output(0, "Please enter your message on multiple lines, optionally beginning with a \"Subject: \" line.\n")
        OT_API_Output(0, "Use Ctrl-C to cancel, otherwise finish your message with an EOF or a ~ by itself on a blank line:\n\n")

        var strTestMessage = OT_CLI_ReadUntilEOF()
        
        // Send the request.
        //
        var strResponse	= madeEasy.send_user_msg(Server, MyNym, HisNym, strTestMessage)

        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  
        // 
        // Instead, simply check for success or failure:
        //
        if (1 != VerifyMessageSuccess(strResponse))
        {
            OT_API_Output(0, "send_user_msg: Failed.\n");
        }
        else
        {
            OT_API_Output(0, "Success in send_user_msg! Server response:\n\n")
            print(strResponse)
            OT_API_Output(0, "\n\n")
            return 1
        }
    }
    
    return -1
}















def main_write_cheque()
{
    // TODO:  Add a call or two inside this function, so that it is actually smart enough to grab
    // more transaction numbers if it is low.
    
    if (VerifyExists("MyAcct") && VerifyExists("Server") && VerifyExists("HisNym"))
    {
        // ---------------------------------------------
        // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
        //
        var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
        
        if (!VerifyStringVal(strMyNymID))
        {
            OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
            return (-1)
        }
        if (VerifyExists("MyNym") && !(MyNym == strMyNymID))
        {
            OT_API_Output(0, "\n\nFailure: MyNym was provided, but didn't match the Nym who owns MyAcct. To override, use: --mynym "+strMyNymID+"\n\n")
            return (-1)
        }
        // ***************************************************************
        
        var strDefaultAmount = "1"       // smallest possible amount.
        var strDefaultMemo   = "(memo field)" 
        var nDefaultLength   = 2592000   // 30 days
        
        var strAmount = "0"
        var strMemo   = ""  // empty
        var nLength   = 0   
        
        // ------------------------------------
        if (VerifyExists("Args"))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "amount 100 memo \"my share for the BBQ\""
            //
            var strNewAmount = OT_CLI_GetValueByKey( Args, "amount" )
            var strNewMemo   = OT_CLI_GetValueByKey( Args, "memo" )
            var strNewLength = OT_CLI_GetValueByKey( Args, "validfor" )
            
            if (VerifyStringVal(strNewMemo)) 
            { strMemo = strNewMemo }
            
            if (VerifyStringVal(strNewAmount) && (strNewAmount.to_int() > 0))
            { strAmount = strNewAmount }
            
            if (VerifyStringVal(strNewLength) && (strNewLength.to_int() > 0))
            { nLength = strNewLength.to_int() }
        }
        
        // ------------------------------------
        // If the transfer parameters aren't provided, then we
        // ask the user to supply them at the command line.
        //
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {
            OT_API_Output(0, "Enter the amount as integer["+strDefaultAmount+"]: ")
            strAmount  = OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strMemo))
        {
            OT_API_Output(0, "Optionally, enter a note on a single line["+strDefaultMemo+"]: ")
            strMemo	= OT_CLI_ReadLine()
        }
        if (!VerifyIntVal(nLength) || (nLength < 1))
        {
            OT_API_Output(0, "Enter the 'valid for' time period, in seconds["+nDefaultLength.to_string()+"]: ")
            var strTemp	= OT_CLI_ReadLine()
            nLength = strTemp.to_int()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {    strAmount = strDefaultAmount }
        
        if (!VerifyStringVal(strMemo))
        {    strMemo = strDefaultMemo }
        
        if (!VerifyIntVal(nLength) || (nLength < 1))
        {    nLength = nDefaultLength }
        // ----------------------------------------------    
        
        
        // Todo: use Args feature here to allow an option to override nLength.
        // If it's not used, go with the default of 30 days (above.)
        
        
        var lFrom = OT_API_GetTime()
        var   nTo   = strFrom + nLength
        var strTo   = nTo.to_string()
        
//      std::string OT_API_WriteCheque ( const std::string SERVER_ID,
//										 const std::string CHEQUE_AMOUNT, 
//										 const std::string VALID_FROM, 
//										 const std::string VALID_TO,
//										 const std::string SENDER_ACCT_ID,
//										 const std::string SENDER_USER_ID,
//										 const std::string CHEQUE_MEMO, 
//										 const std::string RECIPIENT_USER_ID);
        
        var strCheque = OT_API_WriteCheque (Server,
                                            strAmount, 
                                            strFrom, 
                                            strTo,
                                            MyAcct,
                                            strMyNymID,
                                            strMemo, 
                                            HisNym)
        
        // stderr
        OT_API_Output(0, "\n-------------------------------------------\n the cheque:\n\n")
        
        // stdout
        print(strCheque)
        
        // stderr
        OT_API_Output(0, "\n\n")
        
        return 1
    }
    
    // "return value"
    -1
}




















def details_create_offer(strScale, strMinIncrement, strQuantity, strPrice, bSelling) : strScale.is_type(string_type) && strMinIncrement.is_type(string_type) && strQuantity.is_type(string_type) && strPrice.is_type(string_type) && bSelling.is_type(bool_type)
{
    // NOTE: The top half of this function has nothing to do with placing a new offer.
    // Instead, as a convenience for knotwork, it first checks to see if there are any
    // existing offers within certain parameters based on this new one, and removes them
    // if so. Only then, after that is done, does it actually place the new offer.
    // (Meaning: most of the code you see here at first is not actually necessary for
    // placing offers, but was done at the request of a server operator.)
    //
    var strLocation = "details_create_offer"
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    
    var strMyNymID  = OT_API_GetAccountWallet_NymID(MyAcct)
    var strMyNymID2 = OT_API_GetAccountWallet_NymID(HisAcct)
    
    if (!VerifyStringVal(strMyNymID) || !VerifyStringVal(strMyNymID2) || (strMyNymID != strMyNymID2))
    {
        OT_API_Output(0, "You must supply myacct as your asset account, and hisacct as your currency account.\n")
        OT_API_Output(0, "Also, both accounts must be owned by the same Nym (you.)\n\n")
        return (-1)
    }
    // ----------------------------------------------
    
    var strMyServerID  = OT_API_GetAccountWallet_ServerID(MyAcct)
    var strMyServerID2 = OT_API_GetAccountWallet_ServerID(HisAcct)
    
    if (!VerifyStringVal(strMyServerID) || !VerifyStringVal(strMyServerID2) || (strMyServerID != strMyServerID2) )
    {
        OT_API_Output(0, "Both accounts must be on the same server.\n")
        return (-1)
    }
    // Below this point we're safe to use Server.
    // ----------------------------------------------
    
    // We're about to load up the Nym's market offers so we can see if there are
    // any we should cancel before placing this new offer.
    //
    // Therefore, I'm going to download the Nym's market offers before loading them
    // up, in case we don't even have the current list of them.

    details_get_nym_market_offers(strMyServerID, strMyNymID)
    
    // ----------------------------------------------    
    /*
     me: How about this — when you do "opentxs newoffer" I can alter that 
     script to automatically cancel any sell offers for a lower amount 
     than my new buy offer, if they're on the same market at the same scale.
     and vice versa. Vice versa meaning, cancel any bid offers for a higher
     amount than my new sell offer.

     knotwork: yeah that would work.
     
     So when placing a buy offer, check all the other offers I already have at the same scale,
     same asset and currency ID. (That is, the same "market" as denoted by strMapKey in "opentxs showmyoffers")
     For each, see if it's a sell offer and if so, if the amount is lower than the amount on
     the new buy offer, then cancel that sell offer from the market. (Because I don't want to buy-high, sell low.)
     
     Similarly, if placing a sell offer, then check all the other offers I already have at the
     same scale, same asset and currency ID, (the same "market" as denoted by strMapKey....) For
     each, see if it's a buy offer and if so, if the amount is higher than the amount of my new
     sell offer, then cancel that buy offer from the market. (Because I don't want some old buy offer
     for $10 laying around for the same stock that I'm SELLING for $8! If I dump 100 shares, I'll receive
     $800--I don't want my software to automatically turn around and BUY those same shares again for $1000!
     That would be a $200 loss.)
     
     This is done here:
     */
        
    var offerList := loadNymOffers(strMyServerID, strMyNymID)
    
    if (!VerifyStorable(offerList, "OTDB_OfferListNym"))
    {
        OT_API_Output(0, strLocation+": Unable to load up a (nym) offerList from local storage. Probably doesn't exist.\n")
    }
    // ----------------------------------
    else
    {
        // LOOP THROUGH THE OFFERS and sort them into a map_of_maps, key is: scale-assetID-currencyID
        // the value for each key is a sub-map, with the key: transaction ID and value: the offer data itself.
        //
        var nCount = offerList.GetOfferDataNymCount() // size_t
        var nTemp  = nCount // so it's created as size_t
        
        if (VerifyIntVal(nCount) && (nCount > 0))
        {        
            var map_of_maps := convert_offerlist_to_maps(offerList)
            
            if (!VerifyType(map_of_maps, "Map"))
            {
                OT_API_Output(0, strLocation+": Unable to convert offer list to map of offers. Perhaps it's empty?\n")
            }
            else
            {
                // -------------------------------------------        
                // find_strange_offers is called for each offer, for this nym,
                // as it iterates through the maps. When it's done, extra_vals.the_vector 
                // will contain a vector of all the transaction numbers for offers that we 
                // should cancel, before placing the new offer. (Such as an offer to sell for
                // 30 clams when our new offer buys for 40...)
                //
                var extra_vals = the_lambda_struct()
                
                extra_vals.the_asset_acct    = MyAcct
                extra_vals.the_currency_acct = HisAcct
                extra_vals.the_scale         = strScale
                extra_vals.the_price         = strPrice
                extra_vals.bSelling          = bSelling        
                // ----------------------------------
                var nIterated = iterate_nymoffers_maps(map_of_maps, find_strange_offers, extra_vals)
                
                if ((-1) == nIterated)
                {
                    OT_API_Output(0, strLocation+": Error trying to iterate nym's offers.\n")
                    return (-1)
                }
                // ----------------------------------
                // Okay -- if there are any offers we need to cancel, extra_vals.the_vector now contains
                // the transaction number for each one. Let's remove them from the market before
                // starting up the new offer...
                //
                
                OT_API_Output(0, strLocation+": FYI, about to cancel at least one market offer, before placing the new one, due to price inconsistencies between the two...\n")
                
                while (extra_vals.the_vector.size() > 0)
                {
                    OT_API_Output(0, strLocation+": Canceling market offer with transaction number: " + extra_vals.the_vector[0] + "\n")
                    
                    details_cancel_offer(strMyServerID, strMyNymID, MyAcct, extra_vals.the_vector[0])
                    extra_vals.the_vector.erase_at(0)
                }
            }
        }
        else
        {
            OT_API_Output(0, strLocation+": FYI, there don't seem to be any existing offers for this nym, so I won't be erasing any older ones.\n")
        }
    }
    // ********************************************************************
    
    // OKAY! Now that we've cleaned out any undesirable offers, let's place the
    // the offer itself!    
    
    // ----------------------------------------------
    //
    // Send the "create offer" transaction.
    //
    var strResponse	= madeEasy.create_market_offer(strMyServerID, strMyNymID, MyAcct, HisAcct, strScale, strMinIncrement, strQuantity, strPrice, bSelling)
    var strAttempt  = "create_market_offer"
    // ----------------------------------------------
    // NOTICE: No need here to deal with retries, timeouts, request number,
    // syncing transaction number, download / process nymbox, etc! It's all
    // handled at a lower level!  Instead, simply check for success or failure:
    
    // ***************************************************************
    
    var nInterpretReply = InterpretTransactionMsgReply(strMyServerID, strMyNymID, MyAcct, strAttempt, strResponse)
    
    if (1 == nInterpretReply)
    {    OT_API_Output(0, "Server response ("+strAttempt+"): SUCCESS placing market offer!\n\n") }
    
    return nInterpretReply
}



def main_create_offer()
{
    var strUsage = concat("\n\n USAGE: newoffer --myacct <YOUR_ASSET_ACCT> --hisacct <YOUR_CURRENCY_ACCT>\n\n",
                          " Optional: --args \"type <bid|ask> scale 1 quantity 100 price 101\"\n\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("MyAcct") && VerifyExists("HisAcct"))
    {
        var strScale               = "0" // must be 1, 10, 100, etc
        var strMinIncrement        = "0" // must be 1, 2, 3, etc
        var strQuantity            = "0" // must be >= 1
        var strPrice               = "0" // must be >= 1
        var strType                = ""  // must be bid or ask
        // ------------------------------------        
        var strDefaultScale        = "1"    // must be 1, 10, 100, etc
        var strDefaultMinIncrement = "1"    // must be 1, 2, 3, etc
        var strDefaultQuantity	   = "100"  // must be >= 1
        var strDefaultPrice		   = "101"  // must be >= 1
        var strDefaultType         = "bid"  // must be bid or ask
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args"))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "type bid scale 1 quantity 100 price 101"
            // EXAMPLE:  --args "type ask scale 1 quantity 100 price 101"
            //
            var strNewScale    = OT_CLI_GetValueByKey( Args, "scale"    ) // 1, 10, 100, 1000, etc
            var strNewMinInc   = OT_CLI_GetValueByKey( Args, "min_inc"  ) // 1, 2, 3, 4, etc. Usually 1.
            var strNewQuantity = OT_CLI_GetValueByKey( Args, "quantity" ) // quantity for sale/purchase. 
            var strNewPrice    = OT_CLI_GetValueByKey( Args, "price"    ) // per scale
            var strNewType     = OT_CLI_GetValueByKey( Args, "type"    )  // bid / ask
            
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewScale))
            {    strScale = strNewScale }
            if (VerifyStringVal(strNewMinInc))
            {    strMinIncrement = strNewMinInc }
            if (VerifyStringVal(strNewQuantity))
            {    strQuantity = strNewQuantity }
            if (VerifyStringVal(strNewPrice))
            {    strPrice = strNewPrice }
            if (VerifyStringVal(strNewType))
            {    strType = strNewType }
        }            
        // ------------------------------------
        // If the offer parameters aren't satisfied yet, then
        // ask the user to supply them at the command line.
        //
        if (!VerifyStringVal(strScale) || (strScale.to_int() < 1))
        {
            OT_API_Output(0, "Enter the market scale (1, 10, 100, etc)["+strDefaultScale+"]: ")
            strScale        = OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strMinIncrement) || (strMinIncrement.to_int() < 1))
        {
            OT_API_Output(0, "Enter the minimum increment["+strDefaultMinIncrement+"]: ")
            strMinIncrement	= OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strQuantity) || (strQuantity.to_int() < 1))
        {
            OT_API_Output(0, "Enter the quantity being purchased/sold["+strDefaultQuantity+"]: ")
            strQuantity		= OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strPrice) || (strPrice.to_int() < 1))
        {
            OT_API_Output(0, "Enter the price per scale["+strDefaultPrice+"]: ")
            strPrice		= OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strType) || ((strType != "bid") && (strType != "ask")))
        {
            OT_API_Output(0, "Enter the order type (bid/ask) ["+strDefaultType+"]: ")
            strType		= OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strScale) || (strScale.to_int() < 1))
        {    strScale = strDefaultScale }
        if (!VerifyStringVal(strMinIncrement) || (strMinIncrement.to_int() < 1))
        {    strMinIncrement = strDefaultMinIncrement }
        if (!VerifyStringVal(strQuantity) || (strQuantity.to_int() < 1))
        {    strQuantity = strDefaultQuantity }
        if (!VerifyStringVal(strPrice) || (strPrice.to_int() < 1))
        {    strPrice = strDefaultPrice }
        if (!VerifyStringVal(strType)  || ((strType != "bid") && (strType != "ask")))
        {    strType = strDefaultType }
        // ----------------------------------------------    
        //
        // false == buying    bid
        // true  == selling   ask
        //
        var bType	= ((strType == "bid") ? false : true);
        // ----------------------------------------------    
        return details_create_offer(strScale, strMinIncrement, strQuantity, strPrice, bType)
    }
    
    return (-1)
}













def main_create_server_contract()
{
    if (VerifyExists("MyNym"))
    {
        OT_API_Output(0, "Please enter the XML contents for the contract, followed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        
        var strXML = OT_CLI_ReadUntilEOF() 
        
        if (VerifyStringVal(strXML))
        {
            var strContractID = OT_API_CreateServerContract(MyNym, strXML)
            
            if (VerifyStringVal(strContractID))
            {
                // stderr
                OT_API_Output(0, "-------------------------------------------\nNew Contract ID: " + strContractID + "\n\n")
                
                var strContract = OT_API_GetServer_Contract(strContractID)
                
                if (VerifyStringVal(strContract))
                {
                    // stderr
                    OT_API_Output(0, "-------------------------------------------\nNew Contract:\n\n")
                    
                    // stdout
                    print(strContract)
                    
                    OT_API_Output(0, "\n\n")
                    
                    return 1
                }
            }
        }
    }
    
    // "return value"
    -1
}









def main_create_asset_contract()
{
    // bool OTContract::CreateContract(OTString & strContract, OTPseudonym & theSigner)
    
    if (VerifyExists("MyNym"))
    {
        OT_API_Output(0, "Please enter the XML contents for the contract, followed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        
        var strXML = OT_CLI_ReadUntilEOF() 
        
        if (VerifyStringVal(strXML))
        {
            var strContractID = OT_API_CreateAssetContract(MyNym, strXML)
            
            if (VerifyStringVal(strContractID))
            {
                // stderr
                OT_API_Output(0, "-------------------------------------------\nNew Contract ID: " + strContractID + "\n\n")
                
                var strContract = OT_API_GetAssetType_Contract(strContractID)
                
                if (VerifyStringVal(strContract))
                {
                    // stderr
                    OT_API_Output(0, "-------------------------------------------\nNew Contract:\n\n")
                    
                    // stdout
                    print(strContract)
                    
                    OT_API_Output(0, "\n\n")
                    
                    return 1
                }
            }
        }
    }
    
    // "return value"
    -1
}










def main_create_acct()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    
    // Just to show how easy it is now, let's try a "create_asset_acct" message.
    // (It sends a NymID to the server, and downloads that Nym's public key.)
    
    if (VerifyExists("Server") && VerifyExists("MyNym") && VerifyExists("MyPurse"))
    {	
        if (!OT_API_IsNym_RegisteredAtServer(MyNym, Server))
        {
            // If the Nym's not registered at the server, then register him first.
            main_register_nym()
        }
        // --------------------------
        // Send the request.
        //
        var strResponse	= madeEasy.create_asset_acct(Server, MyNym, MyPurse)	// Send the 'create_asset_acct' message to the server.
        
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        
        // -1 error, 0 failure, 1 success.
        //
        if (1 != VerifyMessageSuccess(strResponse))
        {
            OT_API_Output(0, "\n\ncreate_asset_acct: Failed.\n\n");
            return -1
        }
        else
        {
            OT_API_Output(0, "Success in create_asset_acct! Server response:\n\n") // stderr
            print(strResponse) // stdout
            OT_API_Output(0, "\n\n") //stderr
            return 1
        }
    }
    
    // Done!
    -1
}











def main_add_signature()
{
    // SignContract erases all signatures and affixes a new one alone.
    // But AddSignature, on the other hand, leaves all signatures in place, and simply adds yours to the list. 
    
    if (VerifyExists("MyNym"))
    {
        
        OT_API_Output(0, "Please enter an already-signed contract you wish to add your signature to, followed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        
        var strInput = OT_CLI_ReadUntilEOF() 
        
        OT_API_Output(0, "\n\n You entered:\n" + strInput + "\n\n") 
        
        var strOutput = OT_API_AddSignature(MyNym, strInput) 
        
        // stderr
        OT_API_Output(0, "-------------------------------------------\nSigned:\n\n")
        
        // stdout
        print(strOutput)
        
        // stderr
        OT_API_Output(0, "\n\n")
        
        return 1
    }
    
    // "return value"
    -1 
}






def main_sign_contract()
{
    // SignContract erases all signatures and affixes a new one alone.
    // But AddSignature, on the other hand, leaves all signatures in place, and simply adds yours to the list.
    
    var strUsage = concat("\n\n FYI, USAGE: sign \n",
                          " Optionally, you may specify a contract type:  sign --args \"type LEDGER\"\nIn that example, the output would start with the bookend: -----BEGIN OT SIGNED LEDGER-----\n(You don't need to specify the type if the bookend is already present on the input string.)\n\n")
    
    OT_API_Output(0, strUsage)

    if (VerifyExists("MyNym"))
    {
        OT_API_Output(0, "Please enter a contract to be signed, followed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        
        var strInput = OT_CLI_ReadUntilEOF() 
        
        OT_API_Output(0, "\n\n You entered:\n" + strInput + "\n\n") 
        
        var strOutput = OT_API_SignContract(MyNym, strInput) 
        
        if (!VerifyStringVal(strOutput))
        {
            // Maybe we need to flat sign (maybe it wasn't already a signed contract...)
            //
            var strContractType

            if (VerifyExists("Args"))
            {
                strContractType = OT_CLI_GetValueByKey(Args, "type")
            }
            // --------------------------------------------
            if (VerifyStringVal(strContractType))
            {
                OT_API_Output(0, "A properly-formed-and-signed contract was not provided, but a 'type' was... so we'll try flatsigning the input text...\n\n")
                strOutput = OT_API_FlatSign(MyNym, strInput, strContractType) 
            }
            else
            {
                OT_API_Output(0, "A properly-formed-and-signed contract was not provided, and neither was a 'type' in order to form one. (Failure.)\n")
                OT_API_Output(0, strUsage)
                return -1
            }
        }
        // ------------------------------------
        
        var nReturnVal = -1
        
        if (VerifyStringVal(strOutput))
        {
            // stderr
            OT_API_Output(0, "-------------------------------------------\nSigned:\n\n")
            
            // stdout
            print(strOutput)
            
            nReturnVal = 1
        }
        else
        {
            OT_API_Output(0, "Sorry, but OT was unable to sign. Oh well.")
        }
        // ------------------------------------        
        // stderr
        OT_API_Output(0, "\n\n")
        
        return nReturnVal
    }
    
    // "return value"
    -1
}












def details_cancel_offer(strServerID, strNymID, strAcctID, strTransNum)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
        
    // Just to show how easy it is now, let's try a "cancel_payment_plan" message.
    // (It cancels a payment plan.)
    
    if (VerifyStringVal(strServerID) && VerifyStringVal(strNymID) && VerifyStringVal(strAcctID) && VerifyStringVal(strTransNum))
    {	
        // Send the transaction.
        //        
        var strResponse	= madeEasy.cancel_market_offer(strServerID, strNymID, strAcctID, strTransNum)
        
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        
        if (1 != VerifyMessageSuccess(strResponse))
        {
            OT_API_Output(0, "\n\n canceloffer: Failed.\n")
        }
        else if (1 != VerifyMsgBalanceAgrmntSuccess(strServerID, strNymID, strAcctID, strResponse))
        {
            OT_API_Output(0, "\n\n canceloffer: Balance agreement failed.\n")
        }
        else if (1 != VerifyMsgTrnxSuccess(strServerID, strNymID, strAcctID, strResponse))
        {
            OT_API_Output(0, "\n\n canceloffer: Balance agreement succeeded, but transaction failed.\n")
        }
        else
        {
            OT_API_Output(0, "\n\nSuccess in canceloffer! Server response:\n\n")
            print(strResponse) // stdout
            OT_API_Output(0, "\n") // stderr
            return 1
        }
    }
    
    // Done!
    -1
}




def main_cancel_offer()
{
    // ------------------------------
    
    var strUsage = "\n\n FYI, USAGE: canceloffer --args \"transnum <transaction_number>\"\n\n"
    
    // Just to show how easy it is now, let's try a "cancel_payment_plan" message.
    // (It cancels a payment plan.)
    
    if (!VerifyExists("Server") || !VerifyExists("MyNym") || !VerifyExists("MyAcct") || !VerifyExists("Args"))
    {  OT_API_Output(0, strUsage)  }
    else
    {	
        var strTransactionNum = OT_CLI_GetValueByKey(Args, "transnum")
        
        if (!VerifyStringVal(strTransactionNum) )
        {
            OT_API_Output(0, "\n\n\nYou need to provide a transaction number...\n\n")
            OT_API_Output(0, strUsage)
        }
        else
        {
            return details_cancel_offer(Server, MyNym, MyAcct, strTransactionNum)            
        }
    }
    
    // Done!
    -1
}









def main_cancel_plan()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    
    // string OT_CLI_GetValueByKey(Args, str_key)
    
    var strUsage = "\n\n FYI, USAGE: cancel_plan.ot --args \"transnum <transaction_number>\"\n\n"
    
    // Just to show how easy it is now, let's try a "cancel_payment_plan" message.
    // (It cancels a payment plan.)
    
    if (!VerifyExists("Server") || !VerifyExists("MyNym") || !VerifyExists("MyAcct") || !VerifyExists("Args"))
    {  OT_API_Output(0, strUsage)  }
    else
    {	
        var strTransactionNum = OT_CLI_GetValueByKey(Args, "transnum")
        
        if (!VerifyStringVal(strTransactionNum) )
        {
            OT_API_Output(0, "\n\n\nYou need to provide a transaction number...\n\n")
            OT_API_Output(0, strUsage)
        }
        else
        {
            // Send the transaction.
            //
            var strResponse	= madeEasy.cancel_payment_plan(Server, MyNym, MyAcct, strTransactionNum)
            
            // NOTICE: No need here to deal with retries, timeouts, request number,
            // syncing transaction number, download / process nymbox, etc! It's all
            // handled at a lower level!  Instead, simply check for success or failure:
            
            if (1 != VerifyMessageSuccess(strResponse))
            {
                OT_API_Output(0, "\n\ncancel_payment_plan: Failed.\n")
            }
            else if (1 != VerifyMsgBalanceAgrmntSuccess(Server, MyNym, MyAcct, strResponse))
            {
                OT_API_Output(0, "\n\ncancel_payment_plan: Balance agreement failed.\n")
            }
            else if (1 != VerifyMsgTrnxSuccess(Server, MyNym, MyAcct, strResponse))
            {
                OT_API_Output(0, "\n\ncancel_payment_plan: Balance agreement succeeded, but transaction failed.\n")
            }
            else
            {
                OT_API_Output(0, "\n\nSuccess in cancel_payment_plan! Server response:\n\n")
                print(strResponse) // stdout
                OT_API_Output(0, "\n\n") // stderr
                return 1
            }
        }
    }
    
    // Done!
    -1
}








def main_verify_signature()
{
    if (VerifyExists("HisNym"))
    {
        OT_API_Output(0, "Please enter a contract you wish to verify with HisNym, followed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        
        var strInput = OT_CLI_ReadUntilEOF() 
        
        OT_API_Output(0, "\n\n--------------------------------------\n You entered:\n" + strInput + "\n\n") 
        
        var bSuccess = false
        
        bSuccess = OT_API_VerifySignature(HisNym, strInput) 
        
        if (bSuccess)
        {
            print("\n\n *** Verified! ***\n\n")
            return 1
        }
        else
        {
            print("Failed!\n\n")
        }
    }
    
    // return value
    -1
}








def stat_nyms()
{
    print("------------------------------------------------------------------")
    print(" ** PSEUDONYMS: " + "\n")
    
    var nNymCount = OT_API_GetNymCount()
    
    for (var i = 0; i < nNymCount; ++i)
    {
        var strID   = OT_API_GetNym_ID(i)
        var strName = OT_API_GetNym_Name(strID)
        
        print(strID + " ---  " + strName)
    }
    
    1
}

def stat_servers()
{
    print("------------------------------------------------------------------")
    print(" ** SERVERS: " + "\n")
    var nServerCount = OT_API_GetServerCount()
    
    for (var i = 0; i < nServerCount; ++i)
    {
        var strID   = OT_API_GetServer_ID(i)
        var strName = OT_API_GetServer_Name(strID)
        
        print(strID + " ---  " + strName)
    }
    
    1
}

def stat_assets()
{
    print("------------------------------------------------------------------")
    print(" ** ASSET TYPES: " + "\n")
    var nAssetTypeCount = OT_API_GetAssetTypeCount()
    
    for (var i = 0; i < nAssetTypeCount; ++i)
    {
        var strID   = OT_API_GetAssetType_ID(i)
        var strName = OT_API_GetAssetType_Name(strID)
        
        print(strID + " ---  " + strName)
    }
    
    1
}

def stat_accounts()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    
    
    print("------------------------------------------------------------------")
    print(" ** ACCOUNTS: " + "\n")
    
    var nAccountCount = OT_API_GetAccountCount()
    
    for (var i = 0; i < nAccountCount; ++i)
    {
        if ((i > 0) && (i != (nAccountCount))) { print("-------------------------------------"); }
        var strID            = OT_API_GetAccountWallet_ID(i)
        
        var strStatAcct      = madeEasy.stat_asset_account(strID)
        
        var bSuccess         = VerifyStringVal(strStatAcct)
        if (bSuccess)
        {    
            print(strStatAcct)  
        }
        else
        {
            print("Error trying to stat an asset account: "+strID)
        }
        // stderr
        print("")
    }
    print("------------------------------------------------------------------")
    
    1
}

def main_stat() 
{
    print("");
    
    stat_nyms()
    stat_servers()
    stat_assets()
    stat_accounts()
    
    1
}












def details_stat_account(strID)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    
    // stderr
    OT_API_Output(0, "\n\n------------------------------------------------------------------\n")
    
    var strStatAcct = madeEasy.stat_asset_account(strID)
    
    var bSuccess = VerifyStringVal(strStatAcct)
    var nSuccess = (bSuccess ? 1 : -1)
    
    if (bSuccess)
    {    
        print(strStatAcct)  
    }
    else
    {
        print("Error trying to stat an asset account: "+strID+"\n")
    }
    // stderr
    OT_API_Output(0, "\n")
    
    return nSuccess
}



def main_stat_acct() 
{
    if (VerifyExists("MyAcct"))
    {	
        return details_stat_account(MyAcct)
    }
    return (-1)
}










def details_account_balance(strID)
{
    var strName          = OT_API_GetAccountWallet_Name(strID)
    var lBalance       = OT_API_GetAccountWallet_Balance(strID)
    
    OT_API_Output(0, "\n    Balance: ") //stderr
    print(lBalance.to_string()) // stdout
    OT_API_Output(0, strID + "   (" + strName + ")\n\n") //stderr
    
    return 1
}

def main_balance() 
{
    if (VerifyExists("MyAcct"))
    {	
        return details_account_balance(MyAcct)
    }
    return -1
}









def details_nym_stat(strID)
{
//  var strName    = OT_API_GetNym_Name(strID)
    var strStats   = OT_API_GetNym_Stats(strID)
    
    print(strStats) // stdout
    
    1
}


def main_nym_stat() 
{
    if (VerifyExists("MyNym"))
    {	
        return details_nym_stat(MyNym)
    }
    return -1
}












def main_show_mint()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    // SHOW MINT
    // 
    // (Load a public mint from local storage and display it on the screen.
    // If necessary, download it from the server.)
    //
    
    if (VerifyExists("Server") && VerifyExists("MyNym") && VerifyExists("MyPurse"))
    {	
        // Just to show how easy it is now, let's load up a mint and display it.
        // If this function is unable to load it, it will download the mint from
        // the server.
        //
        var strMint	= madeEasy.load_or_retrieve_mint(Server, MyNym, MyPurse) // <=====
        
        // NOTICE -- there's no need here to deal with retries, timeouts, request number, synching 
        // transaction number, download / process nymbox, etc! It's all handled interally.
        //
        // Simply "verify" the return value:
        //
        if (!VerifyStringVal(strMint))
        {
            OT_API_Output(0, "\n\n load_or_retrieve_mint: Failed.\n\n")
	        return -1
        }
        else	// Success!
        {
            OT_API_Output(0, "\n\n") // stderr
            print(strMint)           // stdout
            OT_API_Output(0, "\n\n") // stderr
            return 1
        }
    }
    
    // Done!
    -1
}














// Creates a new Pseudonym and adds it to the wallet.
// (And sets the display name for the new Nym, in the wallet.)
// Prints the new NymID to stdout.
//
// Returns 1 for success, 0 for failure.
//
def details_create_nym(nKeybits, strName)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    
    var strNymID = madeEasy.create_pseudonym(nKeybits)  // returns new Nym ID
    
    if (!VerifyStringVal(strNymID))
    {
        OT_API_Output(0, "details_create_nym: Failed in OT_ME::create_pseudonym(keybits == " + nKeybits.to_string() + ")\n")
        return (-1)
    }
    OT_API_Output(0, "Success creating! " + nKeybits.to_string() + " keybits, new ID: ") // stderr
    print(strNymID) // stdout
    OT_API_Output(0, "\n") //stderr
    // -------------------
    var bSetName = OT_API_SetNym_Name(strNymID, // subject
                                      strNymID, // signer
                                      strName)
    if (!bSetName)
    {
        OT_API_Output(0, "Failed in OT_API_SetNym_Name(name == " + strName + ")\n")
        return (-1)
    }
    // -------------------    
    OT_API_Output(0, "Success setting name to: " + strName + "\n\n") // stderr
    return 1
}


def main_create_nym()
{
    var nKeybits = 1024
    var strName  = "New Nym"
    // ------------------------------------
    if (VerifyExists("Args"))
    {
        // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
        //                                  const std::string str_key)
        // 
        // OPTION:   --args "key value key value"
        //
        // EXAMPLE:  --args "keybits 1024"
        //
        var strKeybits = OT_CLI_GetValueByKey( Args, "keybits" )
        
        var strNewName = OT_CLI_GetValueByKey( Args, "name" )
        
        if (VerifyStringVal(strKeybits) && (strKeybits.to_int() > 0))
        { nKeybits = strKeybits.to_int() }
        
        if (VerifyStringVal(strNewName))
        { strName = strNewName }
    }
    // ------------------------------------
    
    return details_create_nym(nKeybits, strName)
}















/*
 call OT_API_LoadInbox() to load the inbox ledger from local storage.
 
 During this time, your user has the opportunity to peruse the inbox, and to decide which transactions therein he wishes to accept or reject. Usually the inbox is display on the screen, then the user selects various items to accept or reject, and then the user clicks “Process Inbox” and then you do this:
 Then call OT_API_Ledger_CreateResponse() in order to create a ‘response’ ledger for that inbox, which will be sent to the server to signal your responses to the various inbox transactions.
 Then call OT_API_Ledger_GetCount() (pass it the inbox) to find out how many transactions are inside of it. Use that count to LOOP through them…
 Use OT_API_Ledger_GetTransactionByIndex() to grab each transaction as you iterate through the inbox. (There are various introspection functions you can use in the API here if you wish to display the inbox items on the screen for the user…) 
 Next call OT_API_Transaction_CreateResponse() for each transaction in the inbox, to create a response to it, accepting or rejecting it. This function creates the response and adds it to the response ledger.
 Next, call OT_API_Ledger_FinalizeResponse() which will create a Balance Agreement for the ledger.
 Finally, call OT_API_processInbox() to send your message to the server and process the various items.
 
 If the message was successful, then use OT_API_Message_GetBalanceAgreementSuccess() and OT_API_Message_GetTransactionSuccess() as described above in the deposit cash instructions.
 */
// ------------------------------
//
// PROCESS INBOX, ACCEPTING ALL ITEMS WITHIN...
// 
// Load an asset account's inbox from local storage and iterate through
// the items inside, and fire off a server message accepting them all.
//

def accept_entire_inbox()
{
    // ---------------------------------------------
    
    var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
    
    if (!VerifyStringVal(strMyNymID))
    {
        OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
        return (-1)
    }
    // ----------------------------------------------
    
    var strInbox = OT_API_LoadInbox(Server, strMyNymID, MyAcct); // Returns NULL, or an inbox.
    
	if (!VerifyStringVal(strInbox))
	{
		OT_API_Output(0, "\n\n OT_API_LoadInbox: Failed.\n\n")
        return -1
	}
	else	// Success!
	{
		OT_API_Output(0, "\n\n") // stderr
        //		print(strInbox)          // stdout
        
        var nCount = OT_API_Ledger_GetCount(Server, strMyNymID, MyAcct, strInbox)
        
        if (VerifyIntVal(nCount) && (nCount > 0))
        {
            var strResponseLEDGER = OT_API_Ledger_CreateResponse(Server, strMyNymID, MyAcct, strInbox)
            
            if (!VerifyStringVal(strResponseLEDGER))
            {
                OT_API_Output(0, "\n\nFailure: OT_API_Ledger_CreateResponse returned NULL.\n")
                return (-1)
            }
            // ----------------------------------
            for (var nIndex = 0; nIndex < nCount; ++nIndex)
            {
                var strTrans              = OT_API_Ledger_GetTransactionByIndex(Server, strMyNymID, MyAcct, strInbox, nIndex)                
                var strNEW_ResponseLEDGER = OT_API_Transaction_CreateResponse(Server, strMyNymID, MyAcct, strResponseLEDGER, strTrans, true) // accept = true  
                
                if (!VerifyStringVal(strNEW_ResponseLEDGER))
                {
                    OT_API_Output(0, "\n\nFailure: OT_API_Transaction_CreateResponse returned NULL.\n")
                    return (-1)
                }
                strResponseLEDGER = strNEW_ResponseLEDGER
            } // for
            // ----------------------------------
            var strFinalizedResponse = OT_API_Ledger_FinalizeResponse(Server, strMyNymID, MyAcct, strResponseLEDGER)
            
            if (!VerifyStringVal(strFinalizedResponse))
            {
                OT_API_Output(0, "\n\nFailure: OT_API_Ledger_FinalizeResponse returned NULL.\n")
                return (-1)
            }
            // ***************************************************************
            
            // Instantiate the "OT Made Easy" object.
            //
            var madeEasy	= OT_ME()
            
            // Server communications are handled here...
            //
            var strResponse = madeEasy.process_inbox(Server, strMyNymID, MyAcct, strFinalizedResponse) 
            var strAttempt  = "process_inbox"
            
            // ***************************************************************
            
            var nInterpretReply = InterpretTransactionMsgReply(Server, strMyNymID, MyAcct, strAttempt, strResponse)
            
            if (1 == nInterpretReply)
            {    
                // Download all the intermediary files (account balance, inbox, outbox, etc)
                // since they have probably changed from this operation.
                //
                var bRetrieved = madeEasy.retrieve_account(Server, strMyNymID, MyAcct, true) //bForceDownload defaults to false.
                
                OT_API_Output(0, "\n\nServer response ("+strAttempt+"): SUCCESS processing/accepting entire inbox!\n")
                OT_API_Output(0, (bRetrieved ? "Success" : "Failed") + " retrieving intermediary files for account.\n")
            }
            
            // ***************************************************************
            //
            // Success!
            //
            return nInterpretReply  
            
        } // VerifyIntVal (nCount) && nCount > 0     
        
        OT_API_Output(0, "(The inbox is empty.)\n\n")
    }
    
    0
}



def main_accept_inbox()
{
    if (VerifyExists("Server") && VerifyExists("MyAcct"))
    {	
        return accept_entire_inbox()
    } 
    
    return -1
}













def main_check_user()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    
    // Just to show how easy it is now, let's try a "check_user" message.
    // (It sends a NymID to the server, and downloads that Nym's public key.)
    
    
    if (VerifyExists("Server") && VerifyExists("MyNym") && VerifyExists("HisNym"))
    {
        // Send the request.
        //
        var strResponse	= ""
        
        strResponse = madeEasy.check_user(Server, MyNym, HisNym)	// Send the 'check_user' message to the server.
        
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        
        // -1 is error, 
        //  0 is reply received: failure 
        //  1 is reply received: success
        //
        if (1 == VerifyMessageSuccess(strResponse))
        {
            OT_API_Output(0, "\n\nSuccess in check_user! Server response:\n\n");
            print(strResponse) // stdout
            OT_API_Output(0, "\n\n") //stderr
            return 1
        }
        else
        {
            OT_API_Output(0, "\n\ncheck_user: Failed.\n\n");
        }
    }
    
    // Done
    -1
}













def download_acct_files()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    
    // ---------------------------------------------
    
    var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
    
    if (!VerifyStringVal(strMyNymID))
    {
        OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
        return (-1)
    }
    // ----------------------------------------------
    
    // Download all the intermediary files (account balance, inbox, outbox, etc)
    // since they have probably changed from this operation.
    //
    var bRetrieved = madeEasy.retrieve_account(Server, strMyNymID, MyAcct, true) //bForceDownload defaults to false.
    
    OT_API_Output(0, "\n\n" + (bRetrieved ? "SUCCESS" : "FAILED") + " retrieving intermediary files for account: " + MyAcct + "\n\n")
    
    return bRetrieved ? 1 : -1;
}


def main_dl_acct_files()
{
    var strUsage = "Usage:  refreshacct --server SERVER_ID --myacct YOUR_ACCT_ID\n\n"
    
    OT_API_Output(0, strUsage)
    
    if (VerifyExists("Server") && VerifyExists("MyAcct"))
    {	
        return download_acct_files()
    } 
    
    return -1
}


def main_refresh_all()
{
    var strUsage = "Usage:  refresh --server SERVER_ID --mynym YOUR_NYM_ID --myacct YOUR_ACCT_ID\n\n"
    
    OT_API_Output(0, strUsage)
    
    if (VerifyExists("Server") && VerifyExists("MyNym") && VerifyExists("MyAcct"))
    {	
        var nSuccess = main_refresh_nym()   // <=======
        
        if ((-1) == nSuccess)
        {
            return (-1)
        }
        
        return main_dl_acct_files()  // <=======
    } 
    
    return -1
}










def details_download_contract(strContractID) : strContractID.is_type(string_type)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    
    // ---------------------------------------------
    
    // Download all the intermediary files (account balance, inbox, outbox, etc)
    // since they have probably changed from this operation.
    //
    var strRetrieved   = madeEasy.retrieve_contract(Server, MyNym, strContractID)
    var nRetrieved     = VerifyMessageSuccess(strRetrieved)
    
    var strSuccess = "ERROR"
    
    if (1 == nRetrieved)
    {   strSuccess = "SUCCESS" }
    else if (0 == nRetrieved)
    {   strSuccess = "FAILED" }
    
    OT_API_Output(0, "\n\n " + strSuccess + " retrieving contract: "+strContractID+"\n\n")
    
    return (1 == nRetrieved) ? 1 : -1;
}


def main_download_contract()
{
    var strUsage = concat("\n\nUsage:  getcontract --server SERVER_ID --mynym YOUR_NYM_ID \n",
                          "                    --args \"contract_id CONTRACT_ID_HERE\"\n\n")
    OT_API_Output(0, strUsage)
    
    var strContractID = ""
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {	
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args"))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "contract_id CvHGtfOOKzQKL5hFL7J4iF5yAodVKhS1rxPzME5R9XA"
            //
            var strNewContractID = OT_CLI_GetValueByKey( Args, "contract_id" ) 
            
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewContractID))
            {    strContractID = strNewContractID }
            else
            {
                OT_API_Output(0, "\n\nMissing --args \"contract_id CONTRACT_ID_HERE\"\n\n")
                return (-1)
            }
            
            return details_download_contract(strContractID)
        }
        // ------------------------------------
    } 
    
    return -1
}












def main_verify_last_receipt()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    
    var madeEasy	= OT_ME()
    // ------------------------------
    // SHOW INBOX
    // 
    // Load an asset account's inbox from local storage and display it on the screen.
    //
    
    if (VerifyExists("Server") && VerifyExists("MyAcct"))
    {	
        // ---------------------------------------------
        // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
        //
        var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
        
        if (!VerifyStringVal(strMyNymID))
        {
            OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
            return (-1)
        }
        // ***************************************************************
        
        var bSuccess = OT_API_VerifyAccountReceipt(Server, strMyNymID, MyAcct);
        
        if (!bSuccess)
        {
            OT_API_Output(0, "\n\n OT_API_VerifyAccountReceipt: Failed. Try using refreshacct and then try verifying again.\n\n")
            return -1
        }
        else	// Success!
        {        
            OT_API_Output(0, "\n\nVerify receipt:  success!\n\n") // stderr
            return 1
        }
    }
    
    // Done!
    -1
}




















def main_register_nym()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // --------------------------------------------------------------------
    
    var strUsage = concat("\n\nUsage: register_nym.ot --server SERVER_ID --mynym NYM_ID\n\n",
                          "(If you don't have a NymID, then use create_nym.ot first.)\n\n")
    
    OT_API_Output(0, strUsage)
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {        
        var strResponse = madeEasy.register_nym(Server, MyNym)
        var nSuccess    = VerifyMessageSuccess(strResponse)
        
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        //
        // -1 is error, 
        //  0 is reply received: failure 
        //  1 is reply received: success
        //
        switch(nSuccess)
        {
            case (1)
            {
                var MsgUtil	= Utility()
                
                //	4. Use the getRequest command, thus insuring that the request number is in sync. 
                //
                if (1 != MsgUtil.getRequestNumber(Server, MyNym)) 
                {
                    OT_API_Output(0, "\n Succeeded in register_nym, but strange: then failed calling getRequest, to sync the request number. (Finished.)\n")
                }
                else // If it returns 1, we know for sure that the request number is in sync.
                {
                    OT_API_Output(0, "\n\n Server response:\n\n");
                    print(strResponse) // stdout
                    OT_API_Output(0, "\n\n SUCCESS in register_nym!\n(Also, success syncronizing the request number.)\n\n")
                }
                break
            }
            case (0)
            {
                OT_API_Output(0, "\n\n FAILURE in register_nym! Server response:\n\n");
                print(strResponse) // stdout
                break
            }
            default
            {
                OT_API_Output(0, "\n\nError in register_nym!\n")
                
                if (VerifyStringVal(strResponse))
                {
                    OT_API_Output(0, "Server response:\n\n");
                    print(strResponse) // stdout
                }
                break
            }
        }
        OT_API_Output(0, "\n\n") //stderr
        
        return nSuccess
    }
    
    return -1
}








def main_refresh_nym()
{
    // --------------------------------------------------------------------
    var MsgUtil	= Utility()
    // --------------------------------------------------------------------
    
    var strUsage = concat("\n\nUsage: refreshnym --server SERVER_ID --mynym NYM_ID\n\n",
                          "(If you don't have a NymID, then use the newnym command first.)\n\n")
    
    OT_API_Output(0, strUsage)
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {        
        if (1 != MsgUtil.getRequestNumber(Server, MyNym)) 
        {
            OT_API_Output(0, "\n Failed calling getRequest, to sync the request number. (Finished.)\n")
            return (-1)
        }
        else // If it returns 1, we know for sure that the request number is in sync.
        {
            OT_API_Output(0, "\n\n SUCCESS syncronizing the request number.\n")
        }
        // -------------------------------------------------------
        
        var bWasMsgSent    = OTBool(false)
        var bForceDownload = true
        
        var nGetAndProcessNymbox = MsgUtil.getAndProcessNymbox_4(Server, MyNym, bWasMsgSent, bForceDownload)
        
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        //
        // -1 is error, 
        //  0 is reply received: failure 
        //  1 is reply received: success
        //
        switch(nGetAndProcessNymbox)
        {
            case (1)
            {
                OT_API_Output(0, "\n\n SUCCESS in refresh nym!\n")
                break
            }
            case (0)
            {
                if (bWasMsgSent.getBooleanValue()) // the message was sent, and the server replied "failure".
                {
                    OT_API_Output(0, "\n\n FAILURE in refresh nym!\n")
                }
                else // the message wasn't sent; the 0 in this case means "nymbox was empty."
                {
                    OT_API_Output(0, "\n\n Success in refresh nym! (Skipped processing Nymbox, since it's empty.)\n")
                    return 0
                }
                break
            }
            default
            {
                OT_API_Output(0, "\n\nError in refresh nym! nGetAndProcessNymbox: "+nGetAndProcessNymbox.to_string()+"\n")
                break
            }
        }
        OT_API_Output(0, "\n") //stderr
        
        return nGetAndProcessNymbox
    }
    
    return -1
}





// --------------------------------------------------------------
// GET BOX RECEIPT          Note: from ot_made_easy.ot
// Note: nBoxType is 0 for Nymbox, 1 for Inbox, and 2 for Outbox.
// Also, if nBoxType is 0 (nymbox) then you have to pass the NymID in the ACCT_ID 
// argument, as well as the NYM_ID argument (you have to pass it twice...)
// Otherwise for inbox/outbox, pass the actual ACCT_ID there as normal.
//
//def OT_ME::get_box_receipt(SERVER_ID, NYM_ID, ACCT_ID, nBoxType, STR_TRANS_NUM) 
//{
//    var ot_Msg := OTAPI_Func()
//    // -------------------------
//    var theRequest := OTAPI_Func(ot_Msg.GET_BOX_RECEIPT, SERVER_ID, NYM_ID, ACCT_ID, nBoxType, STR_TRANS_NUM)
//    var	strResponse = theRequest.SendRequest(theRequest, "GET_BOX_RECEIPT")
//    
//    return strResponse;
//}


def details_download_box_receipt(strID, nBoxType)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ---------------------------------------------
    
    var strMyNymID  = MyNym
    var strAcctID
    
    // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
    //
    if (0 == nBoxType)  // It's a Nymbox he's after. (Use NymID for the AcctID, in this case.)
    {
        strAcctID = MyNym
    }
    else // it's an inbox or outbox (needs an acct ID.)
    {
        if (!VerifyExists("MyAcct", false))
        {
            OT_API_Output(0, "Failure: Unable to find MyAcct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
            return (-1)
        }
        else
        {
            strAcctID = MyAcct
            
            // (After this point, MyNym contains the NymID, and strMyNymID contains
            // the NymID that corresponds to MyAcct -- they may not necessarily be
            // the same Nym...)
            //
            strMyNymID = OT_API_GetAccountWallet_NymID(strAcctID)
            
            if (!VerifyStringVal(strMyNymID))
            {
                OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
                OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
                return (-1)
            }
            // -------------------------------------
            if (strMyNymID != MyNym)
            {
                OT_API_Output(0, "Failure: Found a NymID based on myacct, but MyNym is not the same ID.\n")
                OT_API_Output(0, "To avoid any confusion, please be explicit with Nym ID:   --mynym NYM_ID \n\n")
                return (-1)
            }
        }
    }
    // ***************************************************************
    
    // HERE, WE SEND THE 'GET BOX RECEIPT' REQUEST TO THE SERVER
    //
    var strResponse = madeEasy.get_box_receipt(Server, strMyNymID, strAcctID, nBoxType, strID) 
//  var strAttempt  = "get_box_receipt" // unused here.
    
    // ***************************************************************
    // NOTICE: No need here to deal with retries, timeouts, request number,
    // syncing transaction number, download / process nymbox, etc! It's all
    // handled at a lower level!  
    // 
    // Instead, simply check for success or failure:
    //
    var nInterpretReply = VerifyMessageSuccess(strResponse)
    
    if (!VerifyIntVal(nInterpretReply) || (1 != nInterpretReply))
    {
        OT_API_Output(0, "get_box_receipt: Failed. nInterpretReply is: " + nInterpretReply.to_string() + "\n");
        OT_API_Output(0, "get_box_receipt: Perhaps that receipt is no longer in the box?\n");
    }
    else
    {
        OT_API_Output(0, "Success in get_box_receipt! Server response:\n\n")
        print(strResponse)
        OT_API_Output(0, "\n\n")
        return 1
    }    
    // ***************************************************************
    //
    // Return status to caller.
    //
    return nInterpretReply  
}




def main_get_box_receipt()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // --------------------------------------------------------------------
    var strUsage = concat("\n\nUsage: getboxreceipt --server SERVER_ID --mynym NYM_ID\n\n",
                              "Also:    --args \"box_type BOX_TYPE_ID_HERE id TRANSACTION_ID_HERE\"\nBox types are 0 (Nymbox), 1 (Inbox), 2 (Outbox)\n\n")
    
    OT_API_Output(0, strUsage)
    
    var strID
    var nBoxType = 1  // Inbox by default.
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {        
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args"))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "box_type 0 id 98"
            //
            var strNewID   = OT_CLI_GetValueByKey( Args, "id" ) 
            var strNewType = OT_CLI_GetValueByKey( Args, "box_type" ) 
            
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewID))
            {    strID = strNewID }
            else
            {
                OT_API_Output(0, "\n\nMissing --args \"id TRANSACTION_ID_HERE\"\n\n")
                return (-1)
            }
            // **************************************************************
            //
            if (VerifyStringVal(strNewType))
            {    nBoxType = strNewType.to_int() }
            // ----------------------------------------------
            if (!VerifyIntVal(nBoxType) || (nBoxType < 0) || (nBoxType > 2))
            {
                OT_API_Output(0, "\n\n box_type cannot be <0 or >2. Try:  --args \"box_type 1\"\nBox types are 0 (Nymbox), 1 (Inbox), 2 (Outbox)\n\n")
                return (-1)
            }
            // ------------------------------------
            // If Inbox or Outbox, make sure we have an acct...
            //
            if ((nBoxType != 0) && !VerifyExists("MyAcct", false))
            {
                OT_API_Output(0, "\n\n For inbox (1) or outbox (2) box types, need an account ID.\nMissing: --myacct ACCT_ID_HERE \n\n")
                return (-1)
            }
            // ------------------------------------

            return details_download_box_receipt(strID, nBoxType)
        }
        // ------------------------------------
    }
    
    return -1
}










// ------------------------------
//
// WITHDRAW CASH 
//
// (from asset account on server to cash purse on client.)
//
def details_withdraw_cash(strAmount)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()

    // ---------------------------------------------
    // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
    //
    var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
    
    if (!VerifyStringVal(strMyNymID))
    {
        OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
        return (-1)
    }
    // ---------------------------------------------
    // MAKE SURE WE HAVE THE RIGHT ASSET CONTRACT    
    //
    var strAssetTypeID = OT_API_GetAccountWallet_AssetTypeID(MyAcct)
    
    if (!VerifyStringVal(strAssetTypeID))
    {
        OT_API_Output(0, "Failure: Unable to find Asset Type ID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the asset type based on the account.\n\n")
        return (-1)
    }
    // ---------------------------------------------
    var assetContract = OT_API_LoadAssetContract(strAssetTypeID)
    
    if (!VerifyStringVal(assetContract)) 
    {
        var strResponse = madeEasy.retrieve_contract(Server, strMyNymID, strAssetTypeID) 

        if (1 != VerifyMessageSuccess(strResponse))
        {
            OT_API_Output(0, "details_withdraw_cash: Unable to retrieve contract for IDs: \n")
            OT_API_Output(0, "  Server ID: " + Server  + "\n")
            OT_API_Output(0, "   Asset ID: " + strAssetTypeID + "\n")
            return (-1)			
        }
        // ----------------------------------------
        assetContract = OT_API_LoadAssetContract(strAssetTypeID)
        
        if (!VerifyStringVal(assetContract))
        {
            OT_API_Output(0, "Failure: Unable to load Asset contract even after retrieving it.\n")
            return (-1)
        }
    }
    // By this point, we KNOW the appropriate asset contract is available.
    // ---------------------------------------- 
    //
    // HERE, WE MAKE SURE WE HAVE THE PROPER MINT...
    //
    var strMint = madeEasy.load_or_retrieve_mint(Server, strMyNymID, strAssetTypeID) 

    if (!VerifyStringVal(strMint))
    {
        OT_API_Output(0, "Failure: Unable to load or retrieve necessary mint file for withdrawal.\n")
        return (-1)
    }
    // By this point, we know we can successfully load both: 
    // 1. the proper asset contract.
    // 2. the proper (unexpired) mint file.
    // ***************************************************************
    // HERE, WE SEND THE WITHDRAWAL REQUEST TO THE SERVER
    //
    var strResponse = madeEasy.withdraw_cash(Server, strMyNymID, MyAcct, strAmount) 
    var strAttempt  = "withdraw_cash"
    // ***************************************************************
    
    // HERE, WE INTERPRET THE SERVER REPLY, WHETHER SUCCESS, FAIL, OR ERROR...
    
    var nInterpretReply = InterpretTransactionMsgReply(Server, strMyNymID, MyAcct, strAttempt, strResponse)
    
    if (1 == nInterpretReply)
    {    
        // Download all the intermediary files (account balance, inbox, outbox, etc)
        // since they have probably changed from this operation.
        //
        var bRetrieved = madeEasy.retrieve_account(Server, strMyNymID, MyAcct) //bForceDownload defaults to false.
        
        OT_API_Output(0, "\n\nServer response ("+strAttempt+"): SUCCESS withdrawing cash! (From account on server to local purse.) \n")
        OT_API_Output(0, (bRetrieved ? "Success" : "Failed") + " retrieving intermediary files for account.\n")
    }
    
    // ***************************************************************
    //
    // Return status to caller.
    //
    return nInterpretReply  
}

// HERE, WE GET ALL THE ARGUMENTS TOGETHER,
// and then call the above function.
//
def main_withdraw_cash()
{
    var strUsage = concat("\n\n  USAGE: withdraw --myacct YOUR_ASSET_ACCT --server SERVER_ID \n\n",
                           "Also NECESSARY: --args \"amount PUT_AMOUNT_HERE\"\n")

    OT_API_Output(0, strUsage)
    // ------------------------------------        

    if (VerifyExists("Server") && VerifyExists("MyAcct"))
    {	
        // strAmount
        //
        var strAmount    = "0" // must be >= 1
        // ------------------------------------        
        var strDefaultAmount  = "1"  // must be >= 1
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false)) // displayErrorMsg=false
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "amount 1"
            //
            var strNewAmount = OT_CLI_GetValueByKey( Args, "amount"    ) // any integer value
            
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewAmount))
            {    strAmount = strNewAmount }
        }            
        // ------------------------------------
        // If the withdrawal parameters aren't provided, then we
        // ask the user to supply them at the command line.
        //
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {
            OT_API_Output(0, "Enter the amount as integer["+strDefaultAmount+"]: ")
            strAmount        = OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {    strAmount = strDefaultAmount }
        // ----------------------------------------------    

        return details_withdraw_cash(strAmount)
    }
    
    return -1
}

// -----------------------











/*
 pScript->chai.add(fun(&OTAPI_Wrap::Wallet_GetNymIDFromPartial),     "OT_API_Wallet_GetNymIDFromPartial");
 pScript->chai.add(fun(&OTAPI_Wrap::Wallet_GetServerIDFromPartial),  "OT_API_Wallet_GetServerIDFromPartial");
 pScript->chai.add(fun(&OTAPI_Wrap::Wallet_GetAssetIDFromPartial),   "OT_API_Wallet_GetAssetIDFromPartial");
 pScript->chai.add(fun(&OTAPI_Wrap::Wallet_GetAccountIDFromPartial), "OT_API_Wallet_GetAccountIDFromPartial");

 */


// ------------------------------
//
// WITHDRAW VOUCHER 
//
//(From asset account into instrument form, 
// like a cashier's cheque.)
//


def details_withdraw_voucher(strAmount, strMemo)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    
    // ---------------------------------------------
    // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
    //
    var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
    
    if (!VerifyStringVal(strMyNymID))
    {
        OT_API_Output(0, "\n\nFailure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
        return (-1)
    }
    // ---------------------------------------------

    var strHisNymID
    
    if (VerifyExists("HisNym")) // This ID is already validated in the C++ code (in this case.)
    {
        strHisNymID = HisNym
    }
    else
    {
        OT_API_Output(0, "Optionally, enter recipient NymID (abbreviations accepted): ")
        var strHisPartialNymID = OT_CLI_ReadLine()
        
        if (VerifyStringVal(strHisPartialNymID)) // If the user typed something...
        {
            strHisNymID = OT_API_Wallet_GetNymIDFromPartial(strHisPartialNymID) // Try to find the associated ID...
            
            if (!VerifyStringVal(strHisNymID)) // But if it returned NULL, failure (return.)
            {
                OT_API_Output(0, "\n\nFailure: Unable to find HisNym (Recipient) in your wallet. Use: --hisnym NYM_ID\n")
                return (-1)
            }
        }
        // ------------------------
        else // The user just hit "enter" so we'll default the recipient Nym to the user himself.
        {
            strHisNymID = MyNym
        }
        // ------------------------
    }

    // ***************************************************************
    
    // HERE, WE SEND THE VOUCHER WITHDRAWAL REQUEST TO THE SERVER
    //
    var strResponse = madeEasy.withdraw_voucher(Server, strMyNymID, MyAcct, strHisNymID, strMemo, strAmount)
    var strAttempt  = "withdraw_voucher"
    //  static int withdrawVoucher(const std::string SERVER_ID,
    //                             const std::string USER_ID,
    //                             const std::string ACCT_ID,
    //                             const std::string RECIPIENT_USER_ID,
    //                             const std::string CHEQUE_MEMO,
    //                             const std::string AMOUNT);
    // ***************************************************************
    
    // HERE, WE INTERPRET THE SERVER REPLY, WHETHER SUCCESS, FAIL, OR ERROR...
    
    var nInterpretReply = InterpretTransactionMsgReply(Server, strMyNymID, MyAcct, strAttempt, strResponse)
    
    if (1 == nInterpretReply) // Success!
    {    
        // ---------------------------------------------------------
        var strLedger = OT_API_Message_GetLedger(strResponse)
        
        if (!VerifyStringVal(strLedger)) 
        {
            OT_API_Output(0, "\n\n details_withdraw_voucher: Error: strLedger is null, returned by OT_API_Message_GetLedger.\n")
            return (-1)
        }
        // ---------------------------------------------------------
        var strTransReply = OT_API_Ledger_GetTransactionByIndex(Server, strMyNymID, MyAcct, strLedger, 0) // index 0.
        
        if (!VerifyStringVal(strTransReply)) 
        {
            OT_API_Output(0, concat("details_withdraw_voucher: Error: strTransReply is unexpectedly null, returned by ", 
                                    "OT_API_Ledger_GetTransactionByIndex, argument passed, index 0 and ledger:\n\n") + strLedger + "\n\n")
            return (-1)
        }
        // ---------------------------------------------------------

        var strOutput = OT_API_Transaction_GetVoucher(Server, strMyNymID, MyAcct, strTransReply)
        
        if (!VerifyStringVal(strOutput)) 
        {
            OT_API_Output(0, concat("details_withdraw_voucher: Error: Voucher is unexpectedly null, returned by ", 
                                    "OT_API_Transaction_GetVoucher with strTransReply set to:\n\n") + strTransReply + "\n\n")
            return (-1)
        }
        // ---------------------------------------------------------        
        // Download all the intermediary files (account balance, inbox, outbox, etc)
        // since they have probably changed from this operation.
        //
        var bRetrieved = madeEasy.retrieve_account(Server, strMyNymID, MyAcct, true) //bForceDownload defaults to false.
        OT_API_Output(0, (bRetrieved ? "Success" : "Failed") + " retrieving intermediary files for account.\n")
        // ---------------------------------------------------------
        OT_API_Output(0, "details_withdraw_voucher: Voucher returned by OT_API_Transaction_GetVoucher:\n\n") // stderr
        print(strOutput) // stdout
        OT_API_Output(0, "\n\n") // stderr.

        OT_API_Output(0, "\n\nServer response ("+strAttempt+"): SUCCESS withdrawing voucher (cashier's cheque)!\n")
        
        return 1
    }
    
    // ***************************************************************
    //
    // Return status to caller.
    //
    return nInterpretReply  
}

//  static int withdrawVoucher(const std::string SERVER_ID,
//                             const std::string USER_ID,
//                             const std::string ACCT_ID,
//                             const std::string RECIPIENT_USER_ID,
//                             const std::string CHEQUE_MEMO,
//                             const std::string AMOUNT);

// HERE, WE GET ALL THE ARGUMENTS TOGETHER,
// and then call the above function.
//
def main_withdraw_voucher()
{
    var strUsage1 = concat("\n\n  USAGE: voucher --myacct YOUR_ASSET_ACCT --hisnym RECIPIENT_NYM_ID\n\n",
                           "Also NECESSARY: --args \"amount PUT_AMOUNT_HERE\"\n")
    var strUsage = concat(strUsage1,
                          "And OPTIONALLY: --args \"memo \\\"Just a memo for the voucher cheque.\\\"\"\n\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server") && VerifyExists("MyAcct"))
    {	
        // strAmount and strNote...
        //
        var strAmount    = "0" // must ultimately be >= 1
        var strNote      = ""  // can be blank
        // ------------------------------------        
        var strDefaultAmount  = "1"  // must be >= 1
        var strDefaultNote    = "(blank memo field)"   // can be blank
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "amount 1"
            // EXAMPLE:  --args "amount 15 note \"Just a memo for the voucher cheque.\""
            //
            var strNewAmount = OT_CLI_GetValueByKey( Args, "amount"    ) // any integer value
            var strNewNote   = OT_CLI_GetValueByKey( Args, "memo"  )     // optional memo field
            
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewAmount))
            {    strAmount = strNewAmount }
            if (VerifyStringVal(strNewNote))
            {    strNote = strNewNote }
        }            
        // ------------------------------------
        // If the transfer parameters aren't provided, then we
        // ask the user to supply them at the command line.
        //
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {
            OT_API_Output(0, "Enter the amount as integer["+strDefaultAmount+"]: ")
            strAmount        = OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strNote))
        {
            OT_API_Output(0, "Optionally, enter a memo on a single line["+strDefaultNote+"]: ")
            strNote	= OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {    strAmount = strDefaultAmount }
        if (!VerifyStringVal(strNote))
        {    strNote = strDefaultNote }
        // ----------------------------------------------    
                
        return details_withdraw_voucher(strAmount, strNote)
    }
    
    return -1
}

// -----------------------








def loadMarketList(serverID) 
{
    var vUndefRetVal
    var marketList
    var storable
    
    if (OTDB_Exists("markets", serverID, "market_data.bin", "")) 
    {
        OT_API_Output(1, "Markets file exists...Querying list of markets...\n")
        storable := OTDB_QueryObject(STORED_OBJ_MARKET_LIST, "markets", serverID, "market_data.bin", "")
        
        if (!VerifyStorable(storable, "OTDB_Storable"))
        {
            OT_API_Output(0, "Failed to verify storable object. Probably doesn't exist.\n")
            return vUndefRetVal
        }
        // ------------------------------------------
        OT_API_Output(1, "QueryObject worked. Now dynamic casting from storable to marketlist...\n")
        marketList := OTDB_CAST_MARKET_LIST(storable)
        
        if (!VerifyStorable(marketList, "OTDB_MarketList"))
        {
            OT_API_Output(0, "Unable to dynamic cast a storable to a marketlist.\n")
            return vUndefRetVal
        }
        // ------------------------------------------
        
        return marketList  // success.
    }
    else
    {
        OT_API_Output(0, "The market list file doesn't exist.\n")
        return vUndefRetVal
    }
    // This WAS a "load or create" sort of function, but I commented out the "create" part because
    // you will literally NEVER need to create this list.
    //
//    else 
//    {
//        OT_API_Output(0, "Didn't exist. Creating market list object...\n")
//        storable := OTDB_CreateObject(STORED_OBJ_MARKET_LIST);
//        
//        if (!VerifyStorable(storable))
//        {
//            OT_API_Output(0, "Failed trying to create market list object!\n")
//            return storable  // containing null or undef
//        }
//        
//        OT_API_Output(0, "CreateObject worked. Now dynamic casting from storable to marketlist...\n")
//        marketList := OTDB_CAST_MARKET_LIST(storable)
//        
//        if (!VerifyStorable(marketList))
//        {
//            OT_API_Output(0, "Failed to dynamic cast from storable to marketlist.\n")
//        }
//    }
    
    return vUndefRetVal
}




def main_show_market_list()
{
    if (VerifyExists("Server"))
    {
        var marketList := loadMarketList(Server)
        
        if (!VerifyStorable(marketList, "OTDB_MarketList"))
        {
            OT_API_Output(0, "Unable to load up marketlist from local storage.\n")
            return (-1)
        }
        // ----------------------------------
        
        // LOOP THROUGH THE MARKETS AND PRINT THEM OUT.
        
        var nCount = marketList.GetMarketDataCount()
        var nTemp  = nCount  // this way, nTemp is initialized as a size_t.
        
        if (!VerifyIntVal(nCount))
        {
            OT_API_Output(0, "Loaded the market list, but GetMarketDataCount returns an invalid result. (Failure.)\n")
        }
        else if (!(nCount > 0))
        {
            OT_API_Output(0, "Loaded the market list, but GetMarketDataCount says there aren't any markets in the list. (Returning.)\n")
        }
        else
        {
//          print("\nIndex\tScale\tMarket\tAsset\tCurrency")
            OT_API_Output(0, "\nIndex\tScale\tMarket\t\t\t\t\t\tAsset\t\t\t\t\t\tCurrency\n")
            
            for (var nIndex = 0; nIndex < nCount; ++nIndex)
            {
                nTemp = nIndex // convert nIndex from int to size_t
                var marketData := marketList.GetMarketData(nTemp) // can't pass an int here--it expects size_t. (It'll crash..)
                
                if (!VerifyStorable(marketData, "OTDB_MarketData"))
                {
                    OT_API_Output(0, "Unable to reference marketData on marketList, at index: " + nIndex.to_string() + "\n")
                    return (-1)
                }
                
                // OUTPUT THE MARKET DATA...   
                //
                print(nIndex.to_string() + "\t" + marketData.scale + "\tM " + marketData.market_id + "\tA " + marketData.asset_type_id + "\tC " + marketData.currency_type_id)
            }
        }
        // ------------------------------------------------------
        
        return 1
    }
    
    (-1)
}


def main_get_market_list()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // --------------------------------------------------------------------
    var strUsage = "\n\n USAGE: getmarketlist --server SERVER_ID --mynym YOUR_NYM_ID\n\n"
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {
        // ------------------------------
        // Send the request.
        //
        var strResponse	= madeEasy.get_market_list(Server, MyNym)
        var strAttempt  = "get_market_list"
        // ----------------------------------------------
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        
        // ***************************************************************
        
        var nInterpretReply = VerifyMessageSuccess(strResponse)
        
        if (1 == nInterpretReply)
        {    
            OT_API_Output(0, "Server response ("+strAttempt+"): SUCCESS getting market list.\n\n") 
            
            main_show_market_list()  // if it was successful, then we display the list on the screen.
        }
        
        return nInterpretReply
    }
    
    return (-1)
}











def loadMarketOffers(serverID, marketID) 
{
    var offerList
    var storable
    var vUndefRetVal // for returning "null"
    
    if (OTDB_Exists("markets", serverID, "offers", marketID + ".bin")) 
    {
        OT_API_Output(1, "Offers file exists... Querying file for market offers...\n")
        storable := OTDB_QueryObject(STORED_OBJ_OFFER_LIST_MARKET, "markets", serverID, "offers", marketID + ".bin")
        
        if (!VerifyStorable(storable, "OTDB_Storable"))
        {
            OT_API_Output(0, "Unable to verify storable object. Probably doesn't exist.\n")
            return vUndefRetVal // containing null or undef
        }
        // -----------------------------------------
        OT_API_Output(1, "QueryObject worked. Now dynamic casting from storable to a (market) offerList...\n")
        offerList := OTDB_CAST_OFFER_LIST_MARKET(storable)
        
        if (!VerifyStorable(offerList, "OTDB_OfferListMarket"))
        {
            OT_API_Output(0, "Unable to dynamic cast a storable to a (market) offerList.\n")
            return vUndefRetVal // containing null or undef
        }
    }
    
    return offerList  // possibly containing the offerList (if success), or possibly containing a null/undef value (if failure.)
}



def details_show_market_offers(strServerID, strMarketID)
{
    var offerList := loadMarketOffers(strServerID, strMarketID)
    
    if (!VerifyStorable(offerList, "OTDB_OfferListMarket"))
    {
        OT_API_Output(0, "Unable to load up a (market) offerList from local storage.\n")
        return (-1)
    }
    // ----------------------------------
    // LOOP THROUGH THE BIDS AND PRINT THEM OUT.
    var nBidCount = offerList.GetBidDataCount()  // size_t
    var nTemp     = nBidCount // just so it's created as size_t
    
    if (VerifyIntVal(nBidCount) && (nBidCount > 0))
    {
        OT_API_Output(0, "\n** BIDS **\n\nIndex\tTrans#\tPrice\tAvailable\n")
        
        for (var nIndex = 0; nIndex < nBidCount; ++nIndex)
        {
            nTemp = nIndex
            var offerData := offerList.GetBidData(nTemp)
            
            if (!VerifyStorable(offerData, "OTDB_BidData"))
            {
                OT_API_Output(0, "Unable to reference bidData on offerList, at index: " + nIndex.to_string() + "\n")
                return (-1)
            }
            
            // OUTPUT THE BID OFFER DATA...   
            //
            print(nIndex.to_string() + "\t" + offerData.transaction_id + "\t" + offerData.price_per_scale + "\t" + offerData.available_assets)
        }
    }
    // ----------------------------------
    // LOOP THROUGH THE ASKS AND PRINT THEM OUT.
    var nAskCount = offerList.GetAskDataCount()
    
    if (VerifyIntVal(nAskCount) && (nAskCount > 0))
    {
        OT_API_Output(0, "\n** ASKS **\n\nIndex\tTrans#\tPrice\tAvailable\n")
        
        for (var nIndex = 0; nIndex < nAskCount; ++nIndex)
        {
            nTemp = nIndex
            var offerData := offerList.GetAskData(nTemp)
            
            if (!VerifyStorable(offerData, "OTDB_AskData"))
            {
                OT_API_Output(0, "Unable to reference askData on offerList, at index: " + nIndex.to_string() + "\n")
                return (-1)
            }
            
            // OUTPUT THE ASK OFFER DATA...   
            //
            print(nIndex.to_string() + "\t" + offerData.transaction_id + "\t" + offerData.price_per_scale + "\t" + offerData.available_assets)
        }
    }
    // ------------------------------------------------------
    
    (1)
}




def impl_show_market_offers(strMarket)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // --------------------------------------------------------------------
    var strUsage1 = "\n\n USAGE: showoffers --server SERVER_ID --mynym YOUR_NYM_ID\n"
    var strUsage = concat(strUsage1, "Also: --args \"market MARKET_ID\"\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server"))
    {
        // ------------------------------------        
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (!VerifyStringVal(strMarket) && VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "market MARKET_ID"
            //
            var strNewMarket = OT_CLI_GetValueByKey( Args, "market" ) // the market ID
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewMarket))
            {    strMarket = strNewMarket }
        }            
        // ------------------------------------
        // If the transfer parameters aren't provided, then we
        // ask the user to supply them at the command line.
        //
        if (!VerifyStringVal(strMarket))
        {
            OT_API_Output(0, "Enter the market ID: ")
            strMarket        = OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strMarket))
        {
            return -1
        }
        // ----------------------------------------------  
        
        return details_show_market_offers(Server, strMarket)
    }
    
    return (-1)
}



def main_show_market_offers()
{
    var strMarket
    
    return impl_show_market_offers(strMarket)
}




def main_get_market_offers()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // --------------------------------------------------------------------
    var strUsage1 = "\n\n USAGE: getoffers --server SERVER_ID --mynym YOUR_NYM_ID\n"
    var strUsage = concat(strUsage1, "Also: --args \"market MARKET_ID depth MAX_DEPTH\"\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {
        var strMarket    = ""  // must ultimately be an ID.
        var strDepth     = ""  // can be blank
        // ------------------------------------        
        var strDefaultDepth   = "50"   // can be blank
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "market MARKET_ID depth 50"
            //
            var strNewMarket = OT_CLI_GetValueByKey( Args, "market"    ) // the market ID
            var strNewDepth  = OT_CLI_GetValueByKey( Args, "depth"  )    // how many offers should we retrieve?
            
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewMarket))
            {    strMarket = strNewMarket }
            if (VerifyStringVal(strNewDepth))
            {    strDepth = strNewDepth }
        }            
        // ------------------------------------
        // If the transfer parameters aren't provided, then we
        // ask the user to supply them at the command line.
        //
        if (!VerifyStringVal(strMarket))
        {
            OT_API_Output(0, "Enter the market ID: ")
            strMarket        = OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strDepth))
        {
            OT_API_Output(0, "Optionally, enter a max depth on a single line["+strDepth+"]: ")
            strDepth	= OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strMarket))
        {    return -1  }
        if (!VerifyStringVal(strDepth))
        {    strDepth = strDefaultDepth }
        // ----------------------------------------------    
        // Send the request.
        //
        var strResponse	= madeEasy.get_market_offers(Server, MyNym, strMarket, strDepth)
        var strAttempt  = "get_market_offers"
        // ----------------------------------------------
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        
        // ***************************************************************
        
        var nInterpretReply = VerifyMessageSuccess(strResponse)
        
        if (1 == nInterpretReply)
        {    
            OT_API_Output(0, "Server response ("+strAttempt+"): SUCCESS getting market offers.\n\n") 
            
            impl_show_market_offers(strMarket)  // if it was successful, then we display the list on the screen.
        }
        
        return nInterpretReply
    }
    
    return (-1)
}












/*
//      pScript->chai.add(fun(&OTDB::OfferDataNym::gui_label),          "gui_label");
        pScript->chai.add(fun(&OTDB::OfferDataNym::valid_from),         "valid_from");
        pScript->chai.add(fun(&OTDB::OfferDataNym::valid_to),           "valid_to");
        pScript->chai.add(fun(&OTDB::OfferDataNym::server_id),          "server_id");
        pScript->chai.add(fun(&OTDB::OfferDataNym::asset_type_id),      "asset_type_id");
        pScript->chai.add(fun(&OTDB::OfferDataNym::asset_acct_id),      "asset_acct_id");
        pScript->chai.add(fun(&OTDB::OfferDataNym::currency_type_id),   "currency_type_id");
        pScript->chai.add(fun(&OTDB::OfferDataNym::currency_acct_id),   "currency_acct_id");
        pScript->chai.add(fun(&OTDB::OfferDataNym::selling),            "selling");
        pScript->chai.add(fun(&OTDB::OfferDataNym::scale),              "scale");
        pScript->chai.add(fun(&OTDB::OfferDataNym::price_per_scale),    "price_per_scale");
        pScript->chai.add(fun(&OTDB::OfferDataNym::transaction_id),     "transaction_id");
        pScript->chai.add(fun(&OTDB::OfferDataNym::total_assets),       "total_assets");
        pScript->chai.add(fun(&OTDB::OfferDataNym::finished_so_far),    "finished_so_far");
        pScript->chai.add(fun(&OTDB::OfferDataNym::minimum_increment),  "minimum_increment");
        pScript->chai.add(fun(&OTDB::OfferDataNym::stop_sign),          "stop_sign");
        pScript->chai.add(fun(&OTDB::OfferDataNym::stop_price),         "stop_price");
        
        OT_CHAI_CONTAINER(OfferListNym, OfferDataNym); 
 */


def details_show_nym_offers(strServerID, strNymID)
{
    var strLocation = "details_show_nym_offers"
    
    var offerList := loadNymOffers(strServerID, strNymID)
    
    if (!VerifyStorable(offerList, "OTDB_OfferListNym"))
    {
        OT_API_Output(0, strLocation+": Unable to load up a (nym) offerList from local storage. Probably doesn't exist.\n")
        return (-1)
    }
    // ----------------------------------
    // LOOP THROUGH THE OFFERS and sort them into a map_of_maps, key is: scale-assetID-currencyID
    // the value for each key is a sub-map, with the key: transaction ID and value: the offer data itself.
    //
    var nCount = offerList.GetOfferDataNymCount() // size_t
    var nTemp  = nCount // so it's created as size_t
    
    if (VerifyIntVal(nCount) && (nCount > 0))
    {        
        var map_of_maps := convert_offerlist_to_maps(offerList)
        
        if (!VerifyType(map_of_maps, "Map"))
        {
            OT_API_Output(0, strLocation+": Unable to convert offer list to map of offers. Perhaps it's empty?\n")
            return (-1)
        }
        // -------------------------------------------        
        // output_nymoffer_data is called for each offer, for this nym,
        // as it iterates through the maps.
        //
        // iterate_nymoffers_maps takes a final parameter extra_vals (not seen here)
        // Other sections in the code which use iterate_nymoffers_maps might pass a value
        // here, or expect one to be returned through the same mechansim.
        //
        var nIterated = iterate_nymoffers_maps(map_of_maps, output_nymoffer_data) // low level. map_of_maps must be good. (assumed.)
        
        if ((-1) == nIterated)
        {
            OT_API_Output(0, strLocation+": Error trying to iterate nym's offers.\n")
            return (-1)
        }        
    }
    
    (1)
}



def main_show_nym_offers()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // --------------------------------------------------------------------
    var strUsage = "\n\n USAGE: showmyoffers --server SERVER_ID --mynym YOUR_NYM_ID\n\n"
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {        
        return details_show_nym_offers(Server, MyNym)
    }
    
    return (-1)
}



def details_get_nym_market_offers(strServerID, strNymID)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    
    var strResponse
    
    // --------------------------------------------------------------------
    if (VerifyStringVal(strServerID) && VerifyStringVal(strNymID))
    {
        // ----------------------------------------------    
        // Send the request.
        //
        strResponse	= madeEasy.get_nym_market_offers(strServerID, strNymID)
        // ----------------------------------------------
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        
        // ***************************************************************
    }
    
    return strResponse
}



def main_get_nym_market_offers()
{
    // --------------------------------------------------------------------
    var strUsage = "\n\n USAGE: getmyoffers --server SERVER_ID --mynym YOUR_NYM_ID\n"
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {        
        // ----------------------------------------------    
        // Send the request.
        //
        var strResponse = details_get_nym_market_offers(Server, MyNym)
        var strAttempt  = "get_nym_market_offers"
        // ----------------------------------------------
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        
        // ***************************************************************
        
        var nInterpretReply = VerifyMessageSuccess(strResponse)
        
        if (1 == nInterpretReply)
        {    
            OT_API_Output(0, "Server response ("+strAttempt+"): SUCCESS getting nym's market offers.\n\n") 
            
            main_show_nym_offers()  // if it was successful, then we display the list on the screen.
        }
        
        return nInterpretReply
    }
    
    return (-1)
}









// ------------------------------
//
// PAY DIVIDEND
//
// Just like withdraw voucher...except instead of withdrawing a single voucher to yourself,
// it removes the total dividend payout from your account, and then divides it up amongst the
// shareholders, sending them EACH a voucher cheque in the amount of strAmount * number of shares owned.
//
def details_pay_dividend(strAmount, strMemo)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    
    // ---------------------------------------------
    // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
    //
    var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
    
    if (!VerifyStringVal(strMyNymID))
    {
        OT_API_Output(0, "\n\nFailure: Unable to find Payer NymID based on myacct. Use: --myacct DIVIDEND_SOURCE_ACCT_ID\n")
        OT_API_Output(0, "The designated asset account (that the dividends will be paid out of) must be yours. OT will find the Nym based on that account.\n\n")
        return (-1)
    }
    // ---------------------------------------------

    var strHisPurse
    
    if (VerifyExists("HisPurse")) // This ID is already validated in the C++ code (in this case.)
    {
        strHisPurse = HisPurse
    }
    else
    {
        while(true)
        {
            OT_API_Output(0, "Enter the SHARES asset type ID (Nym must also be the issuer for these shares): ")
            var strHisPartialPurseID = OT_CLI_ReadLine()
            
            if (VerifyStringVal(strHisPartialPurseID)) // If the user typed something...
            {
                strHisPurse = OT_API_Wallet_GetAssetIDFromPartial(strHisPartialPurseID) // Try to find the associated ID...
                
                if (!VerifyStringVal(strHisPurse)) // But if it returned NULL, failure (return.)
                {
                    OT_API_Output(0, "\n\nFailure: Unable to find SHARES_ASSET_TYPE_ID in your wallet. Use: --hispurse SHARES_ASSET_TYPE_ID\n")
                    return (-1)
                }
                break
            }
        }
    }

    // ***************************************************************
    
    // HERE, WE SEND THE PAY DIVIDEND REQUEST TO THE SERVER
    //
    var strResponse = madeEasy.pay_dividend(Server, strMyNymID, MyAcct, strHisPurse, strMemo, strAmount)
    var strAttempt  = "pay_dividend"
    
//static int payDividend(const std::string SERVER_ID,
//                       const std::string ISSUER_USER_ID,
//                       const std::string DIVIDEND_FROM_ACCT_ID,
//                       const std::string SHARES_ASSET_TYPE_ID,
//                       const std::string DIVIDEND_MEMO,
//                       const std::string AMOUNT_PER_SHARE);
    // ***************************************************************
    
    // HERE, WE INTERPRET THE SERVER REPLY, WHETHER SUCCESS, FAIL, OR ERROR...
    
    var nInterpretReply = InterpretTransactionMsgReply(Server, strMyNymID, MyAcct, strAttempt, strResponse)
    
    if (1 == nInterpretReply) // Success!
    {    
        // ---------------------------------------------------------        
        // Download all the intermediary files (account balance, inbox, outbox, etc)
        // since they have probably changed from this operation.
        //
        var bRetrieved = madeEasy.retrieve_account(Server, strMyNymID, MyAcct, true) //bForceDownload defaults to false.
        OT_API_Output(0, (bRetrieved ? "Success" : "Failed") + " retrieving intermediary files for account.\n")
        // ---------------------------------------------------------
        OT_API_Output(0, "\n\nServer response ("+strAttempt+"): SUCCESS paying out dividends.\n")
    }
    
    return nInterpretReply
}



//static int payDividend(const std::string SERVER_ID,
//                       const std::string ISSUER_USER_ID,
//                       const std::string DIVIDEND_FROM_ACCT_ID,
//                       const std::string SHARES_ASSET_TYPE_ID,
//                       const std::string DIVIDEND_MEMO,
//                       const std::string AMOUNT_PER_SHARE);

// HERE, WE GET ALL THE ARGUMENTS TOGETHER,
// and then call the above function.
//
def main_pay_dividend()
{
    var strUsage1 = concat("\n\n  USAGE: paydividend --server SERVER_ID --mynym SHARES_ISSUER_NYM_ID\n",
                               "             --myacct DIVIDEND_SOURCE_ACCT_ID --hispurse SHARES_ASSET_TYPE_ID\n\n")
    
    var strUsage = concat(strUsage1 + "Also necessary: --args \"amount PAYOUT_AMOUNT_PER_SHARE\"\n",
                          "And OPTIONALLY: --args \"memo \\\"Just a memo for the dividend payment.\\\"\"\n\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server") && VerifyExists("MyAcct"))
    {	
        // strAmount and strNote...
        //
        var strAmount    = "0" // must ultimately be >= 1  (Payout per share.)
        var strNote      = ""  // can be blank
        // ------------------------------------        
        var strDefaultAmount  = "1"  // must be >= 1
        var strDefaultNote    = "(blank memo field)"   // can be blank
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "amount 1"
            // EXAMPLE:  --args "amount 15 memo \"Just a memo for the dividend payout.\""
            //
            var strNewAmount = OT_CLI_GetValueByKey( Args, "amount"    ) // any integer value
            var strNewNote   = OT_CLI_GetValueByKey( Args, "memo"  )     // optional memo field
            
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewAmount))
            {    strAmount = strNewAmount }
            if (VerifyStringVal(strNewNote))
            {    strNote = strNewNote }
        }            
        // ------------------------------------
        // If the transfer parameters aren't provided, then we
        // ask the user to supply them at the command line.
        //
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {
            OT_API_Output(0, "Enter the 'Payout Amount Per-Share' as integer["+strDefaultAmount+"]: ")
            strAmount        = OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strNote))
        {
            OT_API_Output(0, "Optionally, enter a memo on a single line["+strDefaultNote+"]: ")
            strNote	= OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {    strAmount = strDefaultAmount }
        if (!VerifyStringVal(strNote))
        {    strNote = strDefaultNote }
        // ----------------------------------------------    
                
        return details_pay_dividend(strAmount, strNote)
    }
    
    return -1
}

// -----------------------







def main_show_purse()
{
    var strUsage = "\n\n  USAGE: showpurse --mypurse ASSET_TYPE_ID --mynym YOUR_NYM_ID --server SERVER_ID \n\n"    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server") && VerifyExists("MyNym") && VerifyExists("MyPurse"))
    {	
        // ------------------------------------
        
        var strPurse = OT_API_LoadPurse(Server, MyPurse, MyNym) // returns NULL, or a purse.

        if (!VerifyStringVal(strPurse))
        {
            OT_API_Output(0, "\n main_show_purse: Unable to load purse. Does it even exist?\n")
        }
        else
        {
            var lAmount = OT_API_Purse_GetTotalValue(Server, MyPurse, strPurse)

            print("\n\nTOTAL VALUE: " + lAmount.to_string())
            
            // ---------------------------
            // Loop through purse contents and display tokens.
            var nCount =  OT_API_Purse_Count(Server, MyPurse, strPurse)

            if (!VerifyIntVal(nCount) || (nCount < 0))
            {
                OT_API_Output(0, "\n main_show_purse: Error: Unexpected bad value returned from OT_API_Purse_Count.\n\n")
                return (-1)
            }
            // ----------------------
            
            if (nCount > 0)
            {
                print("Token count: " + nCount.to_string() + "\n")
                print("Index\tValue\tSeries\tValidFrom\tValidTo\t\tStatus")

                var nIndex = -1
                
                while (nCount > 0)
                {
                    --nCount
                    ++nIndex  // on first iteration, this is now 0.
                    // -------------------
                    var strToken = OT_API_Purse_Peek(Server, MyPurse, MyNym, strPurse)
                    
                    if (!VerifyStringVal(strToken))
                    {
                        OT_API_Output(0, "main_show_purse: Error: OT_API_Purse_Peek unexpectedly returned NULL instead of token.\n")
                        return (-1)
                    }
                    // ------------------------------------------
                    
                    var strNewPurse = OT_API_Purse_Pop(Server, MyPurse, MyNym, strPurse)
                    
                    if (!VerifyStringVal(strNewPurse))
                    {
                        OT_API_Output(0, "main_show_purse: Error: OT_API_Purse_Pop unexpectedly returned NULL instead of updated purse.\n")
                        return (-1)
                    }
                    // ------------------------------------------
                    strPurse = strNewPurse
                    // ------------------------------------------
                    var lDenomination   = OT_API_Token_GetDenomination(Server, MyPurse, strToken)
                    var nSeries         = OT_API_Token_GetSeries      (Server, MyPurse, strToken)
                    var strValidFrom    = OT_API_Token_GetValidFrom   (Server, MyPurse, strToken)
                    var strValidTo      = OT_API_Token_GetValidTo     (Server, MyPurse, strToken)
                    var lTime         = OT_API_GetTime()
                    // ------------------------------------------
                    if (0 > lDenomination)
                    {
                        OT_API_Output(0, "Error while showing purse: bad lDenomination.\n")
                        return (-1)
                    }
                    if (!VerifyIntVal(nSeries))
                    {
                        OT_API_Output(0, "Error while showing purse: bad nSeries.\n")
                        return (-1)
                    }
                    if (!VerifyStringVal(strValidFrom))
                    {
                        OT_API_Output(0, "Error while showing purse: bad strValidFrom.\n")
                        return (-1)
                    }
                    if (!VerifyStringVal(strValidTo))
                    {
                        OT_API_Output(0, "Error while showing purse: bad strValidTo.\n")
                        return (-1)
                    }
                    if (0 > lTime)
                    {
                        OT_API_Output(0, "Error while showing purse: bad strTime.\n")
                        return (-1)
                    }
                    // ------------------------------------------
                    // Output the token...
                    
                    var strStatus = (lTime > strValidTo.to_int()) ? "expired" : "valid"
                    
                    print(nIndex.to_string() + "\t" + lDenomination.ot_string() + "\t" + nSeries.to_string() + "\t" + strValidFrom + "\t" + strValidTo + "\t" + strStatus)
                    // ------------------------------------------
                } // while
            } // if nCount > 0
            
            return 1
            
        } // valid purse string was loaded.
        // ------------------------------------
    }
    
    return -1
}








//
//
// THESE FUNCTIONS were added for the PAYMENTS screen. (They are fairly new.)
//
// Basically there was a need to have DIFFERENT instruments, but to be able to
// treat them as though they are a single type.
//
// In keeping with that, the below functions will work with disparate types.
// You can pass [ CHEQUES / VOUCHERS / INVOICES ] and PAYMENT PLANS, and
// SMART CONTRACTS, and PURSEs into these functions, and they should be able
// to handle any of those types.
//
//
//const char * OT_API_Instrument_GetAmount(const char * SERVER_ID, const char * THE_INSTRUMENT);
//const char * OT_API_Instrument_GetTransNum(const char * SERVER_ID, const char * THE_INSTRUMENT);
//
//const char * OT_API_Instrument_GetValidFrom(const char * SERVER_ID, const char * THE_INSTRUMENT);
//const char * OT_API_Instrument_GetValidTo(const char * SERVER_ID, const char * THE_INSTRUMENT);
//
//const char * OT_API_Instrument_GetMemo(const char * SERVER_ID, const char * THE_INSTRUMENT);
//
//const char * OT_API_Instrument_GetAssetID(const char * SERVER_ID, const char * THE_INSTRUMENT);
//
//const char * OT_API_Instrmnt_GetSenderUserID(const char * SERVER_ID, const char * THE_INSTRUMENT);
//const char * OT_API_Instrmnt_GetSenderAcctID(const char * SERVER_ID, const char * THE_INSTRUMENT);
//const char * OT_API_Instrmnt_GetRecipientUserID(const char * SERVER_ID, const char * THE_INSTRUMENT);
//const char * OT_API_Instrmnt_GetRecipientAcctID(const char * SERVER_ID, const char * THE_INSTRUMENT);
//

def details_deposit_cheque(strMyNymID, strInstrument, strType)
{
    var strAssetTypeID = OT_API_Instrument_GetAssetID(Server, strInstrument)
    
    if (!VerifyStringVal(strAssetTypeID))
    {
        OT_API_Output(0, "\n\nFailure: Unable to find Asset Type ID on the instrument.\n\n")
        return (-1)
    }
    // ---------------------------------------------    
    if (strAssetTypeID != OT_API_GetAccountWallet_AssetTypeID(MyAcct))
    {
        OT_API_Output(0, "\n\nFailure: Asset Type ID on the instrument doesn't match the one on MyAcct.\n\n")
        return (-1)
    }
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()

    // ***************************************************************
    
    // HERE, WE SEND THE TRANSFER REQUEST TO THE SERVER
    //
    var strResponse = madeEasy.deposit_cheque(Server, strMyNymID, MyAcct, strInstrument)
    var strAttempt  = "deposit_cheque"

    // ***************************************************************
    
    // HERE, WE INTERPRET THE SERVER REPLY, WHETHER SUCCESS, FAIL, OR ERROR...
    
    var nInterpretReply = InterpretTransactionMsgReply(Server, strMyNymID, MyAcct, strAttempt, strResponse)
    
    if (1 == nInterpretReply)
    {    
        // Download all the intermediary files (account balance, inbox, outbox, etc)
        // since they have probably changed from this operation.
        //
        var bRetrieved = madeEasy.retrieve_account(Server, strMyNymID, MyAcct, true) //bForceDownload defaults to false.
        
        OT_API_Output(0, "Server response ("+strAttempt+"): SUCCESS depositing cheque!\n")
        OT_API_Output(0, (bRetrieved ? "Success" : "Failed") + " retrieving intermediary files for account.\n")
    }
    
    // ***************************************************************
    //
    // Return status to caller.
    //
    return nInterpretReply

    // --------------------------------------------------------------------
}


def details_deposit_purse(strFromNymID, strInstrument, strType, strIndices)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ---------------------------------------------
    // HERE, WE LOOK UP THE asset type ID, BASED ON THE ACCOUNT ID.
    //
    var strAssetTypeID = OT_API_GetAccountWallet_AssetTypeID(MyAcct)
    
    if (!VerifyStringVal(strAssetTypeID))
    {
        OT_API_Output(0, "\n\nFailure: Unable to find Asset Type ID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the asset type based on the account.\n\n")
        return (-1)
    }
    // ---------------------------------------------    
    if (VerifyExists("MyPurse", false) && (MyPurse != strAssetTypeID))
    {
        OT_API_Output(0, "Warning: Depositing to MyAcct, which is NOT the same asset type as the MyPurse asset type specified.\n")
    }
    // ---------------------------------------------    
    
    var bLoadedPurse = false
    
    // If strInstrument wasn't passed, that means we're supposed to load 
    // the purse ourselves, from local storage.
    //
    if (!VerifyStringVal(strInstrument))
    {
        // LOAD PURSE
        
        strInstrument = OT_API_LoadPurse(Server, strAssetTypeID, strFromNymID) // returns NULL, or a purse.
        
        if (!VerifyStringVal(strInstrument))
        {
            OT_API_Output(0, "\n details_deposit_purse: Unable to load purse from local storage. Does it even exist?\n")
            return (-1)
        }
        
        bLoadedPurse = true
    }
    // ---------------------------------------------    
    // Below this point, we know that strInstrument contains either the purse as it was passed in
    // to us, or it contains the purse as we loaded it from local storage.
    // If it WAS from local storage, then there's a chance that strIndices contains "all" or "4, 6, 2" etc.
    // If that's the case, then we need to iterate through the purse, and add the denoted token IDs to 
    // a vector (selectedTokens) and pass it into depositCashPurse.
    //
    // ---------------------------------------------    
    
    var vecSelectedTokenIDs = Vector()
    
    // If we loaded the purse (vs the user pasting one in...)
    // then the user might have wanted to deposit only selected indices,
    // rather than ALL the tokens in that purse.
    // So we'll loop through the purse and add any relevant IDs to the
    // "selected" list, since the actual Token IDs must be passed.
    //
    if (bLoadedPurse)
    {
        // ---------------------------
        // Loop through purse contents...
        //
        var nCount =  OT_API_Purse_Count(Server, strAssetTypeID, strInstrument)
        
        if (!VerifyIntVal(nCount) || (nCount < 0))
        {
            OT_API_Output(0, "\n main_show_purse: Error: Unexpected bad value returned from OT_API_Purse_Count.\n\n")
            return (-1)
        }
        // ----------------------
        if (nCount < 1)
        {
            OT_API_Output(0, "\n main_show_purse: The purse is empty, so you can't deposit it.\n\n")
            return -1
        }
        // ----------------------
        else //nCount >= 1
        {
            // Make a copy of the purse passed in, so we can iterate it and find the 
            // appropriate Token IDs...
            
            var strPurse = strInstrument
            var nIndex   = -1
            
            while (nCount > 0)
            {
                --nCount
                ++nIndex  // on first iteration, this is now 0.
                // -------------------
                var strToken = OT_API_Purse_Peek(Server, strAssetTypeID, strFromNymID, strPurse)
                
                if (!VerifyStringVal(strToken))
                {
                    OT_API_Output(0, "main_show_purse: Error: OT_API_Purse_Peek unexpectedly returned NULL instead of token.\n")
                    return (-1)
                }
                // ------------------------------------------
                
                var strNewPurse = OT_API_Purse_Pop(Server, strAssetTypeID, strFromNymID, strPurse)
                
                if (!VerifyStringVal(strNewPurse))
                {
                    OT_API_Output(0, "main_show_purse: Error: OT_API_Purse_Pop unexpectedly returned NULL instead of updated purse.\n")
                    return (-1)
                }
                // ------------------------------------------
                strPurse = strNewPurse
                // ------------------------------------------
                
                var strTokenID  =  OT_API_Token_GetID(Server, strAssetTypeID, strToken)

                if (!VerifyStringVal(strTokenID))
                {
                    OT_API_Output(0, "Error while depositing purse: bad strTokenID.\n")
                    return (-1)
                }
                // ------------------------------------------
//              bool NumList_VerifyQuery(const std::string str_NumList, const std::string str_Numbers);

                if (OT_API_NumList_VerifyQuery(strIndices, nIndex.to_string())) // empty vector should be interpreted already as "all"
//              if (("all" == strIndices) || OT_API_NumList_VerifyQuery(strIndices, nIndex.to_string()))
                {
                    vecSelectedTokenIDs.push_back(strTokenID)
                }
                // ------------------------------------------
            } // while
        } // if nCount > 0
    }// if (bLoadedPurse)
    // ---------------------------------------------    

    var nResult = depositCashPurse( Server,  strAssetTypeID,  strFromNymID,  strInstrument,  vecSelectedTokenIDs,  MyAcct) 

    return nResult;
    // --------------------------------------------------------------------
}

//case (this.DEPOSIT_CASH)
//{	nRetVal = OT_API_notarizeDeposit(this.serverID, this.nymID, this.accountID, this.strData);	 break; }
//case (this.DEPOSIT_CHEQUE)
//{	nRetVal = OT_API_depositCheque(this.serverID, this.nymID, this.accountID, this.strData);	 break; }
//case (this.DEPOSIT_PAYMENT_PLAN)
//{	nRetVal = OT_API_depositPaymentPlan(this.serverID, this.nymID, this.strData);	 break; }


def details_deposit()
{
    var strInstrument = ""

    // ---------------------------------------------
    // HERE, WE LOOK UP THE recipient NYM ID, BASED ON THE ACCOUNT ID.
    //
    var strToNymID = OT_API_GetAccountWallet_NymID(MyAcct)
    
    if (!VerifyStringVal(strToNymID))
    {
        OT_API_Output(0, "\n\nFailure: Unable to find depositor NymID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
        return (-1)
    }
    // ---------------------------------------------    
    // 
    var strIndices = ""

    if (VerifyExists("Args", false))
    {
        // You have the OPTION to pass in indices for tokens in your purse, and deposit
        // will automatically assume "deposit cash" and deposit those tokens.
        // You can also specify to deposit ALL tokens in your cash purse.
        // Without this extra argument, OT will ask you to paste an instrument,
        // and then will dynamically determine its contract type.
        //
        
        // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
        //                                  const std::string str_key)
        // 
        // OPTION:   --args "key value key value"
        // EXAMPLE:  --args "indices \"4, 6, 9\" "
        // EXAMPLE:  --args "indices \"all\" "
        //
        strIndices = OT_CLI_GetValueByKey(Args, "indices") // OTNumList will be used for this value.        
    }            
    // ----------------------------------------------
    //
    if (VerifyStringVal(strIndices)) // He wants to deposit some or all of his local purse.
    {
        // Only in the case of cash, it's possible you have some cash in Nym A's purse, but
        // you want to deposit it into Nym B's account. So we have a "to" Nym and a "from" Nym
        // even though they will often be the same.
        //
        var strFromNymID = ""
        
        if (VerifyExists("MyNym", false))
        {
            strFromNymID = MyNym
        }
        else
        {
            strFromNymID = strToNymID
        }
        // ---------------------------
        // In this case, strInstrument is blank.
        // That's how the callee knows that we're working with the local purse.
        // Then strIndices tells him either to use "all" tokens in that purse, or
        // the selected indices.
        //
        return details_deposit_purse(strFromNymID, strInstrument, "PURSE", strIndices)
    }
    // ---------------------------------------------    
    
    else // he wants to paste an instrument.
    {
        // 
        OT_API_Output(0, "You can deposit a PURSE (containing cash tokens) or a CHEQUE / VOUCHER. \n")
        OT_API_Output(0, "Paste your financial instrument here, followed by a ~ by itself on a blank line: \n")
        
        strInstrument = OT_CLI_ReadUntilEOF() 
        
        if(!VerifyStringVal(strInstrument))
        {
            return (-1)
        }
        // -----------------------
        
//      const char * OTPayment::_TypeStrings[] = 
//      {
//          // ------------------
//          // OTCheque is derived from OTTrackable, which is derived from OTInstrument, which is
//          // derived from OTScriptable, which is derived from OTContract.
//          // ------------------
//          "CHEQUE",         // A cheque drawn on a user's account.
//          "VOUCHER",        // A cheque drawn on a server account (cashier's cheque aka banker's cheque)
//          "INVOICE",        // A cheque with a negative amount. (Depositing this causes a payment out, instead of a deposit in.)
//          // ------------------
//          "PAYMENT_PLAN",   // An OTCronItem-derived OTPaymentPlan, related to a recurring payment plan.
//          "SMART_CONTRACT", // An OTCronItem-derived OTSmartContract, related to a smart contract.
//          // ------------------
//          "PURSE",          // An OTContract-derived OTPurse containing a list of cash OTTokens.
//          // ------------------
//          "ERROR_STATE"
//      };

        
        var strType = OT_API_Instrument_GetType(Server, strInstrument)
        
        if (!VerifyStringVal(strType))
        {
            OT_API_Output(0, "\n\nFailure: Unable to determine instrument type. Expected CHEQUE, VOUCHER, INVOICE, or (cash) PURSE.\n")
            return (-1)
        }
        // ---------------------------------------------    

        switch(strType)
        {
            case ("CHEQUE") 
            {
                return details_deposit_cheque(strToNymID, strInstrument, strType)
            }
            case ("VOUCHER")
            {
                return details_deposit_cheque(strToNymID, strInstrument, strType)
            }
            case ("INVOICE")
            {
                return details_deposit_cheque(strToNymID, strInstrument, strType)
            }
            case ("PURSE")
            {
                return details_deposit_purse(strToNymID, strInstrument, strType, "") // strIndices is left blank in this case
            }
            default
            {
                OT_API_Output(0, "\n\nFailure: Unable to determine instrument type. Expected CHEQUE, VOUCHER, INVOICE, or (cash) PURSE.\n")
                return (-1)
            }
        }
    }
    
    return (-1)
}


def main_deposit()
{                       
    var strUsage1 = "\n\n  USAGE: deposit --myacct YOUR_ACCT_ID --mynym YOUR_NYM_ID --server SERVER_ID \n(OT will ask you to paste the instrument.)\n"    
    var strUsage2 = concat(strUsage1, "Optionally:    --args \"indices \\\"4, 6, 9\\\" \"\n")
    var strUsage3 = concat(strUsage2, "Optionally:    --args \"indices \\\"all\\\" \"  (To deposit ALL cash tokens in your purse.)\n")
    var strUsage  = concat(strUsage3, "NymID is often determined based on MyAcct.\nIf you supply optional indices, they must correspond to tokens in your cash purse.\n\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    // A bit complicated:
    //
    // If I specify MyPurse and MyAcct, then they MUST have the same asset type.
    //
    // If I specify MyNym and MyPurse, that is where we will look for the purse.
    //
    // If I specify MyAcct, and it's owned by a different Nym than MyNym, then the cash 
    // tokens will be reassigned from MyNym to MyAcct's Nym, before depositing.
    // Basically ALWAYS look up MyAcct's owner, and set HIM as the recipient Nym.
    // (But still use MyNym, independently, to find the purse being deposited.)
    // 
    // Must ALWAYS specify MyAcct because otherwise, where are you depositing to?
    // 
    // If MyNym isn't available, should use MyAcct's Nym.
    //
    // Shouldn't need to specify MyPurse, since we can ONLY deposit into MyAcct of
    // the same type as MyAcct. Thus we should ignore any other asset types or purses
    // since they couldn't possibly be deposited into MyAcct anyway.
    //
    
    if (VerifyExists("Server") && VerifyExists("MyAcct"))
    {	
        return details_deposit()
    }
    
    return -1
}











def main_new_symmetric_key()
{
	var strKey = OT_API_CreateSymmetricKey()
    
	if (VerifyStringVal(strKey))
	{
		// stderr
		OT_API_Output(0, "\n")
        
		// stdout
		print(strKey)
        
		// stderr
		OT_API_Output(0, "\n")
		
		return 1
    }
    
    // "return value"
    -1
}



/*
 
 const char * OT_API_Instrument_GetAmount(const char * SERVER_ID, const char * THE_INSTRUMENT);
 const char * OT_API_Instrument_GetTransNum(const char * SERVER_ID, const char * THE_INSTRUMENT);
 
 const char * OT_API_Instrument_GetValidFrom(const char * SERVER_ID, const char * THE_INSTRUMENT);
 const char * OT_API_Instrument_GetValidTo(const char * SERVER_ID, const char * THE_INSTRUMENT);
 
 const char * OT_API_Instrument_GetMemo(const char * SERVER_ID, const char * THE_INSTRUMENT);
 
 const char * OT_API_Instrument_GetType(const char * SERVER_ID, const char * THE_INSTRUMENT);
 
 const char * OT_API_Instrument_GetAssetID(const char * SERVER_ID, const char * THE_INSTRUMENT);
 
 const char * OT_API_Instrmnt_GetSenderUserID(const char * SERVER_ID, const char * THE_INSTRUMENT);
 const char * OT_API_Instrmnt_GetSenderAcctID(const char * SERVER_ID, const char * THE_INSTRUMENT);
 const char * OT_API_Instrmnt_GetRecipientUserID(const char * SERVER_ID, const char * THE_INSTRUMENT);
 const char * OT_API_Instrmnt_GetRecipientAcctID(const char * SERVER_ID, const char * THE_INSTRUMENT);
 */

// Show an individual payment in detail.
//
def main_show_payment()
{
    var strUsage = "\nUsage:  showpayment --args \"index PAYMENT_INDEX showmemo true|false\"\n Default index is 0. Default showmemo is false.\n"

    OT_API_Output(0, strUsage)
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    // SHOW PAYMENTS INBOX
    // 
    // Load an asset account's payments inbox from local storage and display it on the screen.
    //
    
    if (VerifyExists("Server") && VerifyExists("MyNym") && VerifyExists("Args"))
    {	
        
        // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
        //                                  const std::string str_key)
        // 
        // OPTION:   --args "key value key value"
        // EXAMPLE:  --args "index 1"
        //
        var strIndex         = OT_CLI_GetValueByKey( Args, "index"    ) // any integer value
        var strShowLargeMemo = OT_CLI_GetValueByKey( Args, "showmemo"    ) // any integer value
        var nIndex   = 0
        var bShowLargeMemo = false  // Memos aren't normally shown if they contain a newline. But you can force them to show anyway.
        // ----------------------------------------------
        // Set the values based on the custom arguments, for those found.
        //
        if (VerifyStringVal(strShowLargeMemo) && ("true" == strShowLargeMemo))
        {
            bShowLargeMemo = true // now we'll show the memo even if it spans multiple lines.
        }
        // -----------------------------
        if (VerifyStringVal(strIndex))
        {    
            var nTempIndex = strIndex.to_int()
            
            if (VerifyIntVal(nTempIndex) && (nTempIndex >= 0))
            {
                nIndex = nTempIndex
            }
        }
        // ***************************************************************
        
        var strInbox = OT_API_LoadPaymentInbox(Server, MyNym); // Returns NULL, or an inbox.
        
        if (!VerifyStringVal(strInbox))
        {
            OT_API_Output(0, "\n\n OT_API_LoadPaymentInbox: Failed.\n\n")
            return (-1)
        }
        else	// Success!
        {
            OT_API_Output(0, "\n\n") // stderr
//          print(strInbox)          // stdout
            
            var nCount = OT_API_Ledger_GetCount(Server, MyNym, MyNym, strInbox)
            
            if (VerifyIntVal(nCount))
            {
                if (nIndex > (nCount - 1))
                {
                    OT_API_Output(0, "Index out of bounds. (There are " + nCount.to_string() + " indices, starting at 0.\n")
                    return (-1)
                }
                // ------------------------------------------------------------------------
                OT_API_Output(0, "Ind  Amt   Type       Txn#   Memo\n")
                OT_API_Output(0, "---------------------------------\n")
                
                var strInstrument      = OT_API_Ledger_GetInstrument(Server, MyNym, MyNym, strInbox, nIndex)

                if (!VerifyStringVal(strInstrument))
                {
                    OT_API_Output(0, "Failed trying to get payment instrument from payments box.\n")
                    return (-1)
                }
                
                var strTrans           = OT_API_Ledger_GetTransactionByIndex(Server, MyNym, MyNym, strInbox, nIndex)
                var lTransNumber       = OT_API_Ledger_GetTransactionNumberByIndex(Server, MyNym, MyNym, strInbox, nIndex)
                
                var lRefNum            = OT_API_Transaction_GetDisplayReferenceToNum(Server, MyNym, MyNym, strTrans)
                var lAmount            = OT_API_Instrument_GetAmount(Server, strInstrument)
                var strType            = OT_API_Instrument_GetType(Server, strInstrument)
                var strAssetType       = OT_API_Instrument_GetAssetID(Server, strInstrument)  // todo: output this.
                
                var strMemo            = OT_API_Instrument_GetMemo(Server, strInstrument)
                
                var strSenderUserID    = OT_API_Instrmnt_GetSenderUserID(Server, strInstrument)
                var strSenderAcctID    = OT_API_Instrmnt_GetSenderAcctID(Server, strInstrument)
                var strRecipientUserID = OT_API_Instrmnt_GetRecipientUserID(Server, strInstrument)
                var strRecipientAcctID = OT_API_Instrmnt_GetRecipientAcctID(Server, strInstrument)
                
                var strUserID = VerifyStringVal(strSenderUserID) ? strSenderUserID : strRecipientUserID;
                var strAcctID = VerifyStringVal(strSenderAcctID) ? strSenderAcctID : strRecipientAcctID;
                // ------------------------------
                var bUserIDExists  = VerifyStringVal(strUserID)
                var bAcctIDExists  = VerifyStringVal(strAcctID)
                var bAssetIDExists = VerifyStringVal(strAssetType)
                var bMemoExists    = VerifyStringVal(strMemo)
                
                if (bMemoExists && (strMemo.find("\n") >= 0) && !bShowLargeMemo)
                {
                    strMemo = "<too large to display here>"
                }
                else if (bMemoExists)
                {
                    var strTempMemo = "\"" + strMemo + "\""
                    strMemo = strTempMemo
                }
                // ------------------------------
                var strNewlineSeparator = ""
                
                if (bUserIDExists || bAcctIDExists)
                {  strNewlineSeparator = "\n" }
                
                var strSeparator = (!bUserIDExists && !bAcctIDExists && !bAssetIDExists) ? "" : strNewlineSeparator;
                // ------------------------------
                // Set up some symbols to appear or not, 
                // based on whether there is something to show.
                //
                var strUserDenoter   = (bUserIDExists  ? "U:" : "")
                var strUserDenoter2  = (bUserIDExists  ? " - " : "")
                var strAcctDenoter   = (bAcctIDExists  ? "A:" : "")
                var strAcctDenoter2  = (bAcctIDExists  ? " - " : "")
                var strAssetDenoter  = (bAssetIDExists ? "T:" : "")
                var strAssetDenoter2 = (bAssetIDExists ? " - " : "")
                // ------------------------------
                // If we have the user/acct/asset ID, then get the associated name (if that exists.)
                //
                var strUserName     = (bUserIDExists  ? ("\"" + OT_API_GetNym_Name(strUserID) + "\"") : "")
                var strAcctName     = (bAcctIDExists  ? ("\"" + OT_API_GetAccountWallet_Name(strAcctID) + "\"") : "")
                var strAssetName    = (bAssetIDExists ? ("\"" + OT_API_GetAssetType_Name(strAssetType) + "\"") : "")
                
                // Just making sure here that if the string wasn't there, that it's set to 
                // a proper empty string, instead of a null or a "not a value" value.
                //
                if (!VerifyStringVal(strUserName))      { strUserName   = ""; strUserDenoter2  = "" }
                if (!VerifyStringVal(strAcctName))      { strAcctName   = ""; strAcctDenoter2  = "" }
                if (!VerifyStringVal(strAssetName))     { strAssetName  = ""; strAssetDenoter2 = "" }
                
                if ("\"\"" == strUserName)              { strUserName   = ""; strUserDenoter2  = "" }
                if ("\"\"" == strAcctName)              { strAcctName   = ""; strAcctDenoter2  = "" }
                if ("\"\"" == strAssetName)             { strAssetName  = ""; strAssetDenoter2 = "" }
                // ------------------------------
                var strOut1 = nIndex.to_string() + "    "
                var strOut2 = lAmount.to_string() + (lAmount.to_string().size() < 3 ? "    " : "   ")
                var strOut3 = strType
                var strOut4 = strType.size() > 10 ? " " : "    "
                var strOut5 = lTransNumber.to_string() + (lTransNumber.to_string().size() < 2 ? "    " : "   ")
                var strOut6 = (bMemoExists ? ( strMemo ) : "") + "\n"
                var strOut7 = strUserDenoter+strUserID + strUserDenoter2 + strUserName + strSeparator
                var strOut8 = strAcctDenoter+strAcctID + strAcctDenoter2 + strAcctName + strSeparator
                var strOut9 = strAssetDenoter+strAssetType + strAssetDenoter2 + strAssetName + "\n"

                print(strOut1 + strOut2 + strOut3 + strOut4 + strOut5 + strOut6 + strOut7 + strOut8 + strOut9)                    
            } // VerifyIntVal (nCount)
            
//          OT_API_Output(0, "\n\n") // stderr
            return 1
        }        
    }
    return -1
}

def main_show_payments_inbox()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    
    var madeEasy	= OT_ME()
    // ------------------------------
    // SHOW PAYMENTS INBOX
    // 
    // Load an asset account's payments inbox from local storage and display it on the screen.
    //
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {	
        // ***************************************************************
        
        var strInbox = OT_API_LoadPaymentInbox(Server, MyNym); // Returns NULL, or an inbox.
        
        if (!VerifyStringVal(strInbox))
        {
            OT_API_Output(0, "\n\n OT_API_LoadPaymentInbox: Failed.\n\n")
            return (-1)
        }
        else	// Success!
        {
            OT_API_Output(0, "\n\n") // stderr
//          print(strInbox)          // stdout
            
            var nCount = OT_API_Ledger_GetCount(Server, MyNym, MyNym, strInbox)
            
            if (VerifyIntVal(nCount))
            {
                OT_API_Output(0, "SHOW PAYMENT INBOX:\n")
                OT_API_Output(0, "Ind  Amt   Type       Txn#  Asset_Type\n")
                OT_API_Output(0, "---------------------------------------\n")
                
                for (var nIndex = 0; nIndex < nCount; ++nIndex)
                {
                    var strInstrument      = OT_API_Ledger_GetInstrument(Server, MyNym, MyNym, strInbox, nIndex)

                    if (!VerifyStringVal(strInstrument))
                    {
                        OT_API_Output(0, "Failed trying to get payment instrument from payments box.\n")
                        return (-1)
                    }
                    
                    var strTrans           = OT_API_Ledger_GetTransactionByIndex(Server, MyNym, MyNym, strInbox, nIndex)
                    var lTransNumber       = OT_API_Ledger_GetTransactionNumberByIndex(Server, MyNym, MyNym, strInbox, nIndex)
                    
                    var lRefNum          = OT_API_Transaction_GetDisplayReferenceToNum(Server, MyNym, MyNym, strTrans)
//                  var strAmount          = OT_API_Transaction_GetAmount(Server, MyNym, MyNym, strTrans)
//                  var strType            = OT_API_Transaction_GetType(Server, MyNym, MyNym, strTrans)
//                  var strSenderUserID    = OT_API_Transaction_GetSenderUserID(Server, MyNym, MyNym, strTrans)
//                  var strSenderAcctID    = OT_API_Transaction_GetSenderAcctID(Server, MyNym, MyNym, strTrans)
//                  var strRecipientUserID = OT_API_Transaction_GetRecipientUserID(Server, MyNym, MyNym, strTrans)
//                  var strRecipientAcctID = OT_API_Transaction_GetRecipientAcctID(Server, MyNym, MyNym, strTrans)
                    
//                  var lRefNum            = OT_API_Transaction_GetDisplayReferenceToNum(Server, MyNym, MyNym, strTrans)
                    var lAmount            = OT_API_Instrument_GetAmount(Server, strInstrument)
                    var strType            = OT_API_Instrument_GetType(Server, strInstrument)
                    var strAssetType       = OT_API_Instrument_GetAssetID(Server, strInstrument)  // todo: output this.
                    
                    var strSenderUserID    = OT_API_Instrmnt_GetSenderUserID(Server, strInstrument)
                    var strSenderAcctID    = OT_API_Instrmnt_GetSenderAcctID(Server, strInstrument)
                    var strRecipientUserID = OT_API_Instrmnt_GetRecipientUserID(Server, strInstrument)
                    var strRecipientAcctID = OT_API_Instrmnt_GetRecipientAcctID(Server, strInstrument)
                    
                    var strUserID = VerifyStringVal(strSenderUserID) ? strSenderUserID : strRecipientUserID;
                    var strAcctID = VerifyStringVal(strSenderAcctID) ? strSenderAcctID : strRecipientAcctID;
                    // ------------------------------
                    var bUserIDExists  = VerifyStringVal(strUserID)
                    var bAcctIDExists  = VerifyStringVal(strAcctID)
                    var bAssetIDExists = VerifyStringVal(strAssetType)
                    // ------------------------------
                    var strAssetDenoter = (bAssetIDExists ? " - " : "")
                    // ------------------------------
                    var strAssetName    = (bAssetIDExists ? ("\"" + OT_API_GetAssetType_Name(strAssetType) + "\"") : "")
                    if (!VerifyStringVal(strAssetName))     { strAssetName = ""; strAssetDenoter2 = "" }
                    // ------------------------------
                    var strOut1 = nIndex.to_string() + "    "
                    var strOut2 = lAmount.to_string() + (lAmount.to_string().size() < 3 ? "    " : "   ")
                    var strOut3 = strType
                    var strOut4 = strType.size() > 10 ? " " : "    "
                    var strOut5 = lTransNumber.to_string() + (lTransNumber.to_string().size() < 2 ? "    " : "   ")
                    var strOut6 = strAssetType + strAssetDenoter + strAssetName + "\n"
                    
                    print(strOut1 + strOut2 + strOut3 + strOut4 + strOut5 + strOut6)                    
                } // for
            } // VerifyIntVal (nCount)
            
            return 1
        }        
    }
    return -1
}







def main_show_records()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    // SHOW RECORD BOX
    // 
    // Load an asset account's record box from local storage and display it on the screen.
    //
    
    if (VerifyExists("Server") && VerifyExists("MyAcct"))
    {	
        // ---------------------------------------------
        // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
        //
        var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
        
        if (!VerifyStringVal(strMyNymID))
        {
            OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
            return (-1)
        }
        // ***************************************************************
        
        var strInbox = OT_API_LoadRecordBox(Server, strMyNymID, MyAcct); // Returns NULL, or an inbox.
        
        if (!VerifyStringVal(strInbox))
        {
            OT_API_Output(0, "\n\n OT_API_LoadRecordBox: Failed.\n\n")
            return -1
        }
        else	// Success!
        {
            OT_API_Output(0, "\n\n") // stderr
//          print(strInbox)          // stdout
            
            var nCount = OT_API_Ledger_GetCount(Server, strMyNymID, MyAcct, strInbox)
            
            if (VerifyIntVal(nCount))
            {
                OT_API_Output(0, "SHOW RECORDS: \n\n")
                OT_API_Output(0, "Ind  Amt  Type        Txn# InRef#|User / Acct\n")
                OT_API_Output(0, "---------------------------------|(from or to)\n")
                
                for (var nIndex = 0; nIndex < nCount; ++nIndex)
                {
                    var strTrans           = OT_API_Ledger_GetTransactionByIndex(Server, strMyNymID, MyAcct, strInbox, nIndex)
                    var lTransNumber       = OT_API_Ledger_GetTransactionNumberByIndex(Server, strMyNymID, MyAcct, strInbox, nIndex)
                    var lRefNum          = OT_API_Transaction_GetDisplayReferenceToNum(Server, strMyNymID, MyAcct, strTrans)
                    var Amount             = OT_API_Transaction_GetAmount(Server, strMyNymID, MyAcct, strTrans)
                    var strType            = OT_API_Transaction_GetType(Server, strMyNymID, MyAcct, strTrans)
                    var strSenderUserID    = OT_API_Transaction_GetSenderUserID(Server, strMyNymID, MyAcct, strTrans)
                    var strSenderAcctID    = OT_API_Transaction_GetSenderAcctID(Server, strMyNymID, MyAcct, strTrans)
                    var strRecipientUserID = OT_API_Transaction_GetRecipientUserID(Server, strMyNymID, MyAcct, strTrans)
                    var strRecipientAcctID = OT_API_Transaction_GetRecipientAcctID(Server, strMyNymID, MyAcct, strTrans)
                    
                    var strUserID = VerifyStringVal(strSenderUserID) ? strSenderUserID : strRecipientUserID;
                    var strAcctID = VerifyStringVal(strSenderAcctID) ? strSenderAcctID : strRecipientAcctID;
                    
                    var bUserIDExists = VerifyStringVal(strUserID)
                    var bAcctIDExists = VerifyStringVal(strAcctID)
                    
                    var strNewlineSeparator = ""
                    
                    if (bUserIDExists || bAcctIDExists)
                    {  strNewlineSeparator = "\n                                 |" }
                    
                    var strSeparator = (!bUserIDExists && !bAcctIDExists) ? "" : strNewlineSeparator;
                    
                    var strUserDenoter = (bUserIDExists ? "U:" : "")
                    var strAcctDenoter = (bAcctIDExists ? "A:" : "")
                    
                    OT_API_Output(0, nIndex.to_string() + "    ")
                    OT_API_Output(0, lAmount.to_string() + (lAmount.to_string().size() < 3 ? "    " : "   "))
                    OT_API_Output(0, strType)
                    OT_API_Output(0, strType.size() > 10 ? " " : "    ")
                    OT_API_Output(0, lTransNumber.to_string() + (lTransNumber.to_string().size() < 2 ? "    " : "   "))
                    OT_API_Output(0, lRefNum.to_string() + (lRefNum.to_string().size() > 2 ? "  " : " ") + "|")
                    OT_API_Output(0, strUserDenoter+strUserID + strSeparator + strAcctDenoter+strAcctID + "\n")
                } // for
            } // VerifyIntVal (nCount)
            
            return 1
        }
    }
    -1
}








def main_show_inbox()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    
    var madeEasy	= OT_ME()
    // ------------------------------
    // SHOW INBOX
    // 
    // Load an asset account's inbox from local storage and display it on the screen.
    //
    
    if (VerifyExists("Server") && VerifyExists("MyAcct"))
    {	
        // ---------------------------------------------
        // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
        //
        var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
        
        if (!VerifyStringVal(strMyNymID))
        {
            OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
            return (-1)
        }
        // ***************************************************************
        
        var strInbox = OT_API_LoadInbox(Server, strMyNymID, MyAcct); // Returns NULL, or an inbox.
        
        if (!VerifyStringVal(strInbox))
        {
            OT_API_Output(0, "\n\n OT_API_LoadInbox: Failed.\n\n")
            return -1
        }
        else	// Success!
        {
            OT_API_Output(0, "\n\n") // stderr
//          print(strInbox)          // stdout
            
            var nCount = OT_API_Ledger_GetCount(Server, strMyNymID, MyAcct, strInbox)
            
            if (VerifyIntVal(nCount))
            {
                OT_API_Output(0, "SHOW INBOX: \n\n")
                OT_API_Output(0, "Ind  Amt  Type        Txn# InRef#|User / Acct\n")
                OT_API_Output(0, "---------------------------------|(from or to)\n")
                
                for (var nIndex = 0; nIndex < nCount; ++nIndex)
                {
                    var strTrans           = OT_API_Ledger_GetTransactionByIndex(Server, strMyNymID, MyAcct, strInbox, nIndex)
                    var lTransNumber       = OT_API_Ledger_GetTransactionNumberByIndex(Server, strMyNymID, MyAcct, strInbox, nIndex)
                    var lRefNum            = OT_API_Transaction_GetDisplayReferenceToNum(Server, strMyNymID, MyAcct, strTrans)
                    var lAmount            = OT_API_Transaction_GetAmount(Server, strMyNymID, MyAcct, strTrans)
                    var strType            = OT_API_Transaction_GetType(Server, strMyNymID, MyAcct, strTrans)
                    var strSenderUserID    = OT_API_Transaction_GetSenderUserID(Server, strMyNymID, MyAcct, strTrans)
                    var strSenderAcctID    = OT_API_Transaction_GetSenderAcctID(Server, strMyNymID, MyAcct, strTrans)
                    var strRecipientUserID = OT_API_Transaction_GetRecipientUserID(Server, strMyNymID, MyAcct, strTrans)
                    var strRecipientAcctID = OT_API_Transaction_GetRecipientAcctID(Server, strMyNymID, MyAcct, strTrans)
                    
                    var strUserID = VerifyStringVal(strSenderUserID) ? strSenderUserID : strRecipientUserID;
                    var strAcctID = VerifyStringVal(strSenderAcctID) ? strSenderAcctID : strRecipientAcctID;
                    
                    var bUserIDExists = VerifyStringVal(strUserID)
                    var bAcctIDExists = VerifyStringVal(strAcctID)
                    
                    var strNewlineSeparator = ""
                    
                    if (bUserIDExists || bAcctIDExists)
                    {  strNewlineSeparator = "\n                                 |" }
                    
                    var strSeparator = (!bUserIDExists && !bAcctIDExists) ? "" : strNewlineSeparator;
                    
                    var strUserDenoter = (bUserIDExists ? "U:" : "")
                    var strAcctDenoter = (bAcctIDExists ? "A:" : "")
                    
                    OT_API_Output(0, nIndex.to_string() + "    ")
                    OT_API_Output(0, lAmount.to_string() + (lAmount.to_string().size() < 3 ? "    " : "   "))
                    OT_API_Output(0, strType)
                    OT_API_Output(0, strType.size() > 10 ? " " : "    ")
                    OT_API_Output(0, lTransNumber.to_string() + (lTransNumber.to_string().size() < 2 ? "    " : "   "))
                    OT_API_Output(0, lRefNum.to_string() + (lRefNum.to_string().size() > 2 ? "  " : " ") + "|")
                    OT_API_Output(0, strUserDenoter+strUserID + strSeparator + strAcctDenoter+strAcctID + "\n")
                } // for
            } // VerifyIntVal (nCount)
            
            return 1
        }
    }
    -1
}








def main_show_outbox()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    
    var madeEasy	= OT_ME()
    // ------------------------------
    // SHOW OUTPUT
    // 
    // Load an asset account's outbox from local storage and display it on the screen.
    //
    
    if (VerifyExists("Server") && VerifyExists("MyAcct"))
    {	
        // ---------------------------------------------
        // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
        //
        var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
        
        if (!VerifyStringVal(strMyNymID))
        {
            OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
            return (-1)
        }
        // ***************************************************************
        
        var strOutbox = OT_API_LoadOutbox(Server, strMyNymID, MyAcct); // Returns NULL, or an outbox.
        
        if (!VerifyStringVal(strOutbox))
        {
            OT_API_Output(0, "\n\n OT_API_LoadOutbox: Failed.\n\n")
            return -1
        }
        else	// Success!
        {
            OT_API_Output(0, "\n\n") // stderr
//          print(strOutbox)         // stdout
            
            var nCount = OT_API_Ledger_GetCount(Server, strMyNymID, MyAcct, strOutbox)
            
            if (VerifyIntVal(nCount))
            {
                OT_API_Output(0, "SHOW OUTBOX: \n\n")
                OT_API_Output(0, "Ind  Amt  Type        Txn# InRef#|User / Acct\n")
                OT_API_Output(0, "---------------------------------|(from or to)\n")
                
                for (var nIndex = 0; nIndex < nCount; ++nIndex)
                {
                    var strTrans           = OT_API_Ledger_GetTransactionByIndex(Server, strMyNymID, MyAcct, strOutbox, nIndex)
                    var lTransNumber       = OT_API_Ledger_GetTransactionNumberByIndex(Server, strMyNymID, MyAcct, strOutbox, nIndex)
                    var lRefNum            = OT_API_Transaction_GetDisplayReferenceToNum(Server, strMyNymID, MyAcct, strTrans)
                    var lAmount            = OT_API_Transaction_GetAmount(Server, strMyNymID, MyAcct, strTrans)
                    var strType            = OT_API_Transaction_GetType(Server, strMyNymID, MyAcct, strTrans)
                    var strSenderUserID    = OT_API_Transaction_GetSenderUserID(Server, strMyNymID, MyAcct, strTrans)
                    var strSenderAcctID    = OT_API_Transaction_GetSenderAcctID(Server, strMyNymID, MyAcct, strTrans)
                    var strRecipientUserID = OT_API_Transaction_GetRecipientUserID(Server, strMyNymID, MyAcct, strTrans)
                    var strRecipientAcctID = OT_API_Transaction_GetRecipientAcctID(Server, strMyNymID, MyAcct, strTrans)
                    
                    var strUserID = strRecipientUserID
                    var strAcctID = strRecipientAcctID
                    
                    var bUserIDExists = VerifyStringVal(strUserID)
                    var bAcctIDExists = VerifyStringVal(strAcctID)
                    
                    var strNewlineSeparator = ""
                    
                    if (bUserIDExists || bAcctIDExists)
                    {  strNewlineSeparator = "\n                                 |" }
                    
                    var strSeparator = (!bUserIDExists && !bAcctIDExists) ? "" : strNewlineSeparator;
                    
                    var strUserDenoter = (bUserIDExists ? "U:" : "")
                    var strAcctDenoter = (bAcctIDExists ? "A:" : "")
                    
                    OT_API_Output(0, nIndex.to_string() + "    ")
                    OT_API_Output(0, lAmount.to_string() + (lAmount.to_string().size() < 3 ? "    " : "   "))
                    OT_API_Output(0, strType)
                    OT_API_Output(0, strType.size() > 10 ? " " : "    ")
                    OT_API_Output(0, lTransNumber.to_string + (lTransNumber.to_string().size() < 2 ? "    " : "   "))
                    OT_API_Output(0, lRefNum.to_string() + (lRefNum.to_string().size() > 2 ? "  " : " ") + "|")
                    OT_API_Output(0, strUserDenoter+strUserID + strSeparator + strAcctDenoter+strAcctID + "\n")
                } // for
            } // VerifyIntVal (nCount)
            
            return 1
        }
    }
    -1
}








def main_show_mail()
{
    if (!VerifyExists("MyNym"))
    {
        return (-1)
    }
    // ----------------------------------
    var nCount = OT_API_GetNym_MailCount(MyNym)
    
    if (!VerifyIntVal(nCount))
    {
        OT_API_Output(0, "Error: bad result from OT_API_GetNym_MailCount for Nym: " + MyNym + "\n")
        return (-1)
    }
    // -------------------------------------------------
    if (0 == nCount)
    {
        OT_API_Output(0, "\n(Mail is empty.)\n\n")
        return 0
    }
    // -------------------------------------------------
    for (var nIndex = 0; nIndex < nCount; ++nIndex)
    {
        var bMailVerified   = OT_API_Nym_VerifyMailByIndex(MyNym, nIndex)
        
        if (!VerifyBoolVal(bMailVerified))
        {
            OT_API_Output(0, "Error: bad result from OT_API_Nym_VerifyMailByIndex at Index: " + nIndex.to_string() + "\n")
            return (-1)
        }
        // -------------------------------------------------
        if (!bMailVerified) // 1 meaning OT_TRUE.
        {
            print("UNVERIFIED mail! At index: " + nIndex.to_string() + "\n")
//          continue
        }
        // -------------------------------------------------
        else
        { print("Mail VERIFIED at index: " + nIndex.to_string() + "\n") }
        // -------------------------------------------------
        var strMailServerID = OT_API_GetNym_MailServerIDByIndex(MyNym, nIndex)
        var strMailSenderID = OT_API_GetNym_MailSenderIDByIndex(MyNym, nIndex)
        var strMailContents = OT_API_GetNym_MailContentsByIndex(MyNym, nIndex)
        
        if (VerifyStringVal(strMailSenderID))
        {
            print("Mail from: " + strMailSenderID + "\n")
        }
        if (VerifyStringVal(strMailServerID))
        {
            print("Server ID: " + strMailServerID + "\n")
        }
        if (VerifyStringVal(strMailContents))
        {
            print("Contents:\n" + strMailContents + "\n\n")
        }
    }
    
    return 1 // return nCount
}

//pScript->chai.add(fun(&OTAPI_Wrap::Nym_RemoveMailByIndex), "OT_API_Nym_RemoveMailByIndex");


// ------------------------------------------------------------------





def main_show_outmail()
{
    if (!VerifyExists("MyNym"))
    {
        return (-1)
    }
    // ----------------------------------
    var nCount = OT_API_GetNym_OutmailCount(MyNym)
    
    if (!VerifyIntVal(nCount))
    {
        OT_API_Output(0, "Error: bad result from OT_API_GetNym_OutmailCount for Nym: " + MyNym + "\n")
        return (-1)
    }
    // -------------------------------------------------
    if (0 == nCount)
    {
        OT_API_Output(0, "\n(Sent mail box is empty.)\n\n")
        return 0
    }
    // -------------------------------------------------
    for (nIndex = 0; nIndex < nCount; ++nIndex)
    {
        var bMailVerified   = OT_API_Nym_VerifyOutmailByIndex(MyNym, nIndex)
        
        if (!VerifyBoolVal(bMailVerified))
        {
            OT_API_Output(0, "Error: bad result from OT_API_Nym_VerifyOutmailByIndex at Index: " + nIndex.to_string() + "\n")
            return (-1)
        }
        // -------------------------------------------------
        if (!bMailVerified) // 1 meaning OT_TRUE.
        {
            print("UNVERIFIED sent (outgoing) mail! At index: " + nIndex.to_string() + "\n")
//          continue
        }
        // -------------------------------------------------
        else
        { print("Sent (outgoing) mail VERIFIED at index: " + nIndex.to_string() + "\n") }
        // -------------------------------------------------
        var strMailServerID    = OT_API_GetNym_OutmailServerIDByIndex(MyNym, nIndex)
        var strMailRecipientID = OT_API_GetNym_OutmailRecipientIDByIndex(MyNym, nIndex)
        var strMailContents    = OT_API_GetNym_OutmailContentsByIndex(MyNym, nIndex)
        
        if (VerifyStringVal(strMailRecipientID))
        {
            print("Mail was sent to: " + strMailRecipientID + "\n")
        }
        if (VerifyStringVal(strMailServerID))
        {
            print("At server ID: " + strMailServerID + "\n")
        }
        if (VerifyStringVal(strMailContents))
        {
            print("Contents:\n" + strMailContents + "\n\n")
        }
    }
    
    return 1
//  return nCount
}

//pScript->chai.add(fun(&OTAPI_Wrap::Nym_RemoveOutmailByIndex), "OT_API_Nym_RemoveOutmailByIndex");



//pScript->chai.add(fun(&OTAPI_Wrap::Nym_RemoveOutpaymentsByIndex), "OT_API_Nym_RemoveOutpaymentsByIndex");

// ------------------------------------------------------------------

//pScript->chai.add(fun(&OTAPI_Wrap::GetNym_OutpaymentsCount), "OT_API_GetNym_OutpaymentsCount");
//pScript->chai.add(fun(&OTAPI_Wrap::GetNym_OutpaymentsContentsByIndex), "OT_API_GetNym_OutpaymentsContentsByIndex");
//pScript->chai.add(fun(&OTAPI_Wrap::GetNym_OutpaymentsRecipientIDByIndex), "OT_API_GetNym_OutpaymentsRecipientIDByIndex");
//pScript->chai.add(fun(&OTAPI_Wrap::GetNym_OutpaymentsServerIDByIndex), "OT_API_GetNym_OutpaymentsServerIDByIndex");

//pScript->chai.add(fun(&OTAPI_Wrap::Nym_VerifyOutpaymentsByIndex), "OT_API_Nym_VerifyOutpaymentsByIndex");




def main_show_outpayments()
{
    if (!VerifyExists("MyNym"))
    {
        return (-1)
    }
    // ----------------------------------
    var nCount = OT_API_GetNym_OutpaymentsCount(MyNym)
    
    if (!VerifyIntVal(nCount))
    {
        OT_API_Output(0, "Error: bad result from OT_API_GetNym_OutpaymentsCount for Nym: " + MyNym + "\n")
        return (-1)
    }
    // -------------------------------------------------
    if (0 == nCount)
    {
        OT_API_Output(0, "\nSent (outgoing) payments box is empty.\n\n")
        return 0
    }
    // -------------------------------------------------
    for (nIndex = 0; nIndex < nCount; ++nIndex)
    {
        var bMailVerified   = OT_API_Nym_VerifyOutpaymentsByIndex(MyNym, nIndex)
        
        if (!VerifyBoolVal(bMailVerified))
        {
            OT_API_Output(0, "Error: bad result from OT_API_Nym_VerifyOutpaymentsByIndex at Index: " + nIndex.to_string() + "\n")
            return (-1)
        }
        // -------------------------------------------------
        if (!bMailVerified) // 1 meaning OT_TRUE.
        {
            print("UNVERIFIED sent (outgoing) payment! At index: " + nIndex.to_string() + "\n")
//          continue
        }
        // -------------------------------------------------
        else
        { print("Sent (outgoing) payment VERIFIED at index: " + nIndex.to_string() + "\n") }
        // -------------------------------------------------
        var strMailServerID    = OT_API_GetNym_OutpaymentsServerIDByIndex(MyNym, nIndex)
        var strMailRecipientID = OT_API_GetNym_OutpaymentsRecipientIDByIndex(MyNym, nIndex)
        var strMailContents    = OT_API_GetNym_OutpaymentsContentsByIndex(MyNym, nIndex)
        
        if (VerifyStringVal(strMailRecipientID))
        {
            print("Payment was sent to: " + strMailRecipientID + "\n")
        }
        if (VerifyStringVal(strMailServerID))
        {
            print("At server ID: " + strMailServerID + "\n")
        }
        if (VerifyStringVal(strMailContents))
        {
            print("Contents:\n" + strMailContents + "\n\n")
        }
    }
    
    return 1
//  return nCount
}

// ------------------------------------------------------------------




def main_add_server()
{
    OT_API_Output(0, "Please paste a server contract, followed by an EOF or a ~ by itself on a blank line:\n\n")
    
    // The reason we accept the tilde ~ on a blank line by itself, is because
    // the EOF, while it works, causes us not to be able to read any more input
    // from stdin. Stdin is considered "closed" for the duration of the run.
    // So the tilde allows us to read multiple times without closing stdin.
    
    var strContract = OT_CLI_ReadUntilEOF() 
    
    if (!VerifyStringVal(strContract))
    {
        OT_API_Output(0, "\n\n Sorry, You must input a server contract, in order to add it to your wallet.\n\n")
        return (-1)
    }
    // ------------
    
    var bAdded = OT_API_AddServerContract(strContract)
    
    if (false == bAdded)
    {
        OT_API_Output(0, "\n\n Sorry, failed. Are you sure that was a server contract?\n\n")
        return (-1)
    }
    
    OT_API_Output(0, "\n\n Success adding server contract to your wallet.\n\n")
    1
}


def main_add_asset()
{
    OT_API_Output(0, "Please paste a currency contract, followed by an EOF or a ~ by itself on a blank line:\n\n")
    
    // The reason we accept the tilde ~ on a blank line by itself, is because
    // the EOF, while it works, causes us not to be able to read any more input
    // from stdin. Stdin is considered "closed" for the duration of the run.
    // So the tilde allows us to read multiple times without closing stdin.
    
    var strContract = OT_CLI_ReadUntilEOF() 
    
    if (!VerifyStringVal(strContract))
    {
        OT_API_Output(0, "\n\n Sorry, You must input a currency contract, in order to add it to your wallet.\n\n")
        return (-1)
    }
    // ------------
    
    var bAdded = OT_API_AddAssetContract(strContract)
    
    if (false == bAdded)
    {
        OT_API_Output(0, "\n\n Sorry, failed. Are you sure that was an asset contract?\n\n")
        return (-1)
    }
    
    OT_API_Output(0, "\n\n Success adding asset contract to your wallet.\n\n")
    1
}



def main_issue_asset()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    
    var strUsage = concat("\n\nUsage: issue_asset.ot --server SERVER_ID --mynym NYM_ID\n\n",
                          "       (NYM_ID must already be the 'contract' key on the new contract.)\n       See create_asset_contract.ot before running this script.\n\n")
    
    OT_API_Output(0, strUsage)
    
    // ----------------------------------------------------
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {   
        OT_API_Output(0, "Please paste a currency contract, followed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        
        var strContract = OT_CLI_ReadUntilEOF() 
        
        if (!VerifyStringVal(strContract))
        {
            OT_API_Output(0, "\n\n Sorry, You must input a currency contract, in order to issue it on an OT server.\n\n")
            return (-1)
        }
        // ------------
        
        var strResponse	= madeEasy.issue_asset_type(Server, MyNym, strContract)
        var nStatus     = VerifyMessageSuccess(strResponse)
        
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        //
        // -1 is error, 
        //  0 is reply received: failure 
        //  1 is reply received: success
        //
        switch(nStatus)
        {
            case (1)
            {
                OT_API_Output(0, "\n\n SUCCESS in issue_asset! Server response:\n\n");
                print(strResponse) // stdout
                break
            }
            case (0)
            {
                OT_API_Output(0, "\n\n FAILURE in issue_asset! Server response:\n\n");
                print(strResponse) // stdout
                break
            }
            default
            {
                OT_API_Output(0, "\n\nError in issue_asset! nStatus is: "+nStatus.to_string()+"\n")
                
                if (VerifyStringVal(strResponse))
                {
                    OT_API_Output(0, "Server response:\n\n")
                    print(strResponse) // stdout
                }
                break
            }
        }
        OT_API_Output(0, "\n\n") //stderr
        
        return (0 == nStatus) ? (-1) : nStatus
    }
    
    return -1
}
































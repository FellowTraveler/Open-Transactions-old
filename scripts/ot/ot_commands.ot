

// NEW RETURN CODE CONVENTION!

// OT API already returns: -1 for error, 0 for "didn't need to do anything" and 1 for success (or larger.)
// All of the below functions follow that convention (they just return the same values.)
//
// But for the OT command line tool, we need to return 0 for success, and non-zero codes for errors.
// This is because it's a UNIX convention and will be expected by anyone writing bash scripts.
// 
// However, I don't want to physically change all the below functions, so I'm going to change the
// opentxs script itself, so that it translates the return value. That way I only have to change it
// in one spot, and we have access to use these scripts both ways.
//
// THE POINT? If you notice these scripts returning 1, which is then interpreted as 0 by bash scripts,
// it's because the script that CALLS these scripts, is doing that translation (for the above described
// reasons.)
//





def main_encode()
{
    OT_API_Output(0, "Please enter multiple lines of input to be encoded, followed by an EOF or a ~ by itself on a blank line:\n\n")

    // The reason we accept the tilde ~ on a blank line by itself, is because
    // the EOF, while it works, causes us not to be able to read any more input
    // from stdin. Stdin is considered "closed" for the duration of the run.
    // So the tilde allows us to read multiple times without closing stdin.
     
    var strInput = OT_CLI_ReadUntilEOF() 

    OT_API_Output(0, "\n\n--------------------------------------\n You entered:\n" + strInput + "\n\n") 

    var strOutput = OT_API_Encode(strInput, true)  // bLineBreaks=true 
     
    // stderr
    OT_API_Output(0, "-------------------------------------- \n Encoded:\n\n")

    // stdout
    if (VerifyStringVal(strOutput))
    {
        print(strOutput)
        // stderr
        OT_API_Output(0, "\n\n")
        return 1
    }

    // stderr
    OT_API_Output(0, "\n\n")

    -1
}


def main_decode()
{
    OT_API_Output(0, "Please enter multiple lines of OT-armored text to be decoded, followed by an EOF or a ~ by itself on a blank line:\n\n")
    
    // The reason we accept the tilde ~ on a blank line by itself, is because
    // the EOF, while it works, causes us not to be able to read any more input
    // from stdin. Stdin is considered "closed" for the duration of the run.
    // So the tilde allows us to read multiple times without closing stdin.
    
    var strInput = OT_CLI_ReadUntilEOF() 
    
    OT_API_Output(0, "\n\n--------------------------------------\n You entered:\n" + strInput + "\n\n") 
    
    var strOutput = OT_API_Decode(strInput, true)  // bLineBreaks=true 
    
    // stderr
    OT_API_Output(0, "--------------------------------------\n Decoded:\n\n")
    
    // stdout
    if (VerifyStringVal(strOutput))
    {
        print(strOutput)
        // stderr
        OT_API_Output(0, "\n\n")
        return 1
    }
    
    // stderr
    OT_API_Output(0, "\n\n")
    
    -1
}




def main_encrypt()
{
    if (VerifyExists("HisNym"))
    {
        
        OT_API_Output(0, "Please enter multiple lines of input to be encrypted,\nfollowed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        
        var strInput = OT_CLI_ReadUntilEOF() 
        
        OT_API_Output(0, "\n\n--------------------------------------\n You entered:\n" + strInput + "\n\n") 
        
        var strOutput = OT_API_Encrypt(HisNym, strInput)  // bLineBreaks=true 
                
        // stdout
        if (VerifyStringVal(strOutput))
        {
            // stderr
            OT_API_Output(0, "-------------------------------------- \n Encrypted:\n\n")
            
            print(strOutput)
            // stderr
            OT_API_Output(0, "\n\n")
            return 1
        }
    }
    
    // "return value"
    -1
}


def main_decrypt()
{
    if (VerifyExists("MyNym"))
    {
        
        OT_API_Output(0, "Please enter multiple lines of input to be decrypted, followed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        
        var strInput = OT_CLI_ReadUntilEOF() 
        
        OT_API_Output(0, "\n\n--------------------------------------\n You entered:\n" + strInput + "\n\n") 
        
        var strOutput = OT_API_Decrypt(MyNym, strInput)  // bLineBreaks=true 
        
        // stdout
        if (VerifyStringVal(strOutput))
        {
            // stderr
            OT_API_Output(0, "-------------------------------------- \n Decrypted:\n\n")
            
            print(strOutput)
            // stderr
            OT_API_Output(0, "\n\n")
            return 1
        }
    }
    
    // "return value"
    -1
}


def main_password_encrypt()
{
    OT_API_Output(0, "Please enter a symmetric key, followed by a ~ by itself on a blank line:\n\n")
    
	// The reason we accept the tilde ~ on a blank line by itself, is because
	// the EOF, while it works, causes us not to be able to read any more input
	// from stdin. Stdin is considered "closed" for the duration of the run.
	// So the tilde allows us to read multiple times without closing stdin.
    
	var strKey = OT_CLI_ReadUntilEOF() 
	
	OT_API_Output(0, "Please enter the plaintext, followed by a ~ by itself on a blank line:\n\n")
    
	var strPlaintext = OT_CLI_ReadUntilEOF() 
    
	if (VerifyStringVal(strKey) && VerifyStringVal(strPlaintext))
	{
		var strCiphertext = OT_API_SymmetricEncrypt(strKey, strPlaintext)
		
        // stdout
        if (VerifyStringVal(strCiphertext))
        {
            // stderr
            OT_API_Output(0, "-------------------------------------- \n strCiphertext:\n\n")
            
            print(strCiphertext)
            // stderr
            OT_API_Output(0, "\n\n")
            return 1
        }
	}
    
    // "return value"
    -1
}



def main_password_decrypt()
{
	OT_API_Output(0, "Please enter a symmetric key, followed by a ~ by itself on a blank line:\n\n")
    
	// The reason we accept the tilde ~ on a blank line by itself, is because
	// the EOF, while it works, causes us not to be able to read any more input
	// from stdin. Stdin is considered "closed" for the duration of the run.
	// So the tilde allows us to read multiple times without closing stdin.
    
	var strKey = OT_CLI_ReadUntilEOF() 
	
	OT_API_Output(0, "Please enter the symmetrically-encrypted ciphertext, followed by a ~ by itself on a blank line:\n\n")
    
	var strCiphertext = OT_CLI_ReadUntilEOF() 
    
	if (VerifyStringVal(strKey) && VerifyStringVal(strCiphertext))
	{
		var strPlaintext = OT_API_SymmetricDecrypt(strKey, strCiphertext)
		
        // stdout
        if (VerifyStringVal(strPlaintext))
        {
            // stderr
            OT_API_Output(0, "-------------------------------------- \n Plaintext:\n\n")
            
            print(strPlaintext)
            // stderr
            OT_API_Output(0, "\n\n")
            return 1
        }
	}
    
    // "return value"
    -1
}






def details_import_nym(strNymImportFile, strOutNymID)
{
    strOutNymID = OT_API_Wallet_ImportNym(strNymImportFile)
    
    var bVerified = VerifyStringVal(strOutNymID)
    
    return bVerified
}


def main_import_nym()
{
    var strUsage = "\n\n USAGE: importnym\n"
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    OT_API_Output(0, "Paste your exported Nym here (for import), followed by a ~ by itself on a blank line: \n")
    
    var strNymFile = OT_CLI_ReadUntilEOF() 
    
    if (!VerifyStringVal(strNymFile))
    {
        return (-1)
    }
    // -----------------------
    var strOutNymID
    var bDone = details_import_nym(strNymFile, strOutNymID)
    
    if (false == bDone)
    {
        OT_API_Output(0, "\n\n FAILED trying to import Nym.\n")
        return (-1)
    }
    else
    {
        OT_API_Output(0, "\n\n SUCCESS importing Nym: " + strOutNymID + "\n\n")
        return 1
    }
    // -----------------------
    return -1
}


def details_export_nym(strNymID)
{
    var strExportedNym = OT_API_Wallet_ExportNym(strNymID)
    
    return strExportedNym
}

def main_export_nym()
{
    var strUsage = "\n\n USAGE: exportnym --mynym NYM_ID\n"
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    if (VerifyExists("MyNym"))
    {	       
        var strExportedNym = details_export_nym(MyNym)
                
        if (!VerifyStringVal(strExportedNym))
        {
            OT_API_Output(0, "\n\n FAILED trying to export Nym: " + MyNym + "\n")
            return (-1)
        }
        else
        {
            OT_API_Output(0, "\n\n SUCCESS exporting Nym: " + MyNym + "\n\n") //stderr
            print(strExportedNym) // stdout
            OT_API_Output(0, "\n") //stderr
            return 1
        }
    }
    
    return -1
}


/*
    static const std::string Wallet_ExportNym (const std::string NYM_ID);
    static const std::string Wallet_ImportNym (const std::string FILE_CONTENTS);
    static const std::string Wallet_ImportCert(const std::string DISPLAY_NAME, 
                                               const std::string FILE_CONTENTS);
    static const std::string Wallet_ExportCert(const std::string NYM_ID);

 */



def details_import_cert(strCertfile, strDisplayName, strOutNymID)
{
    strOutNymID = OT_API_Wallet_ImportCert(strCertfile, strDisplayName)
    
    var bVerified = VerifyStringVal(strOutNymID)
    
    return bVerified
}

def main_import_cert()
{
    var strUsage = concat("\n\n USAGE:  importcert\n",
                              " OPTION:   --args \"name \\\"display name for new Nym in wallet\\\"\"\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    OT_API_Output(0, "Paste your public/private Certificate here (for import as a new Nym), followed by a ~ by itself on a blank line: \n")
    
    var strCertfile = OT_CLI_ReadUntilEOF() 
    
    if (!VerifyStringVal(strCertfile))
    {
        return (-1)
    }
    // -----------------------
    var strDisplayName
    var strDefaultName = "imported cert"
    
    if (VerifyExists("Args", false))
    {
        // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
        //                                  const std::string str_key)
        // 
        // OPTION:   --args "name \"display name for Nym in wallet\""
        // EXAMPLE:  --args "name Jimbob"
        //
        var strNewName = OT_CLI_GetValueByKey( Args, "name" ) 
        
        // ----------------------------------------------
        // Set the values based on the custom arguments, for those found.
        //
        if (VerifyStringVal(strNewName))
        {    strDisplayName = strNewName }
    }            
    // ------------------------------------
    // If the transfer parameters aren't provided, then we
    // ask the user to supply them at the command line.
    //
    if (!VerifyStringVal(strDisplayName))
    {
        OT_API_Output(0, "Enter the display name for the New Nym["+strDefaultName+"]: ")
        strDisplayName  = OT_CLI_ReadLine()
    }
    // ------------------------------------
    var strOutNymID
    var bDone = details_import_cert(strCertfile, strDisplayName, strOutNymID)
    
    if (false == bDone)
    {
        OT_API_Output(0, "\n\n FAILED trying to import Cert.\n")
        return (-1)
    }
    else
    {
        OT_API_Output(0, "\n\n SUCCESS importing Cert for NymID: " + strOutNymID + "\n\n")
        return 1
    }
    // -----------------------
    return -1
}

def details_export_cert(strNymID)
{
    var strExportedCert = OT_API_Wallet_ExportCert(strNymID)
    
    return strExportedCert
}

def main_export_cert()
{
    var strUsage = "\n\n USAGE: exportcert --mynym NYM_ID\n"
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    if (VerifyExists("MyNym"))
    {	       
        var strExportedCert = details_export_cert(MyNym)
        
        if (!VerifyStringVal(strExportedCert))
        {
            OT_API_Output(0, "\n\n FAILED trying to export Cert for NymID: " + MyNym + "\n")
            return (-1)
        }
        else
        {
            OT_API_Output(0, "\n\n SUCCESS exporting Cert for NymID: " + MyNym + "\n\n") //stderr
            print(strExportedCert) // stdout
            OT_API_Output(0, "\n") //stderr
            return 1
        }
    }
    
    return -1
}





def main_change_passphrase()
{
    if (OT_API_Wallet_ChangePassphrase())
    {
        return 1
    }
    
    return -1
}







// ------------------------------
//
// SEND TRANSFER (From one asset account to another.)
//


def details_send_transfer(strAmount, strNote)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()

    // ---------------------------------------------
    // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
    //
    var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
    
    if (!VerifyStringVal(strMyNymID))
    {
        OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
        return (-1)
    }
    // ***************************************************************

    // HERE, WE SEND THE TRANSFER REQUEST TO THE SERVER
    //
    var strResponse = madeEasy.send_transfer(Server, strMyNymID, MyAcct, HisAcct, strAmount, strNote) 
    var strAttempt  = "send_transfer"
    /*
     int notarizeTransfer(   const std::string SERVER_ID,
                             const std::string USER_ID,
                             const std::string ACCT_FROM,
                             const std::string ACCT_TO,
                             const std::string AMOUNT,
                             const std::string NOTE);
     */
    // ***************************************************************
    
    // HERE, WE INTERPRET THE SERVER REPLY, WHETHER SUCCESS, FAIL, OR ERROR...
    
    var nInterpretReply = InterpretTransactionMsgReply(Server, strMyNymID, MyAcct, strAttempt, strResponse)
    
    if (1 == nInterpretReply)
    {    
        // Download all the intermediary files (account balance, inbox, outbox, etc)
        // since they have probably changed from this operation.
        //
        var bRetrieved = madeEasy.retrieve_account(Server, strMyNymID, MyAcct, true) //bForceDownload defaults to false.
        
        OT_API_Output(0, "Server response ("+strAttempt+"): SUCCESS sending transfer!\n")
        OT_API_Output(0, (bRetrieved ? "Success" : "Failed") + " retrieving intermediary files for account.\n")
    }
    
    // ***************************************************************
    //
    // Return status to caller.
    //
    return nInterpretReply  
}


// HERE, WE GET ALL THE ARGUMENTS TOGETHER,
// and then call the above function.
//
def main_transfer()
{
    var strUsage1 = concat("\n\n  USAGE: transfer --myacct YOUR_ASSET_ACCT --hisacct RECIPIENT_ASSET_ACCT\n\n",
                           "Also NECESSARY: --args \"amount PUT_AMOUNT_HERE\"\n")
    var strUsage = concat(strUsage1,
                          "And OPTIONALLY: --args \"memo \\\"Just a memo for the transfer.\\\"\"\n\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server") && VerifyExists("MyAcct") && VerifyExists("HisAcct"))
    {	
        // strAmount and strNote...
        //
        var strAmount    = "0" // must be >= 1
        var strNote      = ""  // can be blank
        // ------------------------------------        
        var strDefaultAmount  = "10"  // must be >= 1
        var strDefaultNote    = "(blank memo field)"   // can be blank
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "amount 1"
            // EXAMPLE:  --args "amount 15 note \"Just a memo for the transfer.\""
            //
            var strNewAmount = OT_CLI_GetValueByKey( Args, "amount"    ) // any integer value
            var strNewNote   = OT_CLI_GetValueByKey( Args, "memo"  )     // optional memo field
            
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewAmount))
            {    strAmount = strNewAmount }
            if (VerifyStringVal(strNewNote))
            {    strNote = strNewNote }
        }            
        // ------------------------------------
        // If the transfer parameters aren't provided, then we
        // ask the user to supply them at the command line.
        //
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {
            OT_API_Output(0, "Enter the amount as integer["+strDefaultAmount+"]: ")
            strAmount        = OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strNote))
        {
            OT_API_Output(0, "Optionally, enter a memo on a single line["+strDefaultNote+"]: ")
            strNote	= OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {    strAmount = strDefaultAmount }
        if (!VerifyStringVal(strNote))
        {    strNote = strDefaultNote }
        // ----------------------------------------------    
        
        return details_send_transfer(strAmount, strNote)
    }
    
    return -1
}

// -----------------------


// SET NAME!!



def main_edit_nym()
{
    var strUsage = concat("\n\n USAGE: editnym --mynym YOUR_NYM_ID\n",
                              "Also optionally:         --args \"label \\\"PUT LABEL HERE\\\"\"\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("MyNym"))
    {	
        var strLabel    = ""
        // ------------------------------------        
        var strDefaultLabel    = "(blank label)"   // can be blank
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "label \"FT's test Nym\""
            //
            var strNewLabel   = OT_CLI_GetValueByKey( Args, "label"  )  // optional label field
            // ----------------------------------------------
            // Set the value based on the custom argument.
            //
            if (VerifyStringVal(strNewLabel))
            {    strLabel = strNewLabel }
        }            
        // ------------------------------------
        // If the label isn't provided, then we ask the
        // user to supply it at the command line.
        //
        if (!VerifyStringVal(strLabel))
        {
            OT_API_Output(0, "Enter MyNym's new label ["+strDefaultLabel+"]: ")
            strLabel        = OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strLabel))
        {    strLabel = strDefaultLabel }
        // ----------------------------------------------    
        
        var bSet = OT_API_SetNym_Name(MyNym, MyNym, strLabel)
        
        if (false == bSet)
        {
            OT_API_Output(0, "\n\n FAILED trying to set MyNym's label to: " + strLabel + "\n")
            OT_API_Output(0, "MyNym ID: " + MyNym + "\n\n")
            return (-1)
        }
        else
        {
            OT_API_Output(0, "\n\n SUCCESS setting MyNym's label to: " + strLabel + "\n")
            OT_API_Output(0, "MyNym ID: " + MyNym + "\n\n")
            return 1
        }
    }
    
    return -1
}

// -----------------------



def main_edit_account()
{
    var strUsage = concat("\n\n USAGE: editacct --myacct YOUR_ACCT_ID\n",
                              "Also optionally:          --args \"label \\\"PUT LABEL HERE\\\"\"\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        

    if (VerifyExists("MyAcct"))
    {	
        // ---------------------------------------------
        // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
        //
        var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
        
        if (!VerifyStringVal(strMyNymID))
        {
            OT_API_Output(0, "\n\nFailure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
            return (-1)
        }
        if (VerifyExists("MyNym") && !(MyNym == strMyNymID))
        {
            OT_API_Output(0, "\n\nFailure: MyNym was provided, but didn't match the Nym who owns MyAcct. To override, use: --mynym "+strMyNymID+"\n\n")
            return (-1)
        }
        // ***************************************************************
        //
        var strLabel    = ""
        // ------------------------------------        
        var strDefaultLabel    = "(blank label)"   // can be blank
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "label \"FT's issuer account\""
            //
            var strNewLabel   = OT_CLI_GetValueByKey( Args, "label"  )  // optional label field
            // ----------------------------------------------
            // Set the value based on the custom argument.
            //
            if (VerifyStringVal(strNewLabel))
            {    strLabel = strNewLabel }
        }            
        // ------------------------------------
        // If the label isn't provided, then we ask the
        // user to supply it at the command line.
        //
        if (!VerifyStringVal(strLabel))
        {
            OT_API_Output(0, "Enter MyAcct's new label ["+strDefaultLabel+"]: ")
            strLabel        = OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strLabel))
        {    strLabel = strDefaultLabel }
        // ----------------------------------------------    
        
        var bSet = OT_API_SetAccountWallet_Name(MyAcct, strMyNymID, strLabel)
        
        if (false == bSet)
        {
            OT_API_Output(0, "\n\n FAILED trying to set MyAcct's label to: " + strLabel + "\n")
            OT_API_Output(0, "MyAcct ID: " + MyAcct     + "\n")
            OT_API_Output(0, " MyNym ID: " + strMyNymID + "\n\n")
            return (-1)
        }
        else
        {
            OT_API_Output(0, "\n\n SUCCESS setting MyAcct's label to: " + strLabel + "\n")
            OT_API_Output(0, "MyAcct ID: " + MyAcct     + "\n")
            OT_API_Output(0, " MyNym ID: " + strMyNymID + "\n\n")
            return 1
        }
    }
    
    return -1
}

// -----------------------


def main_edit_asset()
{
    var strUsage = concat("\n\n USAGE: editasset --mypurse ASSET_TYPE_ID\n",
                              "Also optionally:           --args \"label \\\"PUT LABEL HERE\\\"\"\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("MyPurse"))
    {	
        var strLabel    = ""
        // ------------------------------------        
        var strDefaultLabel    = "(blank label)"   // can be blank
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "label \"Silver Grams\""
            //
            var strNewLabel   = OT_CLI_GetValueByKey( Args, "label"  )  // optional label field
            // ----------------------------------------------
            // Set the value based on the custom argument.
            //
            if (VerifyStringVal(strNewLabel))
            {    strLabel = strNewLabel }
        }            
        // ------------------------------------
        // If the label isn't provided, then we ask the
        // user to supply it at the command line.
        //
        if (!VerifyStringVal(strLabel))
        {
            OT_API_Output(0, "Enter MyPurse's new label ["+strDefaultLabel+"]: ")
            strLabel        = OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strLabel))
        {    strLabel = strDefaultLabel }
        // ----------------------------------------------    
        
        var bSet = OT_API_SetAssetType_Name(MyPurse, strLabel)
        
        if (false == bSet)
        {
            OT_API_Output(0, "\n\n FAILED trying to set MyPurse's label to: " + strLabel + "\n")
            OT_API_Output(0, "MyPurse (AssetTypeID): " + MyPurse + "\n\n")
            return (-1)
        }
        else
        {
            OT_API_Output(0, "\n\n SUCCESS setting MyPurse's label to: " + strLabel + "\n")
            OT_API_Output(0, "MyPurse (AssetTypeID): " + MyPurse + "\n\n")
            return 1
        }
    }
    
    return -1
}

// -----------------------


def main_edit_server()
{
    var strUsage = concat("\n\n USAGE: editserver --server SERVER_ID\n",
                              "Also optionally:            --args \"label \\\"PUT LABEL HERE\\\"\"\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server"))
    {	
        var strLabel    = ""
        // ------------------------------------        
        var strDefaultLabel    = "(blank label)"   // can be blank
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "label \"localhost server\""
            //
            var strNewLabel   = OT_CLI_GetValueByKey( Args, "label"  )  // optional label field
            // ----------------------------------------------
            // Set the value based on the custom argument.
            //
            if (VerifyStringVal(strNewLabel))
            {    strLabel = strNewLabel }
        }            
        // ------------------------------------
        // If the label isn't provided, then we ask the
        // user to supply it at the command line.
        //
        if (!VerifyStringVal(strLabel))
        {
            OT_API_Output(0, "Enter Server's new label ["+strDefaultLabel+"]: ")
            strLabel        = OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strLabel))
        {    strLabel = strDefaultLabel }
        // ----------------------------------------------    
        
        var bSet = OT_API_SetServer_Name(Server, strLabel)
        
        if (false == bSet)
        {
            OT_API_Output(0, "\n\n FAILED trying to set Server's label to: " + strLabel + "\n")
            OT_API_Output(0, "Server ID: " + Server + "\n\n")
            return (-1)
        }
        else
        {
            OT_API_Output(0, "\n\n SUCCESS setting Server's label to: " + strLabel + "\n")
            OT_API_Output(0, "Server ID: " + Server + "\n\n")
            return 1
        }
    }
    
    return -1
}

// -----------------------
















def main_sendmsg()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    // Just to show how easy it is, let's try a "send_user_message" message.
    //
    var strUsage = "\n\n FYI, USAGE: sendmsg --mynym <YOUR_NYM_ID> --hisnym <RECIPIENT_NYM_ID>\n\n"

    OT_API_Output(0, strUsage)

    if (VerifyExists("Server") && VerifyExists("MyNym") && VerifyExists("HisNym"))
    {
        OT_API_Output(0, "Please enter your message on multiple lines, optionally beginning with a \"Subject: \" line.\n")
        OT_API_Output(0, "Use Ctrl-C to cancel, otherwise finish your message with an EOF or a ~ by itself on a blank line:\n\n")

        var strMessage = OT_CLI_ReadUntilEOF()
        
        // Send the request.
        //
        var strResponse = madeEasy.send_user_msg(Server, MyNym, HisNym, strMessage)

        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  
        // 
        // Instead, simply check for success or failure:
        //
        if (1 != VerifyMessageSuccess(strResponse))
        {
            OT_API_Output(0, "send_user_msg: Failed.\n");
        }
        else
        {
            OT_API_Output(0, "Success in send_user_msg! Server response:\n\n")
            print(strResponse)
            OT_API_Output(0, "\nSuccess in send_user_msg.\n\n")
            return 1
        }
    }
    
    return -1
}





def details_write_cheque(strCheque, bIsInvoice) // strCheque is output.
{
    var MsgUtil	    = Utility()
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // --------------------------------------------------------------------
    if (VerifyExists("MyAcct") && VerifyExists("HisNym"))
    {
        // ---------------------------------------------
        // Look up the NymID based on MyAcct
        //
        var strMyNymID    = OT_API_GetAccountWallet_NymID(MyAcct)
        
        if (!VerifyStringVal(strMyNymID))
        {
            OT_API_Output(0, "Failure: Unable to find NymID (for sender) based on myacct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
            return (-1)
        }
        if (VerifyExists("MyNym", false) && !(MyNym == strMyNymID))
        {
            OT_API_Output(0, "\n\nFailure: MyNym was provided ("+MyNym+"), but didn't match the Nym who owns MyAcct. To override, use: --mynym "+strMyNymID+"\n\n")
            return (-1)
        }
        // ---------------------------------------------
        // Look up the ServerID based on MyAcct
        //
        var strMyServerID = OT_API_GetAccountWallet_ServerID(MyAcct)
        
        if (!VerifyStringVal(strMyServerID))
        {
            OT_API_Output(0, "Failure: Unable to find ServerID based on myacct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Server based on the account.\n\n")
            return (-1)
        }
        if (VerifyExists("Server", false) && !(Server == strMyServerID))
        {
            OT_API_Output(0, "\n\nFailure: Server was provided ("+Server+"), but didn't match the Server where MyAcct is based. To override, use: --server "+strMyServerID+"\n\n")
            return (-1)
        }
        // ***************************************************************
        //
        // When we pass in HisNym at the command line, using this option:  --hisnym HIS_NYM_ID
        // then OT internally TRIES to look it up on the wallet (and someday on the address
        // book as well) in abbreviated or name form, in order to substitute it with the ACTUAL
        // full NymID, before passing it into the script where we are now. If nothing is found,
        // then it just passes through the ID so we have a chance to download the pubkey and
        // verify that it actually exists.
        //
        // Therefore, if the full "HisNym" ID hasn't ALREADY been found by now, that means we
        // already couldn't find it via abbreviation or name, and therefore we will HAVE to download
        // it from the server since we don't have it already. (And therefore we will NEED to know the
        // FULL ID, since we cannot download a pubkey from a server based on a partial ID.)
        //
        // The point is that when we get here, there's no need to worry about searching for a partial
        // or abbreviated version, and no need to ask load_or_retrieve_pubkey to somehow translate HisNym
        // to a full ID. That would have already happened by now, if one were available. So at this point
        // we basically have to assume the user passed the full and correct ID, and if it's not in the
        // wallet already, then load_or_retrieve_pubkey can go ahead and try to download it as if it is
        // the full and correct ID. If it fails, it fails.
        //
        var strRecipientPubkey = madeEasy.load_or_retrieve_pubkey(strMyServerID, strMyNymID, HisNym)
        // Note: even thogh send_user_payment already calls load_or_retrieve_pubkey, we do it
        // here anyway, BEFORE trying to write the cheque. (No point writing a cheque to HisNym until
        // we're sure it's real...)
        //
        if (!VerifyStringVal(strRecipientPubkey))
        {
            OT_API_Output(0, "\n\nFailure: Unable to load or download pubkey for HisNym based on given value ("+HisNym+"). To override, use: --hisnym HIS_NYM_ID\n\n")
            return (-1)
        }
        // -------------------------------------------------------
        // Make sure we have at least one transaction number (to write the cheque...)
        //
        var nTransCount = OT_API_GetNym_TransactionNumCount(strMyServerID, strMyNymID)
        
        if (nTransCount < 1) // Need at least 1 transaction number, to write a cheque.
        {
            OT_API_Output(0, "I don't have enough transaction numbers to perform this transaction. Grabbing more now...\n")
            // ---------------------------------------
            var  bGotten = MsgUtil.getTransactionNumbers(strMyServerID, strMyNymID)
            if (!bGotten)
            {
                OT_API_Output(0, "\n\nFailure: Unable to get a new transaction number for the Nym ("+strMyNymID+") who owns account ("+MyAcct+").\n\n")
                return (-1)
            }
        }
        // -------------------------------------------------------
        // - At this point we have MyAcct writing a cheque to HisNym.
        // - We have strMyServerID and strMyNymID and we know they match MyAcct.
        // (And we know they match --server and --mynym as well, otherwise the
        // user would have been be forced to override at the command line before 
        // allowing him to continue.)
        // - We know that HisNym is a valid enough ID that we were able to load
        // his public key, or download it and THEN load it up. By this point it was
        // successful either way.
        // - We know that the Nym has at least 1 valid transaction number, with
        // which to write the cheque. (If he didn't, we would have downloaded it in
        // the above block.)
        // - Therefore let's collect all the other cheque-related data, and write
        // the actual cheque, and return it to the caller.
        // -------------------------------------------------------
        var strDefaultAmount = "1"       // smallest possible amount.
        var strDefaultMemo   = "(memo field)" 
        var nDefaultLength   = 2592000   // 30 days
        
        var strAmount = "0"
        var strMemo   = ""  // empty
        var nLength   = 0   
        // ------------------------------------
        if (VerifyExists("Args"))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "amount 100 memo \"my share for the BBQ\""
            //
            var strNewAmount = OT_CLI_GetValueByKey( Args, "amount" )
            var strNewMemo   = OT_CLI_GetValueByKey( Args, "memo" )
            var strNewLength = OT_CLI_GetValueByKey( Args, "validfor" )
            
            if (VerifyStringVal(strNewMemo)) 
            { strMemo = strNewMemo }
            
            if (VerifyStringVal(strNewAmount) && (strNewAmount.to_int() > 0))
            { strAmount = strNewAmount }
            
            if (VerifyStringVal(strNewLength) && (strNewLength.to_int() > 0))
            { nLength = strNewLength.to_int() }
        }
        
        // ------------------------------------
        // If the transfer parameters aren't provided, then we
        // ask the user to supply them at the command line.
        //
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {
            OT_API_Output(0, "Enter the amount as integer["+strDefaultAmount+"]: ")
            strAmount  = OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strMemo))
        {
            OT_API_Output(0, "Optionally, enter a note on a single line["+strDefaultMemo+"]: ")
            strMemo	= OT_CLI_ReadLine()
        }
        if (!VerifyIntVal(nLength) || (nLength < 1))
        {
            OT_API_Output(0, "Enter the 'valid for' time period, in seconds (default is 30 days.) ["+nDefaultLength.to_string()+"]: ")
            var strTemp	= OT_CLI_ReadLine()
            nLength = strTemp.to_int()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {    strAmount = strDefaultAmount }
        
        if (!VerifyStringVal(strMemo))
        {    strMemo = strDefaultMemo }
        
        if (!VerifyIntVal(nLength) || (nLength < 1))
        {    nLength = nDefaultLength }
        // ----------------------------------------------    
        
        // Todo: use Args feature here to allow an option to override nLength.
        // If it's not used, go with the default of 30 days (above.)
        
        var strFrom = OT_API_GetTime()
        var   nTo   = strFrom.to_int() + nLength
        var strTo   = nTo.to_string()
        
        if (bIsInvoice)
        {
            var nTempAmount = ((-1) * (strAmount.to_int()))
            strAmount = nTempAmount.to_string()
        }
        
//      std::string OT_API_WriteCheque ( const std::string SERVER_ID,
//										 const std::string CHEQUE_AMOUNT, 
//										 const std::string VALID_FROM, 
//										 const std::string VALID_TO,
//										 const std::string SENDER_ACCT_ID,
//										 const std::string SENDER_USER_ID,
//										 const std::string CHEQUE_MEMO, 
//										 const std::string RECIPIENT_USER_ID);
        
        strCheque = OT_API_WriteCheque (strMyServerID,
                                        strAmount,
                                        strFrom,
                                        strTo,
                                        MyAcct,
                                        strMyNymID,
                                        strMemo,
                                        HisNym)
        
        
        // TODO:  Record it in the records?
        
        return 1
    }
    
    // "return value"
    -1
}




def main_write_cheque()
{
    var strUsage1 = "Usage:  writecheque  --myacct <MY_ACCT_ID> --hisnym <HIS_NYM_ID>\n"
    var strUsage2 = "This command WRITES but DOES NOT SEND the\ncheque. (Use sendcheque for that.)\n"
    var strUsage = concat(strUsage1+"Optionally: --args \"memo \\\"one-line memo allowed here.\\\" amount AMOUNT\"\n",
                          "Additionally: --args \"validfor IN_SECONDS\" \n"+strUsage2)
    
    OT_API_Output(0, strUsage)
    // ---------------------------------------
    var strCheque  = ""
    var nReturnVal = details_write_cheque(strCheque, false) //bIsInvoice=false
    // ---------------------------------------
    if ((1 == nReturnVal) && VerifyStringVal(strCheque))
    {
        // stderr
        OT_API_Output(0, "\n-------------------------------------------\n the cheque:\n\n")
        // stdout
        print(strCheque)
        // stderr
        OT_API_Output(0, "\n")
    }
    
    nReturnVal
}





def main_write_invoice()
{
    var strUsage1 = "Usage:  writeinvoice  --myacct <MY_ACCT_ID> --hisnym <HIS_NYM_ID>\n"
    var strUsage2 = "This command WRITES but DOES NOT SEND the\ninvoice. (Use sendinvoice for that.)\n"
    var strUsage = concat(strUsage1+"Optionally: --args \"memo \\\"one-line memo allowed here.\\\" amount AMOUNT\"\n",
                          "Additionally: --args \"validfor IN_SECONDS\" \n"+strUsage2)
    OT_API_Output(0, strUsage)
    // ---------------------------------------
    var strCheque  = ""
    var nReturnVal = details_write_cheque(strCheque, true) //bIsInvoice=true
    // ---------------------------------------
    if ((1 == nReturnVal) && VerifyStringVal(strCheque))
    {
        // stderr
        OT_API_Output(0, "\n-------------------------------------------\n the invoice:\n\n")
        // stdout
        print(strCheque)
        // stderr
        OT_API_Output(0, "\n")
    }
    
    nReturnVal
}





def main_sendcheque()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    var strUsage1 = "Usage:  sendcheque  --myacct <MY_ACCT_ID> --hisnym <RECIPIENT_NYM_ID>\n"
    var strUsage2 = "This command WRITES AND SENDS\nthe cheque. (Use 'writecheque', not 'sendcheque', if you don't want it to be immediately SENT.)\n"
    var strUsage = concat(strUsage1+"Optionally: --args \"memo \\\"one-line memo allowed here.\\\" amount AMOUNT\"\n",
                          "Additionally: --args \"validfor IN_SECONDS\" \n"+strUsage2)
    
    OT_API_Output(0, strUsage)
    // ---------------------------------------
    var strCheque  = ""
    var nReturnVal = details_write_cheque(strCheque, false) //bIsInvoice=false
    // ---------------------------------------
    if ((1 == nReturnVal) && VerifyStringVal(strCheque))
    {
        // stderr
        OT_API_Output(0, "\n-------------------------------------------\n the cheque:\n\n")
        // stdout
        print(strCheque)
        // stderr
        OT_API_Output(0, "\n")
        // -----------------------------
        // TODO: Store a copy in outpayments box (OR VERIFY THAT IT'S ALREADY BEING DONE, WHICH I BELIEVE THAT IT IS.)
        // -----------------------------
        var strServerID       = OT_API_Instrmnt_GetServerID       (strCheque)
        var strSenderNymID    = OT_API_Instrmnt_GetSenderUserID   (strCheque)
        var strRecipientNymID = OT_API_Instrmnt_GetRecipientUserID(strCheque)

        if (!VerifyStringVal(strServerID))
        {
            OT_API_Output(0, "Unable to retrieve a Server ID from this cheque! Very strange. (Failure.)\n")
            return (-1)
        }
        if (!VerifyStringVal(strSenderNymID))
        {
            OT_API_Output(0, "Unable to retrieve a Sender Nym ID from this cheque! Very strange. (Failure.)\n")
            return (-1)
        }
        if (!VerifyStringVal(strRecipientNymID))
        {
            OT_API_Output(0, concat("Unable to retrieve a Recipient Nym ID from this cheque! Very strange. (Failure.)\n",
                                    "(Although it's fine to WRITE a cheque with no recipient, still need the ID to SEND one.)\n"))
            return (-1)
        }
        // -----------------------------------------------------------
        var strResponse = madeEasy.send_user_payment(strServerID, strSenderNymID, strRecipientNymID, strCheque)

        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!
        //
        // Instead, simply check for success or failure:
        //
        nReturnVal = VerifyMessageSuccess(strResponse)
        
        if (1 != nReturnVal)
        {
            OT_API_Output(0, "sendcheque: Failed.\n");
        }
        else
        {
            OT_API_Output(0, "Success in sendcheque! Server response:\n\n")
            print(strResponse)
            OT_API_Output(0, "(Success in sendcheque)\n")
            return 1
        }
    }
    
    nReturnVal
}











def main_sendinvoice()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    var strUsage1 = "Usage:  sendinvoice  --myacct <MY_ACCT_ID> --hisnym <RECIPIENT_NYM_ID>\n"
    var strUsage2 = "This command WRITES AND SENDS the invoice. (Use 'writeinvoice', not 'sendinvoice',\nif you don't want it to be immediately SENT.)\n"
    var strUsage = concat(strUsage1+"Optionally: --args \"memo \\\"one-line memo allowed here.\\\" amount AMOUNT\"\n",
                          "Additionally: --args \"validfor IN_SECONDS\" \n"+strUsage2)
    
    OT_API_Output(0, strUsage)
    // ---------------------------------------
    var strCheque  = ""
    var nReturnVal = details_write_cheque(strCheque, true) //bIsInvoice=true
    // ---------------------------------------
    if ((1 == nReturnVal) && VerifyStringVal(strCheque))
    {
        // stderr
        OT_API_Output(0, "\n-------------------------------------------\n the invoice:\n\n")
        // stdout
        print(strCheque)
        // stderr
        OT_API_Output(0, "\n")
        // -----------------------------
        // TODO: Store a copy in outpayments box (OR VERIFY THAT IT'S ALREADY BEING DONE, WHICH I BELIEVE THAT IT IS.)
        // -----------------------------
        var strServerID       = OT_API_Instrmnt_GetServerID       (strCheque)
        var strSenderNymID    = OT_API_Instrmnt_GetSenderUserID   (strCheque)
        var strRecipientNymID = OT_API_Instrmnt_GetRecipientUserID(strCheque)

        if (!VerifyStringVal(strServerID))
        {
            OT_API_Output(0, "Unable to retrieve a Server ID from this invoice! Very strange. (Failure.)\n")
            return (-1)
        }
        if (!VerifyStringVal(strSenderNymID))
        {
            OT_API_Output(0, "Unable to retrieve a Sender Nym ID from this invoice! Very strange. (Failure.)\n")
            return (-1)
        }
        if (!VerifyStringVal(strRecipientNymID))
        {
            OT_API_Output(0, concat("Unable to retrieve a Recipient Nym ID (Endorsee) from this invoice! Very strange. (Failure.)\n",
                                    "(Although it's fine to WRITE a invoice with no endorsee, still need the ID to SEND it.)\n"))
            return (-1)
        }
        // -----------------------------------------------------------
        var strResponse = madeEasy.send_user_payment(strServerID, strSenderNymID, strRecipientNymID, strCheque)

        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!
        //
        // Instead, simply check for success or failure:
        //
        nReturnVal = VerifyMessageSuccess(strResponse)
        
        if (1 != nReturnVal)
        {
            OT_API_Output(0, "sendinvoice: Failed.\n");
        }
        else
        {
            OT_API_Output(0, "Success in sendinvoice! Server response:\n\n")
            print(strResponse)
            OT_API_Output(0, "(Success in sendinvoice)\n")
            return 1
        }
    }
    
    nReturnVal
}




def details_create_offer(strScale, strMinIncrement, strQuantity, strPrice, bSelling) : strScale.is_type(string_type) && strMinIncrement.is_type(string_type) && strQuantity.is_type(string_type) && strPrice.is_type(string_type) && bSelling.is_type(bool_type)
{
    // NOTE: The top half of this function has nothing to do with placing a new offer.
    // Instead, as a convenience for knotwork, it first checks to see if there are any
    // existing offers within certain parameters based on this new one, and removes them
    // if so. Only then, after that is done, does it actually place the new offer.
    // (Meaning: most of the code you see here at first is not actually necessary for
    // placing offers, but was done at the request of a server operator.)
    //
    var strLocation = "details_create_offer"
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    
    var strMyNymID  = OT_API_GetAccountWallet_NymID(MyAcct)
    var strMyNymID2 = OT_API_GetAccountWallet_NymID(HisAcct)
    
    if (!VerifyStringVal(strMyNymID) || !VerifyStringVal(strMyNymID2) || (strMyNymID != strMyNymID2))
    {
        OT_API_Output(0, "You must supply myacct as your asset account, and hisacct as your currency account.\n")
        OT_API_Output(0, "Also, both accounts must be owned by the same Nym (you.)\n\n")
        return (-1)
    }
    // ----------------------------------------------
    
    var strMyServerID  = OT_API_GetAccountWallet_ServerID(MyAcct)
    var strMyServerID2 = OT_API_GetAccountWallet_ServerID(HisAcct)
    
    if (!VerifyStringVal(strMyServerID) || !VerifyStringVal(strMyServerID2) || (strMyServerID != strMyServerID2) )
    {
        OT_API_Output(0, "Both accounts must be on the same server.\n")
        return (-1)
    }
    // Below this point we're safe to use Server.
    // ----------------------------------------------
    
    // We're about to load up the Nym's market offers so we can see if there are
    // any we should cancel before placing this new offer.
    //
    // Therefore, I'm going to download the Nym's market offers before loading them
    // up, in case we don't even have the current list of them.

    details_get_nym_market_offers(strMyServerID, strMyNymID)
    
    // ----------------------------------------------    
    /*
     me: How about this — when you do "opentxs newoffer" I can alter that 
     script to automatically cancel any sell offers for a lower amount 
     than my new buy offer, if they're on the same market at the same scale.
     and vice versa. Vice versa meaning, cancel any bid offers for a higher
     amount than my new sell offer.

     knotwork: yeah that would work.
     
     So when placing a buy offer, check all the other offers I already have at the same scale,
     same asset and currency ID. (That is, the same "market" as denoted by strMapKey in "opentxs showmyoffers")
     For each, see if it's a sell offer and if so, if the amount is lower than the amount on
     the new buy offer, then cancel that sell offer from the market. (Because I don't want to buy-high, sell low.)
     
     Similarly, if placing a sell offer, then check all the other offers I already have at the
     same scale, same asset and currency ID, (the same "market" as denoted by strMapKey....) For
     each, see if it's a buy offer and if so, if the amount is higher than the amount of my new
     sell offer, then cancel that buy offer from the market. (Because I don't want some old buy offer
     for $10 laying around for the same stock that I'm SELLING for $8! If I dump 100 shares, I'll receive
     $800--I don't want my software to automatically turn around and BUY those same shares again for $1000!
     That would be a $200 loss.)
     
     This is done here:
     */
        
    var offerList := loadNymOffers(strMyServerID, strMyNymID)
    
    if (!VerifyStorable(offerList, "OTDB_OfferListNym"))
    {
        OT_API_Output(0, strLocation+": Unable to load up a (nym) offerList from local storage. Probably doesn't exist.\n")
    }
    // ----------------------------------
    else
    {
        // LOOP THROUGH THE OFFERS and sort them into a map_of_maps, key is: scale-assetID-currencyID
        // the value for each key is a sub-map, with the key: transaction ID and value: the offer data itself.
        //
        var nCount = offerList.GetOfferDataNymCount() // size_t
        var nTemp  = nCount // so it's created as size_t
        
        if (VerifyIntVal(nCount) && (nCount > 0))
        {        
            var map_of_maps := convert_offerlist_to_maps(offerList)
            
            if (!VerifyType(map_of_maps, "Map"))
            {
                OT_API_Output(0, strLocation+": Unable to convert offer list to map of offers. Perhaps it's empty?\n")
            }
            else
            {
                // -------------------------------------------        
                // find_strange_offers is called for each offer, for this nym,
                // as it iterates through the maps. When it's done, extra_vals.the_vector 
                // will contain a vector of all the transaction numbers for offers that we 
                // should cancel, before placing the new offer. (Such as an offer to sell for
                // 30 clams when our new offer buys for 40...)
                //
                var extra_vals = the_lambda_struct()
                
                extra_vals.the_asset_acct    = MyAcct
                extra_vals.the_currency_acct = HisAcct
                extra_vals.the_scale         = strScale
                extra_vals.the_price         = strPrice
                extra_vals.bSelling          = bSelling        
                // ----------------------------------
                var nIterated = iterate_nymoffers_maps(map_of_maps, find_strange_offers, extra_vals)
                
                if ((-1) == nIterated)
                {
                    OT_API_Output(0, strLocation+": Error trying to iterate nym's offers.\n")
                    return (-1)
                }
                // ----------------------------------
                // Okay -- if there are any offers we need to cancel, extra_vals.the_vector now contains
                // the transaction number for each one. Let's remove them from the market before
                // starting up the new offer...
                //
                
                OT_API_Output(0, strLocation+": FYI, about to cancel at least one market offer, before placing the new one, due to price inconsistencies between the two...\n")
                
                while (extra_vals.the_vector.size() > 0)
                {
                    OT_API_Output(0, strLocation+": Canceling market offer with transaction number: " + extra_vals.the_vector[0] + "\n")
                    
                    details_cancel_offer(strMyServerID, strMyNymID, MyAcct, extra_vals.the_vector[0])
                    extra_vals.the_vector.erase_at(0)
                }
            }
        }
        else
        {
            OT_API_Output(0, strLocation+": FYI, there don't seem to be any existing offers for this nym, so I won't be erasing any older ones.\n")
        }
    }
    // ********************************************************************
    
    // OKAY! Now that we've cleaned out any undesirable offers, let's place the
    // the offer itself!    
    
    // ----------------------------------------------
    //
    // Send the "create offer" transaction.
    //
    var strResponse	= madeEasy.create_market_offer(strMyServerID, strMyNymID, MyAcct, HisAcct, strScale, strMinIncrement, strQuantity, strPrice, bSelling)
    var strAttempt  = "create_market_offer"
    // ----------------------------------------------
    // NOTICE: No need here to deal with retries, timeouts, request number,
    // syncing transaction number, download / process nymbox, etc! It's all
    // handled at a lower level!  Instead, simply check for success or failure:
    
    // ***************************************************************
    
    var nInterpretReply = InterpretTransactionMsgReply(strMyServerID, strMyNymID, MyAcct, strAttempt, strResponse)
    
    if (1 == nInterpretReply)
    {    OT_API_Output(0, "Server response ("+strAttempt+"): SUCCESS placing market offer!\n\n") }
    
    return nInterpretReply
}



def main_create_offer()
{
    var strUsage = concat("\n\n USAGE: newoffer --myacct <YOUR_ASSET_ACCT> --hisacct <YOUR_CURRENCY_ACCT>\n\n",
                          " Optional: --args \"type <bid|ask> scale 1 quantity 100 price 101\"\n\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("MyAcct") && VerifyExists("HisAcct"))
    {
        var strScale               = "0" // must be 1, 10, 100, etc
        var strMinIncrement        = "0" // must be 1, 2, 3, etc
        var strQuantity            = "0" // must be >= 1
        var strPrice               = "0" // must be >= 1
        var strType                = ""  // must be bid or ask
        // ------------------------------------        
        var strDefaultScale        = "1"    // must be 1, 10, 100, etc
        var strDefaultMinIncrement = "1"    // must be 1, 2, 3, etc
        var strDefaultQuantity	   = "100"  // must be >= 1
        var strDefaultPrice		   = "101"  // must be >= 1
        var strDefaultType         = "bid"  // must be bid or ask
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args"))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "type bid scale 1 quantity 100 price 101"
            // EXAMPLE:  --args "type ask scale 1 quantity 100 price 101"
            //
            var strNewScale    = OT_CLI_GetValueByKey( Args, "scale"    ) // 1, 10, 100, 1000, etc
            var strNewMinInc   = OT_CLI_GetValueByKey( Args, "min_inc"  ) // 1, 2, 3, 4, etc. Usually 1.
            var strNewQuantity = OT_CLI_GetValueByKey( Args, "quantity" ) // quantity for sale/purchase. 
            var strNewPrice    = OT_CLI_GetValueByKey( Args, "price"    ) // per scale
            var strNewType     = OT_CLI_GetValueByKey( Args, "type"    )  // bid / ask
            
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewScale))
            {    strScale = strNewScale }
            if (VerifyStringVal(strNewMinInc))
            {    strMinIncrement = strNewMinInc }
            if (VerifyStringVal(strNewQuantity))
            {    strQuantity = strNewQuantity }
            if (VerifyStringVal(strNewPrice))
            {    strPrice = strNewPrice }
            if (VerifyStringVal(strNewType))
            {    strType = strNewType }
        }            
        // ------------------------------------
        // If the offer parameters aren't satisfied yet, then
        // ask the user to supply them at the command line.
        //
        if (!VerifyStringVal(strScale) || (strScale.to_int() < 1))
        {
            OT_API_Output(0, "Enter the market scale (1, 10, 100, etc)["+strDefaultScale+"]: ")
            strScale        = OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strMinIncrement) || (strMinIncrement.to_int() < 1))
        {
            OT_API_Output(0, "Enter the minimum increment["+strDefaultMinIncrement+"]: ")
            strMinIncrement	= OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strQuantity) || (strQuantity.to_int() < 1))
        {
            OT_API_Output(0, "Enter the quantity being purchased/sold["+strDefaultQuantity+"]: ")
            strQuantity		= OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strPrice) || (strPrice.to_int() < 1))
        {
            OT_API_Output(0, "Enter the price per scale["+strDefaultPrice+"]: ")
            strPrice		= OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strType) || ((strType != "bid") && (strType != "ask")))
        {
            OT_API_Output(0, "Enter the order type (bid/ask) ["+strDefaultType+"]: ")
            strType		= OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strScale) || (strScale.to_int() < 1))
        {    strScale = strDefaultScale }
        if (!VerifyStringVal(strMinIncrement) || (strMinIncrement.to_int() < 1))
        {    strMinIncrement = strDefaultMinIncrement }
        if (!VerifyStringVal(strQuantity) || (strQuantity.to_int() < 1))
        {    strQuantity = strDefaultQuantity }
        if (!VerifyStringVal(strPrice) || (strPrice.to_int() < 1))
        {    strPrice = strDefaultPrice }
        if (!VerifyStringVal(strType)  || ((strType != "bid") && (strType != "ask")))
        {    strType = strDefaultType }
        // ----------------------------------------------    
        //
        // false == buying    bid
        // true  == selling   ask
        //
        var bType	= ((strType == "bid") ? false : true);
        // ----------------------------------------------    
        return details_create_offer(strScale, strMinIncrement, strQuantity, strPrice, bType)
    }
    
    return (-1)
}













def main_create_server_contract()
{
    if (VerifyExists("MyNym"))
    {
        OT_API_Output(0, "Please enter the XML contents for the contract, followed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        
        var strXML = OT_CLI_ReadUntilEOF() 
        
        if (VerifyStringVal(strXML))
        {
            var strContractID = OT_API_CreateServerContract(MyNym, strXML)
            
            if (VerifyStringVal(strContractID))
            {
                // stderr
                OT_API_Output(0, "-------------------------------------------\nNew Contract ID: " + strContractID + "\n\n")
                
                var strContract = OT_API_GetServer_Contract(strContractID)
                
                if (VerifyStringVal(strContract))
                {
                    // stderr
                    OT_API_Output(0, "-------------------------------------------\nNew Contract:\n\n")
                    
                    // stdout
                    print(strContract)
                    
                    OT_API_Output(0, "\n\n")
                    
                    return 1
                }
            }
        }
    }
    
    // "return value"
    -1
}









def main_create_asset_contract()
{
    // bool OTContract::CreateContract(OTString & strContract, OTPseudonym & theSigner)
    
    if (VerifyExists("MyNym"))
    {
        OT_API_Output(0, "Please enter the XML contents for the contract, followed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        
        var strXML = OT_CLI_ReadUntilEOF() 
        
        if (VerifyStringVal(strXML))
        {
            var strContractID = OT_API_CreateAssetContract(MyNym, strXML)
            
            if (VerifyStringVal(strContractID))
            {
                // stderr
                OT_API_Output(0, "-------------------------------------------\nNew Contract ID: " + strContractID + "\n\n")
                
                var strContract = OT_API_GetAssetType_Contract(strContractID)
                
                if (VerifyStringVal(strContract))
                {
                    // stderr
                    OT_API_Output(0, "-------------------------------------------\nNew Contract:\n\n")
                    
                    // stdout
                    print(strContract)
                    
                    OT_API_Output(0, "\n\n")
                    
                    return 1
                }
            }
        }
    }
    
    // "return value"
    -1
}










def main_create_acct()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    
    // Just to show how easy it is now, let's try a "create_asset_acct" message.
    // (It sends a NymID to the server, and downloads that Nym's public key.)
    
    if (VerifyExists("Server") && VerifyExists("MyNym") && VerifyExists("MyPurse"))
    {	
        if (!OT_API_IsNym_RegisteredAtServer(MyNym, Server))
        {
            // If the Nym's not registered at the server, then register him first.
            main_register_nym()
        }
        // --------------------------
        // Send the request.
        //
        var strResponse	= madeEasy.create_asset_acct(Server, MyNym, MyPurse)	// Send the 'create_asset_acct' message to the server.
        
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        
        // -1 error, 0 failure, 1 success.
        //
        if (1 != VerifyMessageSuccess(strResponse))
        {
            OT_API_Output(0, "\n\ncreate_asset_acct: Failed.\n\n");
            return -1
        }
        else
        {
            OT_API_Output(0, "Success in create_asset_acct! Server response:\n\n") // stderr
            print(strResponse) // stdout
            OT_API_Output(0, "\n\n") //stderr
            return 1
        }
    }
    
    // Done!
    -1
}











def main_add_signature()
{
    // SignContract erases all signatures and affixes a new one alone.
    // But AddSignature, on the other hand, leaves all signatures in place, and simply adds yours to the list. 
    
    if (VerifyExists("MyNym"))
    {
        
        OT_API_Output(0, "Please enter an already-signed contract you wish to add your signature to, followed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        
        var strInput = OT_CLI_ReadUntilEOF() 
        
        OT_API_Output(0, "\n\n You entered:\n" + strInput + "\n\n") 
        
        var strOutput = OT_API_AddSignature(MyNym, strInput) 
        
        // stderr
        OT_API_Output(0, "-------------------------------------------\nSigned:\n\n")
        
        // stdout
        print(strOutput)
        
        // stderr
        OT_API_Output(0, "\n\n")
        
        return 1
    }
    
    // "return value"
    -1 
}






def main_sign_contract()
{
    // SignContract erases all signatures and affixes a new one alone.
    // But AddSignature, on the other hand, leaves all signatures in place, and simply adds yours to the list.
    
    var strUsage = concat("\n\n FYI, USAGE: sign \n",
                          " Optionally, you may specify a contract type:  sign --args \"type LEDGER\"\nIn that example, the output would start with the bookend: -----BEGIN OT SIGNED LEDGER-----\n(You don't need to specify the type if the bookend is already present on the input string.)\n\n")
    
    OT_API_Output(0, strUsage)

    if (VerifyExists("MyNym"))
    {
        OT_API_Output(0, "Please enter a contract to be signed, followed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        
        var strInput = OT_CLI_ReadUntilEOF() 
        
        OT_API_Output(0, "\n\n You entered:\n" + strInput + "\n\n") 
        
        var strOutput = OT_API_SignContract(MyNym, strInput) 
        
        if (!VerifyStringVal(strOutput))
        {
            // Maybe we need to flat sign (maybe it wasn't already a signed contract...)
            //
            var strContractType

            if (VerifyExists("Args"))
            {
                strContractType = OT_CLI_GetValueByKey(Args, "type")
            }
            // --------------------------------------------
            if (VerifyStringVal(strContractType))
            {
                OT_API_Output(0, "A properly-formed-and-signed contract was not provided, but a 'type' was... so we'll try flatsigning the input text...\n\n")
                strOutput = OT_API_FlatSign(MyNym, strInput, strContractType) 
            }
            else
            {
                OT_API_Output(0, "A properly-formed-and-signed contract was not provided, and neither was a 'type' in order to form one. (Failure.)\n")
                OT_API_Output(0, strUsage)
                return -1
            }
        }
        // ------------------------------------
        
        var nReturnVal = -1
        
        if (VerifyStringVal(strOutput))
        {
            // stderr
            OT_API_Output(0, "-------------------------------------------\nSigned:\n\n")
            
            // stdout
            print(strOutput)
            
            nReturnVal = 1
        }
        else
        {
            OT_API_Output(0, "Sorry, but OT was unable to sign. Oh well.")
        }
        // ------------------------------------        
        // stderr
        OT_API_Output(0, "\n\n")
        
        return nReturnVal
    }
    
    // "return value"
    -1
}












def details_cancel_offer(strServerID, strNymID, strAcctID, strTransNum)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
        
    // Just to show how easy it is now, let's try a "cancel_payment_plan" message.
    // (It cancels a payment plan.)
    
    if (VerifyStringVal(strServerID) && VerifyStringVal(strNymID) && VerifyStringVal(strAcctID) && VerifyStringVal(strTransNum))
    {	
        // Send the transaction.
        //        
        var strResponse	= madeEasy.cancel_market_offer(strServerID, strNymID, strAcctID, strTransNum)
        
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        
        if (1 != VerifyMessageSuccess(strResponse))
        {
            OT_API_Output(0, "\n\n canceloffer: Failed.\n")
        }
        else if (1 != VerifyMsgBalanceAgrmntSuccess(strServerID, strNymID, strAcctID, strResponse))
        {
            OT_API_Output(0, "\n\n canceloffer: Balance agreement failed.\n")
        }
        else if (1 != VerifyMsgTrnxSuccess(strServerID, strNymID, strAcctID, strResponse))
        {
            OT_API_Output(0, "\n\n canceloffer: Balance agreement succeeded, but transaction failed.\n")
        }
        else
        {
            OT_API_Output(0, "\n\nSuccess in canceloffer! Server response:\n\n")
            print(strResponse) // stdout
            OT_API_Output(0, "\n") // stderr
            return 1
        }
    }
    
    // Done!
    -1
}




def main_cancel_offer()
{
    // ------------------------------
    
    var strUsage = "\n\n FYI, USAGE: canceloffer --args \"transnum <transaction_number>\"\n\n"
    
    // Just to show how easy it is now, let's try a "cancel_payment_plan" message.
    // (It cancels a payment plan.)
    
    if (!VerifyExists("Server") || !VerifyExists("MyNym") || !VerifyExists("MyAcct") || !VerifyExists("Args"))
    {  OT_API_Output(0, strUsage)  }
    else
    {	
        var strTransactionNum = OT_CLI_GetValueByKey(Args, "transnum")
        
        if (!VerifyStringVal(strTransactionNum) )
        {
            OT_API_Output(0, "\n\n\nYou need to provide a transaction number...\n\n")
            OT_API_Output(0, strUsage)
        }
        else
        {
            return details_cancel_offer(Server, MyNym, MyAcct, strTransactionNum)            
        }
    }
    
    // Done!
    -1
}









def main_cancel_plan()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    
    // string OT_CLI_GetValueByKey(Args, str_key)
    
    var strUsage = "\n\n FYI, USAGE: cancel_plan.ot --args \"transnum <transaction_number>\"\n\n"
    
    // Just to show how easy it is now, let's try a "cancel_payment_plan" message.
    // (It cancels a payment plan.)
    
    if (!VerifyExists("Server") || !VerifyExists("MyNym") || !VerifyExists("MyAcct") || !VerifyExists("Args"))
    {  OT_API_Output(0, strUsage)  }
    else
    {	
        var strTransactionNum = OT_CLI_GetValueByKey(Args, "transnum")
        
        if (!VerifyStringVal(strTransactionNum) )
        {
            OT_API_Output(0, "\n\n\nYou need to provide a transaction number...\n\n")
            OT_API_Output(0, strUsage)
        }
        else
        {
            // Send the transaction.
            //
            var strResponse	= madeEasy.cancel_payment_plan(Server, MyNym, MyAcct, strTransactionNum)
            
            // NOTICE: No need here to deal with retries, timeouts, request number,
            // syncing transaction number, download / process nymbox, etc! It's all
            // handled at a lower level!  Instead, simply check for success or failure:
            
            if (1 != VerifyMessageSuccess(strResponse))
            {
                OT_API_Output(0, "\n\ncancel_payment_plan: Failed.\n")
            }
            else if (1 != VerifyMsgBalanceAgrmntSuccess(Server, MyNym, MyAcct, strResponse))
            {
                OT_API_Output(0, "\n\ncancel_payment_plan: Balance agreement failed.\n")
            }
            else if (1 != VerifyMsgTrnxSuccess(Server, MyNym, MyAcct, strResponse))
            {
                OT_API_Output(0, "\n\ncancel_payment_plan: Balance agreement succeeded, but transaction failed.\n")
            }
            else
            {
                OT_API_Output(0, "\n\nSuccess in cancel_payment_plan! Server response:\n\n")
                print(strResponse) // stdout
                OT_API_Output(0, "\n\n") // stderr
                return 1
            }
        }
    }
    
    // Done!
    -1
}








def main_verify_signature()
{
    if (VerifyExists("HisNym"))
    {
        OT_API_Output(0, "Please enter a contract you wish to verify with HisNym, followed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        
        var strInput = OT_CLI_ReadUntilEOF() 
        
        OT_API_Output(0, "\n\n--------------------------------------\n You entered:\n" + strInput + "\n\n") 
        
        var bSuccess = false
        
        bSuccess = OT_API_VerifySignature(HisNym, strInput) 
        
        if (bSuccess)
        {
            print("\n\n *** Verified! ***\n\n")
            return 1
        }
        else
        {
            print("Failed!\n\n")
        }
    }
    
    // return value
    -1
}








def stat_nyms()
{
    print("------------------------------------------------------------------")
    print(" ** PSEUDONYMS: " + "\n")
    
    var nNymCount = OT_API_GetNymCount()
    
    for (var i = 0; i < nNymCount; ++i)
    {
        var strID   = OT_API_GetNym_ID(i)
        var strName = OT_API_GetNym_Name(strID)
        
        print(strID + " ---  " + strName)
    }
    
    1
}

def stat_servers()
{
    print("------------------------------------------------------------------")
    print(" ** SERVERS: " + "\n")
    var nServerCount = OT_API_GetServerCount()
    
    for (var i = 0; i < nServerCount; ++i)
    {
        var strID   = OT_API_GetServer_ID(i)
        var strName = OT_API_GetServer_Name(strID)
        
        print(strID + " ---  " + strName)
    }
    
    1
}

def stat_assets()
{
    print("------------------------------------------------------------------")
    print(" ** ASSET TYPES: " + "\n")
    var nAssetTypeCount = OT_API_GetAssetTypeCount()
    
    for (var i = 0; i < nAssetTypeCount; ++i)
    {
        var strID   = OT_API_GetAssetType_ID(i)
        var strName = OT_API_GetAssetType_Name(strID)
        
        print(strID + " ---  " + strName)
    }
    
    1
}

def stat_accounts()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    
    
    print("------------------------------------------------------------------")
    print(" ** ACCOUNTS: " + "\n")
    
    var nAccountCount = OT_API_GetAccountCount()
    
    for (var i = 0; i < nAccountCount; ++i)
    {
        if ((i > 0) && (i != (nAccountCount))) { print("-------------------------------------"); }
        var strID            = OT_API_GetAccountWallet_ID(i)
        
        var strStatAcct      = madeEasy.stat_asset_account(strID)
        
        var bSuccess         = VerifyStringVal(strStatAcct)
        if (bSuccess)
        {    
            print(strStatAcct)  
        }
        else
        {
            print("Error trying to stat an asset account: "+strID)
        }
        // stderr
        print("")
    }
    print("------------------------------------------------------------------")
    
    1
}

def main_stat() 
{
    print("");
    
    stat_nyms()
    stat_servers()
    stat_assets()
    stat_accounts()
    
    1
}












def details_stat_account(strID)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    
    // stderr
    OT_API_Output(0, "\n\n------------------------------------------------------------------\n")
    
    var strStatAcct = madeEasy.stat_asset_account(strID)
    
    var bSuccess = VerifyStringVal(strStatAcct)
    var nSuccess = (bSuccess ? 1 : -1)
    
    if (bSuccess)
    {    
        print(strStatAcct)  
    }
    else
    {
        print("Error trying to stat an asset account: "+strID+"\n")
    }
    // stderr
    OT_API_Output(0, "\n")
    
    return nSuccess
}



def main_stat_acct() 
{
    if (VerifyExists("MyAcct"))
    {	
        return details_stat_account(MyAcct)
    }
    return (-1)
}










def details_account_balance(strID)
{
    var strName          = OT_API_GetAccountWallet_Name(strID)
    var strBalance       = OT_API_GetAccountWallet_Balance(strID)
    
    OT_API_Output(0, "\n    Balance: ") //stderr
    print(strBalance) // stdout
    OT_API_Output(0, strID + "   (" + strName + ")\n\n") //stderr
    
    return 1
}

def main_balance() 
{
    if (VerifyExists("MyAcct"))
    {	
        return details_account_balance(MyAcct)
    }
    return -1
}









def details_nym_stat(strID)
{
//  var strName    = OT_API_GetNym_Name(strID)
    var strStats   = OT_API_GetNym_Stats(strID)
    
    print(strStats) // stdout
    
    1
}


def main_nym_stat() 
{
    if (VerifyExists("MyNym"))
    {	
        return details_nym_stat(MyNym)
    }
    return -1
}












def main_show_mint()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    // SHOW MINT
    // 
    // (Load a public mint from local storage and display it on the screen.
    // If necessary, download it from the server.)
    //
    
    if (VerifyExists("Server") && VerifyExists("MyNym") && VerifyExists("MyPurse"))
    {	
        // Just to show how easy it is now, let's load up a mint and display it.
        // If this function is unable to load it, it will download the mint from
        // the server.
        //
        var strMint	= madeEasy.load_or_retrieve_mint(Server, MyNym, MyPurse) // <=====
        
        // NOTICE -- there's no need here to deal with retries, timeouts, request number, synching 
        // transaction number, download / process nymbox, etc! It's all handled interally.
        //
        // Simply "verify" the return value:
        //
        if (!VerifyStringVal(strMint))
        {
            OT_API_Output(0, "\n\n load_or_retrieve_mint: Failed.\n\n")
	        return -1
        }
        else	// Success!
        {
            OT_API_Output(0, "\n\n") // stderr
            print(strMint)           // stdout
            OT_API_Output(0, "\n\n") // stderr
            return 1
        }
    }
    
    // Done!
    -1
}














// Creates a new Pseudonym and adds it to the wallet.
// (And sets the display name for the new Nym, in the wallet.)
// Prints the new NymID to stdout.
//
// Returns 1 for success, 0 for failure.
//
def details_create_nym(nKeybits, strName)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    
    var strNymID = madeEasy.create_pseudonym(nKeybits)  // returns new Nym ID
    
    if (!VerifyStringVal(strNymID))
    {
        OT_API_Output(0, "details_create_nym: Failed in OT_ME::create_pseudonym(keybits == " + nKeybits.to_string() + ")\n")
        return (-1)
    }
    OT_API_Output(0, "Success creating! " + nKeybits.to_string() + " keybits, new ID: ") // stderr
    print(strNymID) // stdout
    OT_API_Output(0, "\n") //stderr
    // -------------------
    var bSetName = OT_API_SetNym_Name(strNymID, // subject
                                      strNymID, // signer
                                      strName)
    if (!bSetName)
    {
        OT_API_Output(0, "Failed in OT_API_SetNym_Name(name == " + strName + ")\n")
        return (-1)
    }
    // -------------------    
    OT_API_Output(0, "Success setting name to: " + strName + "\n\n") // stderr
    return 1
}


def main_create_nym()
{
    var nKeybits = 1024
    var strName  = "New Nym"
    // ------------------------------------
    if (VerifyExists("Args"))
    {
        // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
        //                                  const std::string str_key)
        // 
        // OPTION:   --args "key value key value"
        //
        // EXAMPLE:  --args "keybits 1024"
        //
        var strKeybits = OT_CLI_GetValueByKey( Args, "keybits" )
        
        var strNewName = OT_CLI_GetValueByKey( Args, "name" )
        
        if (VerifyStringVal(strKeybits) && (strKeybits.to_int() > 0))
        { nKeybits = strKeybits.to_int() }
        
        if (VerifyStringVal(strNewName))
        { strName = strNewName }
    }
    // ------------------------------------
    
    return details_create_nym(nKeybits, strName)
}















/*
 call OT_API_LoadInbox() to load the inbox ledger from local storage.
 
 During this time, your user has the opportunity to peruse the inbox, and to decide which transactions therein he wishes to accept or reject. Usually the inbox is display on the screen, then the user selects various items to accept or reject, and then the user clicks “Process Inbox” and then you do this:
 Then call OT_API_Ledger_CreateResponse() in order to create a ‘response’ ledger for that inbox, which will be sent to the server to signal your responses to the various inbox transactions.
 Then call OT_API_Ledger_GetCount() (pass it the inbox) to find out how many transactions are inside of it. Use that count to LOOP through them…
 Use OT_API_Ledger_GetTransactionByIndex() to grab each transaction as you iterate through the inbox. (There are various introspection functions you can use in the API here if you wish to display the inbox items on the screen for the user…) 
 Next call OT_API_Transaction_CreateResponse() for each transaction in the inbox, to create a response to it, accepting or rejecting it. This function creates the response and adds it to the response ledger.
 Next, call OT_API_Ledger_FinalizeResponse() which will create a Balance Agreement for the ledger.
 Finally, call OT_API_processInbox() to send your message to the server and process the various items.
 
 If the message was successful, then use OT_API_Message_GetBalanceAgreementSuccess() and OT_API_Message_GetTransactionSuccess() as described above in the deposit cash instructions.
 */
// ------------------------------
//
// PROCESS INBOX, ACCEPTING ALL ITEMS WITHIN...
// 
// Load an asset account's inbox from local storage and iterate through
// the items inside, and fire off a server message accepting them all.
//

def accept_entire_inbox()
{
    // ---------------------------------------------
    
    var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
    
    if (!VerifyStringVal(strMyNymID))
    {
        OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
        return (-1)
    }
    // ----------------------------------------------
    
    var strInbox = OT_API_LoadInbox(Server, strMyNymID, MyAcct); // Returns NULL, or an inbox.
    
	if (!VerifyStringVal(strInbox))
	{
		OT_API_Output(0, "\n\n OT_API_LoadInbox: Failed.\n\n")
        return -1
	}
	else	// Success!
	{
		OT_API_Output(0, "\n\n") // stderr
        //		print(strInbox)          // stdout
        
        var nCount = OT_API_Ledger_GetCount(Server, strMyNymID, MyAcct, strInbox)
        
        if (VerifyIntVal(nCount) && (nCount > 0))
        {
            var strResponseLEDGER = OT_API_Ledger_CreateResponse(Server, strMyNymID, MyAcct, strInbox)
            
            if (!VerifyStringVal(strResponseLEDGER))
            {
                OT_API_Output(0, "\n\nFailure: OT_API_Ledger_CreateResponse returned NULL.\n")
                return (-1)
            }
            // ----------------------------------
            for (var nIndex = 0; nIndex < nCount; ++nIndex)
            {
                var strTrans              = OT_API_Ledger_GetTransactionByIndex(Server, strMyNymID, MyAcct, strInbox, nIndex)                
                var strNEW_ResponseLEDGER = OT_API_Transaction_CreateResponse(Server, strMyNymID, MyAcct, strResponseLEDGER, strTrans, true) // accept = true  
                
                if (!VerifyStringVal(strNEW_ResponseLEDGER))
                {
                    OT_API_Output(0, "\n\nFailure: OT_API_Transaction_CreateResponse returned NULL.\n")
                    return (-1)
                }
                strResponseLEDGER = strNEW_ResponseLEDGER
            } // for
            // ----------------------------------
            var strFinalizedResponse = OT_API_Ledger_FinalizeResponse(Server, strMyNymID, MyAcct, strResponseLEDGER)
            
            if (!VerifyStringVal(strFinalizedResponse))
            {
                OT_API_Output(0, "\n\nFailure: OT_API_Ledger_FinalizeResponse returned NULL.\n")
                return (-1)
            }
            // ***************************************************************
            
            // Instantiate the "OT Made Easy" object.
            //
            var madeEasy	= OT_ME()
            
            // Server communications are handled here...
            //
            var strResponse = madeEasy.process_inbox(Server, strMyNymID, MyAcct, strFinalizedResponse) 
            var strAttempt  = "process_inbox"
            
            // ***************************************************************
            
            var nInterpretReply = InterpretTransactionMsgReply(Server, strMyNymID, MyAcct, strAttempt, strResponse)
            
            if (1 == nInterpretReply)
            {    
                // Download all the intermediary files (account balance, inbox, outbox, etc)
                // since they have probably changed from this operation.
                //
                var bRetrieved = madeEasy.retrieve_account(Server, strMyNymID, MyAcct, true) //bForceDownload defaults to false.
                
                OT_API_Output(0, "\n\nServer response ("+strAttempt+"): SUCCESS processing/accepting entire inbox!\n")
                OT_API_Output(0, (bRetrieved ? "Success" : "Failed") + " retrieving intermediary files for account.\n")
            }
            
            // ***************************************************************
            //
            // Success!
            //
            return nInterpretReply  
            
        } // VerifyIntVal (nCount) && nCount > 0     
        
        OT_API_Output(0, "(The inbox is empty.)\n\n")
    }
    
    0
}



def main_accept_inbox()
{
    if (VerifyExists("Server") && VerifyExists("MyAcct"))
    {	
        return accept_entire_inbox()
    } 
    
    return -1
}






// returns the server response string (or null.)
// Use VerifyStringVal and/or VerifyMessageSuccess on it, for more info.
//
def details_check_user(strServerID, strMyNymID, strHisNymID)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    
    // Just to show how easy it is now, let's try a "check_user" message.
    // (It sends a NymID to the server, and downloads that Nym's public key.)
    
    var strResponse

    // NOTE: If this were Server, MyNym, and HisNym, then we'd have already
    // translated the partials to read IDs (in OT itself) but we don't have that
    // guarantee in this function. Maybe strServerID was passed in from user input
    // directly, while inside another script. Partial IDs should still work, right?
    // So here, we translate them just in case.
    //
    if (VerifyStringVal(strServerID) && VerifyStringVal(strMyNymID) && VerifyStringVal(strHisNymID))
    {
        // IF we are able to resolve the HisNymId from a partial, then we
        // replace the partial with the full version.
        // (Otherwise we assume it's already a full ID and we don't mess with it.)
        //
        var strServerFromPartial  = OT_API_Wallet_GetServerIDFromPartial(strServerID)
        
        if (VerifyStringVal(strServerFromPartial))
        {
            strServerID = strServerFromPartial
        }
        // ---------------------------------
        var strHisNymFromPartial  = OT_API_Wallet_GetNymIDFromPartial(strHisNymID)
        
        if (VerifyStringVal(strHisNymFromPartial))
        {
            strHisNymID = strHisNymFromPartial
        }
        // ---------------------------------
        var strMyNymFromPartial  = OT_API_Wallet_GetNymIDFromPartial(strMyNymID)
        
        if (VerifyStringVal(strMyNymFromPartial))
        {
            strMyNymID = strMyNymFromPartial
        }
        // ---------------------------------
        // Send the request.
        //        
        strResponse = madeEasy.check_user(strServerID, strMyNymID, strHisNymID)	// Send the 'check_user' message to the server.
    }
    else
    {
        OT_API_Output(0, "\n details_check_user: Bad input... strServerID, strMyNymID, or strHisNymID \n")
    }
    
    // Done
    strResponse
}


def main_check_user()
{
    if (VerifyExists("Server") && VerifyExists("MyNym") && VerifyExists("Args"))
    {
        var strHisNym = OT_CLI_GetValueByKey( Args, "hisnym" ) 
        
        if (!VerifyStringVal(strHisNym))
        {
            OT_API_Output(0, "\n\n Missing:  --args \"hisnym HIS_NYM_ID_GOES_HERE\"\n\n")
            return -1
        }
        // ---------------------------------
        // Send the request.
        //
        var strResponse	= details_check_user(Server, MyNym, strHisNym)

        // ---------------------------------
        // -1 is error,
        //  0 is reply received: failure 
        //  1 is reply received: success
        //
        if (1 == VerifyMessageSuccess(strResponse))
        {
            OT_API_Output(0, "\n\nSuccess in checknym! Server response:\n\n")
            print(strResponse) // stdout
            OT_API_Output(0, "\n\n") //stderr
            return 1
        }
        else
        {
            OT_API_Output(0, "\n\n checknym: Failed.\n\n")
        }
    }
    
    // Done
    -1
}













def download_acct_files()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    
    // ---------------------------------------------
    
    var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
    
    if (!VerifyStringVal(strMyNymID))
    {
        OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
        return (-1)
    }
    // ----------------------------------------------
    
    // Download all the intermediary files (account balance, inbox, outbox, etc)
    // since they have probably changed from this operation.
    //
    var bRetrieved = madeEasy.retrieve_account(Server, strMyNymID, MyAcct, true) //bForceDownload defaults to false.
    
    OT_API_Output(0, "\n\n" + (bRetrieved ? "SUCCESS" : "FAILED") + " retrieving intermediary files for account: " + MyAcct + "\n\n")
    
    return bRetrieved ? 1 : -1;
}


def main_dl_acct_files()
{
    var strUsage = "Usage:  refreshacct --server SERVER_ID --myacct YOUR_ACCT_ID\n\n"
    
    OT_API_Output(0, strUsage)
    
    if (VerifyExists("Server") && VerifyExists("MyAcct"))
    {	
        return download_acct_files()
    } 
    
    return -1
}


def main_refresh_all()
{
    var strUsage = "Usage:  refresh --server SERVER_ID --mynym YOUR_NYM_ID --myacct YOUR_ACCT_ID\n\n"
    
    OT_API_Output(0, strUsage)
    
    if (VerifyExists("Server") && VerifyExists("MyNym") && VerifyExists("MyAcct"))
    {	
        var nSuccess = main_refresh_nym()   // <=======
        
        if ((-1) == nSuccess)
        {
            return (-1)
        }
        
        return main_dl_acct_files()  // <=======
    } 
    
    return -1
}






def details_download_contract(strServerID, strNymID, strContractID) : strContractID.is_type(string_type)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    
    // ---------------------------------------------
    
    // Download all the intermediary files (account balance, inbox, outbox, etc)
    // since they have probably changed from this operation.
    //
    var strRetrieved   = madeEasy.retrieve_contract(strServerID, strNymID, strContractID)
    var nRetrieved     = VerifyMessageSuccess(strRetrieved)
    
    var strSuccess = "ERROR"
    
    if (1 == nRetrieved)
    {   strSuccess = "SUCCESS" }
    else if (0 == nRetrieved)
    {   strSuccess = "FAILED" }
    
    OT_API_Output(0, "\n\n " + strSuccess + " retrieving contract: "+strContractID+"\n\n")
    
    return (1 == nRetrieved) ? 1 : -1;
}


def main_download_contract()
{
    var strUsage = concat("\n\nUsage:  getcontract --server SERVER_ID --mynym YOUR_NYM_ID \n",
                          "                    --args \"contract_id CONTRACT_ID_HERE\"\n\n")
    OT_API_Output(0, strUsage)
    
    var strContractID = ""
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {	
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args"))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "contract_id CvHGtfOOKzQKL5hFL7J4iF5yAodVKhS1rxPzME5R9XA"
            //
            var strNewContractID = OT_CLI_GetValueByKey( Args, "contract_id" ) 
            
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewContractID))
            {    strContractID = strNewContractID }
            else
            {
                OT_API_Output(0, "\n\nMissing --args \"contract_id CONTRACT_ID_HERE\"\n\n")
                return (-1)
            }
            
            return details_download_contract(Server, MyNym, strContractID)
        }
        // ------------------------------------
    } 
    
    return -1
}












def main_verify_last_receipt()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    
    var madeEasy	= OT_ME()
    // ------------------------------
    // SHOW INBOX
    // 
    // Load an asset account's inbox from local storage and display it on the screen.
    //
    
    if (VerifyExists("Server") && VerifyExists("MyAcct"))
    {	
        // ---------------------------------------------
        // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
        //
        var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
        
        if (!VerifyStringVal(strMyNymID))
        {
            OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
            return (-1)
        }
        // ***************************************************************
        
        var bSuccess = OT_API_VerifyAccountReceipt(Server, strMyNymID, MyAcct);
        
        if (!bSuccess)
        {
            OT_API_Output(0, "\n\n OT_API_VerifyAccountReceipt: Failed. Try using refreshacct and then try verifying again.\n\n")
            return -1
        }
        else	// Success!
        {        
            OT_API_Output(0, "\n\nVerify receipt:  success!\n\n") // stderr
            return 1
        }
    }
    
    // Done!
    -1
}




















def main_register_nym()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // --------------------------------------------------------------------
    
    var strUsage = concat("\n\nUsage: register_nym.ot --server SERVER_ID --mynym NYM_ID\n\n",
                          "(If you don't have a NymID, then use create_nym.ot first.)\n\n")
    
    OT_API_Output(0, strUsage)
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {        
        var strResponse = madeEasy.register_nym(Server, MyNym)
        var nSuccess    = VerifyMessageSuccess(strResponse)
        
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        //
        // -1 is error, 
        //  0 is reply received: failure 
        //  1 is reply received: success
        //
        switch(nSuccess)
        {
            case (1)
            {
                var MsgUtil	= Utility()
                
                //	4. Use the getRequest command, thus insuring that the request number is in sync. 
                //
                if (1 != MsgUtil.getRequestNumber(Server, MyNym)) 
                {
                    OT_API_Output(0, "\n Succeeded in register_nym, but strange: then failed calling getRequest, to sync the request number. (Finished.)\n")
                }
                else // If it returns 1, we know for sure that the request number is in sync.
                {
                    OT_API_Output(0, "\n\n Server response:\n\n");
                    print(strResponse) // stdout
                    OT_API_Output(0, "\n\n SUCCESS in register_nym!\n(Also, success syncronizing the request number.)\n\n")
                }
                break
            }
            case (0)
            {
                OT_API_Output(0, "\n\n FAILURE in register_nym! Server response:\n\n");
                print(strResponse) // stdout
                break
            }
            default
            {
                OT_API_Output(0, "\n\nError in register_nym!\n")
                
                if (VerifyStringVal(strResponse))
                {
                    OT_API_Output(0, "Server response:\n\n");
                    print(strResponse) // stdout
                }
                break
            }
        }
        OT_API_Output(0, "\n\n") //stderr
        
        return nSuccess
    }
    
    return -1
}








def main_refresh_nym()
{
    // --------------------------------------------------------------------
    var MsgUtil	= Utility()
    // --------------------------------------------------------------------
    
    var strUsage = concat("\n\nUsage: refreshnym --server SERVER_ID --mynym NYM_ID\n\n",
                          "(If you don't have a NymID, then use the newnym command first.)\n\n")
    
    OT_API_Output(0, strUsage)
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {        
        if (1 != MsgUtil.getRequestNumber(Server, MyNym)) 
        {
            OT_API_Output(0, "\n Failed calling getRequest, to sync the request number. (Finished.)\n")
            return (-1)
        }
        else // If it returns 1, we know for sure that the request number is in sync.
        {
            OT_API_Output(0, "\n\n SUCCESS syncronizing the request number.\n")
        }
        // -------------------------------------------------------
        
        var bWasMsgSent    = OTBool(false)
        var bForceDownload = true
        
        var nGetAndProcessNymbox = MsgUtil.getAndProcessNymbox_4(Server, MyNym, bWasMsgSent, bForceDownload)
        
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        //
        // -1 is error, 
        //  0 is reply received: failure 
        //  1 is reply received: success
        //
        switch(nGetAndProcessNymbox)
        {
            case (1)
            {
                OT_API_Output(0, "\n\n SUCCESS in refresh nym!\n")
                break
            }
            case (0)
            {
                if (bWasMsgSent.getBooleanValue()) // the message was sent, and the server replied "failure".
                {
                    OT_API_Output(0, "\n\n FAILURE in refresh nym!\n")
                }
                else // the message wasn't sent; the 0 in this case means "nymbox was empty."
                {
                    OT_API_Output(0, "\n\n Success in refresh nym! (Skipped processing Nymbox, since it's empty.)\n")
                    return 0
                }
                break
            }
            default
            {
                OT_API_Output(0, "\n\nError in refresh nym! nGetAndProcessNymbox: "+nGetAndProcessNymbox.to_string()+"\n")
                break
            }
        }
        OT_API_Output(0, "\n") //stderr
        
        return nGetAndProcessNymbox
    }
    
    return -1
}





// --------------------------------------------------------------
// GET BOX RECEIPT          Note: from ot_made_easy.ot
// Note: nBoxType is 0 for Nymbox, 1 for Inbox, and 2 for Outbox.
// Also, if nBoxType is 0 (nymbox) then you have to pass the NymID in the ACCT_ID 
// argument, as well as the NYM_ID argument (you have to pass it twice...)
// Otherwise for inbox/outbox, pass the actual ACCT_ID there as normal.
//
//def OT_ME::get_box_receipt(SERVER_ID, NYM_ID, ACCT_ID, nBoxType, STR_TRANS_NUM) 
//{
//    var ot_Msg := OTAPI_Func()
//    // -------------------------
//    var theRequest := OTAPI_Func(ot_Msg.GET_BOX_RECEIPT, SERVER_ID, NYM_ID, ACCT_ID, nBoxType, STR_TRANS_NUM)
//    var	strResponse = theRequest.SendRequest(theRequest, "GET_BOX_RECEIPT")
//    
//    return strResponse;
//}


def details_download_box_receipt(strID, nBoxType)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ---------------------------------------------
    
    var strMyNymID  = MyNym
    var strAcctID
    
    // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
    //
    if (0 == nBoxType)  // It's a Nymbox he's after. (Use NymID for the AcctID, in this case.)
    {
        strAcctID = MyNym
    }
    else // it's an inbox or outbox (needs an acct ID.)
    {
        if (!VerifyExists("MyAcct", false))
        {
            OT_API_Output(0, "Failure: Unable to find MyAcct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
            return (-1)
        }
        else
        {
            strAcctID = MyAcct
            
            // (After this point, MyNym contains the NymID, and strMyNymID contains
            // the NymID that corresponds to MyAcct -- they may not necessarily be
            // the same Nym...)
            //
            strMyNymID = OT_API_GetAccountWallet_NymID(strAcctID)
            
            if (!VerifyStringVal(strMyNymID))
            {
                OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
                OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
                return (-1)
            }
            // -------------------------------------
            if (strMyNymID != MyNym)
            {
                OT_API_Output(0, "Failure: Found a NymID based on myacct, but MyNym is not the same ID.\n")
                OT_API_Output(0, "To avoid any confusion, please be explicit with Nym ID:   --mynym NYM_ID \n\n")
                return (-1)
            }
        }
    }
    // ***************************************************************
    
    // HERE, WE SEND THE 'GET BOX RECEIPT' REQUEST TO THE SERVER
    //
    var strResponse = madeEasy.get_box_receipt(Server, strMyNymID, strAcctID, nBoxType, strID) 
//  var strAttempt  = "get_box_receipt" // unused here.
    
    // ***************************************************************
    // NOTICE: No need here to deal with retries, timeouts, request number,
    // syncing transaction number, download / process nymbox, etc! It's all
    // handled at a lower level!  
    // 
    // Instead, simply check for success or failure:
    //
    var nInterpretReply = VerifyMessageSuccess(strResponse)
    
    if (!VerifyIntVal(nInterpretReply) || (1 != nInterpretReply))
    {
        OT_API_Output(0, "get_box_receipt: Failed. nInterpretReply is: " + nInterpretReply.to_string() + "\n");
        OT_API_Output(0, "get_box_receipt: Perhaps that receipt is no longer in the box?\n");
    }
    else
    {
        OT_API_Output(0, "Success in get_box_receipt! Server response:\n\n")
        print(strResponse)
        OT_API_Output(0, "\n\n")
        return 1
    }    
    // ***************************************************************
    //
    // Return status to caller.
    //
    return nInterpretReply  
}




def main_get_box_receipt()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // --------------------------------------------------------------------
    var strUsage = concat("\n\nUsage: getboxreceipt --server SERVER_ID --mynym NYM_ID\n\n",
                              "Also:    --args \"box_type BOX_TYPE_ID_HERE id TRANSACTION_ID_HERE\"\nBox types are 0 (Nymbox), 1 (Inbox), 2 (Outbox)\n\n")
    
    OT_API_Output(0, strUsage)
    
    var strID
    var nBoxType = 1  // Inbox by default.
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {        
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args"))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "box_type 0 id 98"
            //
            var strNewID   = OT_CLI_GetValueByKey( Args, "id" ) 
            var strNewType = OT_CLI_GetValueByKey( Args, "box_type" ) 
            
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewID))
            {    strID = strNewID }
            else
            {
                OT_API_Output(0, "\n\nMissing --args \"id TRANSACTION_ID_HERE\"\n\n")
                return (-1)
            }
            // **************************************************************
            //
            if (VerifyStringVal(strNewType))
            {    nBoxType = strNewType.to_int() }
            // ----------------------------------------------
            if (!VerifyIntVal(nBoxType) || (nBoxType < 0) || (nBoxType > 2))
            {
                OT_API_Output(0, "\n\n box_type cannot be <0 or >2. Try:  --args \"box_type 1\"\nBox types are 0 (Nymbox), 1 (Inbox), 2 (Outbox)\n\n")
                return (-1)
            }
            // ------------------------------------
            // If Inbox or Outbox, make sure we have an acct...
            //
            if ((nBoxType != 0) && !VerifyExists("MyAcct", false))
            {
                OT_API_Output(0, "\n\n For inbox (1) or outbox (2) box types, need an account ID.\nMissing: --myacct ACCT_ID_HERE \n\n")
                return (-1)
            }
            // ------------------------------------

            return details_download_box_receipt(strID, nBoxType)
        }
        // ------------------------------------
    }
    
    return -1
}










// ------------------------------
//
// WITHDRAW CASH 
//
// (from asset account on server to cash purse on client.)
//
def details_withdraw_cash(strAmount)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()

    // ---------------------------------------------
    // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
    //
    var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
    
    if (!VerifyStringVal(strMyNymID))
    {
        OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
        return (-1)
    }
    // ---------------------------------------------
    // MAKE SURE WE HAVE THE RIGHT ASSET CONTRACT    
    //
    var strAssetTypeID = OT_API_GetAccountWallet_AssetTypeID(MyAcct)
    
    if (!VerifyStringVal(strAssetTypeID))
    {
        OT_API_Output(0, "Failure: Unable to find Asset Type ID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the asset type based on the account.\n\n")
        return (-1)
    }
    // ---------------------------------------------
    var assetContract = OT_API_LoadAssetContract(strAssetTypeID)
    
    if (!VerifyStringVal(assetContract)) 
    {
        var strResponse = madeEasy.retrieve_contract(Server, strMyNymID, strAssetTypeID) 

        if (1 != VerifyMessageSuccess(strResponse))
        {
            OT_API_Output(0, "details_withdraw_cash: Unable to retrieve contract for IDs: \n")
            OT_API_Output(0, "  Server ID: " + Server  + "\n")
            OT_API_Output(0, "   Asset ID: " + strAssetTypeID + "\n")
            return (-1)			
        }
        // ----------------------------------------
        assetContract = OT_API_LoadAssetContract(strAssetTypeID)
        
        if (!VerifyStringVal(assetContract))
        {
            OT_API_Output(0, "Failure: Unable to load Asset contract even after retrieving it.\n")
            return (-1)
        }
    }
    // By this point, we KNOW the appropriate asset contract is available.
    // ---------------------------------------- 
    //
    // HERE, WE MAKE SURE WE HAVE THE PROPER MINT...
    //
    var strMint = madeEasy.load_or_retrieve_mint(Server, strMyNymID, strAssetTypeID) 

    if (!VerifyStringVal(strMint))
    {
        OT_API_Output(0, "Failure: Unable to load or retrieve necessary mint file for withdrawal.\n")
        return (-1)
    }
    // By this point, we know we can successfully load both: 
    // 1. the proper asset contract.
    // 2. the proper (unexpired) mint file.
    // ***************************************************************
    // HERE, WE SEND THE WITHDRAWAL REQUEST TO THE SERVER
    //
    var strResponse = madeEasy.withdraw_cash(Server, strMyNymID, MyAcct, strAmount) 
    var strAttempt  = "withdraw_cash"
    // ***************************************************************
    
    // HERE, WE INTERPRET THE SERVER REPLY, WHETHER SUCCESS, FAIL, OR ERROR...
    
    var nInterpretReply = InterpretTransactionMsgReply(Server, strMyNymID, MyAcct, strAttempt, strResponse)
    
    if (1 == nInterpretReply)
    {    
        // Download all the intermediary files (account balance, inbox, outbox, etc)
        // since they have probably changed from this operation.
        //
        var bRetrieved = madeEasy.retrieve_account(Server, strMyNymID, MyAcct) //bForceDownload defaults to false.
        
        OT_API_Output(0, "\n\nServer response ("+strAttempt+"): SUCCESS withdrawing cash! (From account on server to local purse.) \n")
        OT_API_Output(0, (bRetrieved ? "Success" : "Failed") + " retrieving intermediary files for account.\n")
    }
    
    // ***************************************************************
    //
    // Return status to caller.
    //
    return nInterpretReply  
}

// HERE, WE GET ALL THE ARGUMENTS TOGETHER,
// and then call the above function.
//
def main_withdraw_cash()
{
    var strUsage = concat("\n\n  USAGE: withdraw --myacct YOUR_ASSET_ACCT --server SERVER_ID \n\n",
                           "Also NECESSARY: --args \"amount PUT_AMOUNT_HERE\"\n")

    OT_API_Output(0, strUsage)
    // ------------------------------------        

    if (VerifyExists("Server") && VerifyExists("MyAcct"))
    {	
        // strAmount
        //
        var strAmount    = "0" // must be >= 1
        // ------------------------------------        
        var strDefaultAmount  = "1"  // must be >= 1
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false)) // displayErrorMsg=false
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "amount 1"
            //
            var strNewAmount = OT_CLI_GetValueByKey( Args, "amount"    ) // any integer value
            
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewAmount))
            {    strAmount = strNewAmount }
        }            
        // ------------------------------------
        // If the withdrawal parameters aren't provided, then we
        // ask the user to supply them at the command line.
        //
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {
            OT_API_Output(0, "Enter the amount as integer["+strDefaultAmount+"]: ")
            strAmount        = OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {    strAmount = strDefaultAmount }
        // ----------------------------------------------    

        return details_withdraw_cash(strAmount)
    }
    
    return -1
}

// -----------------------











/*
 pScript->chai.add(fun(&OTAPI_Wrap::Wallet_GetNymIDFromPartial),     "OT_API_Wallet_GetNymIDFromPartial");
 pScript->chai.add(fun(&OTAPI_Wrap::Wallet_GetServerIDFromPartial),  "OT_API_Wallet_GetServerIDFromPartial");
 pScript->chai.add(fun(&OTAPI_Wrap::Wallet_GetAssetIDFromPartial),   "OT_API_Wallet_GetAssetIDFromPartial");
 pScript->chai.add(fun(&OTAPI_Wrap::Wallet_GetAccountIDFromPartial), "OT_API_Wallet_GetAccountIDFromPartial");

 */


// ------------------------------
//
// WITHDRAW VOUCHER 
//
//(From asset account into instrument form, 
// like a cashier's cheque.)
//


def details_withdraw_voucher(strOutput)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ---------------------------------------------
    // HERE, WE LOOK UP THE NYM ID
    //
    var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
    
    if (!VerifyStringVal(strMyNymID))
    {
        OT_API_Output(0, "\n\nFailure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
        return (-1)
    }
    // ---------------------------------------------
    // HERE, WE LOOK UP THE SERVER ID
    //
    var strServerID = OT_API_GetAccountWallet_ServerID(MyAcct)
    
    if (!VerifyStringVal(strServerID))
    {
        OT_API_Output(0, "\n\nFailure: Unable to find the server ID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the server ID based on the account.\n\n")
        return (-1)
    }
    // ---------------------------------------------
    var strHisNymID
    
    if (VerifyExists("HisNym")) // This ID is already validated in the C++ code (in this case.)
    {
        strHisNymID = HisNym
        
        var strRecipientPubkey = madeEasy.load_or_retrieve_pubkey(strServerID, strMyNymID, strHisNymID)

        if (!VerifyStringVal(strRecipientPubkey))
        {
            OT_API_Output(0, "\n\nFailure: Unable to load or download pubkey for HisNym based on given value ("+strHisNymID+"). To override, use: --hisnym HIS_NYM_ID\n\n")
            return (-1)
        }
        // -------------------------------------------------------
    }
    else
    {
        OT_API_Output(0, "Optionally, enter recipient NymID (abbreviations accepted): ")
        
        var strHisPartialNymID = OT_CLI_ReadLine()
        
        if (VerifyStringVal(strHisPartialNymID)) // If the user typed something...
        {
            strHisNymID = OT_API_Wallet_GetNymIDFromPartial(strHisPartialNymID) // Try to find the associated ID...
            
            if (!VerifyStringVal(strHisNymID)) // But if it returned NULL, failure (return.)
            {
                OT_API_Output(0, "\n\nFailure: Unable to find HisNym (Recipient) in your wallet. Use: --hisnym NYM_ID\n")
                return (-1)
            }
        }
        // ------------------------
        else // The user just hit "enter" so we'll default the recipient Nym to the user himself.
        {
            strHisNymID = strMyNymID
        }
        // ------------------------
    }
    
    // ***************************************************************
    //
    // strAmount and strMemo...
    //
    var strAmount    = "0" // must ultimately be >= 1
    var strMemo      = ""  // can be blank
    // ------------------------------------        
    var strDefaultAmount  = "1"  // must be >= 1
    var strDefaultMemo    = "(blank memo field)"   // can be blank
    // ------------------------------------
    // If custom arguments have been passed on the command line,
    // then grab them and use them instead of asking the user to enter them
    // at the command line.
    //
    if (VerifyExists("Args", false))
    {
        // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
        //                                  const std::string str_key)
        // 
        // OPTION:   --args "key value key value"
        // EXAMPLE:  --args "amount 1"
        // EXAMPLE:  --args "amount 15 memo \"Just a memo for the voucher cheque.\""
        //
        var strNewAmount = OT_CLI_GetValueByKey( Args, "amount"    ) // any integer value
        var strNewMemo   = OT_CLI_GetValueByKey( Args, "memo"  )     // optional memo field
        
        // ----------------------------------------------
        // Set the values based on the custom arguments, for those found.
        //
        if (VerifyStringVal(strNewAmount))
        {    strAmount = strNewAmount }
        if (VerifyStringVal(strNewMemo))
        {    strMemo = strNewMemo }
    }            
    // ------------------------------------
    // If the transfer parameters aren't provided, then we
    // ask the user to supply them at the command line.
    //
    if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
    {
        OT_API_Output(0, "Enter the amount as integer["+strDefaultAmount+"]: ")
        strAmount        = OT_CLI_ReadLine()
    }
    if (!VerifyStringVal(strMemo))
    {
        OT_API_Output(0, "Optionally, enter a memo on a single line["+strDefaultMemo+"]: ")
        strMemo	= OT_CLI_ReadLine()
    }
    // ----------------------------------------------
    if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
    {    strAmount = strDefaultAmount }
    if (!VerifyStringVal(strMemo))
    {    strMemo = strDefaultMemo }

    // ***************************************************************
    
    // HERE, WE SEND THE VOUCHER WITHDRAWAL REQUEST TO THE SERVER
    //
    var strResponse = madeEasy.withdraw_voucher(strServerID, strMyNymID, MyAcct, strHisNymID, strMemo, strAmount)
    var strAttempt  = "withdraw_voucher"
//  static int withdrawVoucher(const std::string SERVER_ID,
//                             const std::string USER_ID,
//                             const std::string ACCT_ID,
//                             const std::string RECIPIENT_USER_ID,
//                             const std::string CHEQUE_MEMO,
//                             const std::string AMOUNT);
    // ***************************************************************
    //
    // HERE, WE INTERPRET THE SERVER REPLY, WHETHER SUCCESS, FAIL, OR ERROR...
    
    var nInterpretReply = InterpretTransactionMsgReply(strServerID, strMyNymID, MyAcct, strAttempt, strResponse)
    
    if (1 == nInterpretReply) // Success!
    {    
        // ---------------------------------------------------------
        var strLedger = OT_API_Message_GetLedger(strResponse)
        
        if (!VerifyStringVal(strLedger)) 
        {
            OT_API_Output(0, "\n\n details_withdraw_voucher: Error: strLedger is null, returned by OT_API_Message_GetLedger.\n")
            return (-1)
        }
        // ---------------------------------------------------------
        var strTransReply = OT_API_Ledger_GetTransactionByIndex(strServerID, strMyNymID, MyAcct, strLedger, 0) // index 0.
        
        if (!VerifyStringVal(strTransReply)) 
        {
            OT_API_Output(0, concat("details_withdraw_voucher: Error: strTransReply is unexpectedly null, returned by ", 
                                    "OT_API_Ledger_GetTransactionByIndex, argument passed, index 0 and ledger:\n\n") + strLedger + "\n\n")
            return (-1)
        }
        // ---------------------------------------------------------

        strOutput = OT_API_Transaction_GetVoucher(strServerID, strMyNymID, MyAcct, strTransReply)
        
        if (!VerifyStringVal(strOutput)) 
        {
            OT_API_Output(0, concat("details_withdraw_voucher: Error: Voucher is unexpectedly null, returned by ", 
                                    "OT_API_Transaction_GetVoucher with strTransReply set to:\n\n") + strTransReply + "\n\n")
            return (-1)
        }
        // ---------------------------------------------------------        
        // Download all the intermediary files (account balance, inbox, outbox, etc)
        // since they have probably changed from this operation.
        //
        var bRetrieved = madeEasy.retrieve_account(strServerID, strMyNymID, MyAcct, true) //bForceDownload defaults to false.
        OT_API_Output(0, (bRetrieved ? "Success" : "Failed") + " retrieving intermediary files for account.\n")
        // ---------------------------------------------------------
        OT_API_Output(0, "details_withdraw_voucher: Voucher returned by OT_API_Transaction_GetVoucher:\n\n") // stderr
        print(strOutput) // stdout
        OT_API_Output(0, "\n\n") // stderr.

        OT_API_Output(0, "\n\nServer response ("+strAttempt+"): SUCCESS withdrawing voucher (cashier's cheque)!\n")
        
        return 1
    }
    
    // ***************************************************************
    //
    // Return status to caller.
    //
    return nInterpretReply  
}



//  static int withdrawVoucher(const std::string SERVER_ID,
//                             const std::string USER_ID,
//                             const std::string ACCT_ID,
//                             const std::string RECIPIENT_USER_ID,
//                             const std::string CHEQUE_MEMO,
//                             const std::string AMOUNT);

// HERE, WE GET ALL THE ARGUMENTS TOGETHER,
// and then call the above function.
//
def main_withdraw_voucher()
{
    var strUsage1 = concat("\n\n  USAGE: buyvoucher --myacct YOUR_ASSET_ACCT --hisnym RECIPIENT_NYM_ID\n\n",
                           "Also NECESSARY: --args \"amount PUT_AMOUNT_HERE\"\n")
    var strUsage = concat(strUsage1,
                          "And OPTIONALLY: --args \"memo \\\"Just a memo for the voucher cheque.\\\"\"\n\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("MyAcct"))
    {	
        var strVoucher = ""
        return details_withdraw_voucher(strVoucher)
    }
    
    return -1
}

// -----------------------






def main_sendvoucher()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    var strUsage1 = "Usage:  sendvoucher  --myacct MY_ASSET_ACCT --hisnym RECIPIENT_NYM_ID\n"
    var strUsage2 = "Server is deduced from MyAcct. This command withdraws AND SENDS the\nvoucher. (Use 'buyvoucher', not 'sendvoucher', if you don't want it to be immediately SENT.)\n"
    var strUsage = concat(strUsage1+"Optionally: --args \"memo \\\"one-line memo allowed here.\\\" amount AMOUNT\"\n", strUsage2)
    
    OT_API_Output(0, strUsage)
    // ------------------------------------    
    if (VerifyExists("MyAcct"))
    {
        var strCheque = ""
        var nReturnVal = details_withdraw_voucher(strCheque)
        // ----------------------------------------------------
        //
        if ((1 == nReturnVal) && VerifyStringVal(strCheque))
        {
            // stderr
            OT_API_Output(0, "\n-------------------------------------------\n the voucher:\n\n")
            // stdout
            print(strCheque)
            // stderr
            OT_API_Output(0, "\n")
            // -----------------------------
            // TODO: Store a copy in outpayments box (OR VERIFY THAT IT'S ALREADY BEING DONE, WHICH I BELIEVE THAT IT IS.)
            // -----------------------------
            var strServerID       = OT_API_Instrmnt_GetServerID(strCheque)
            var strSenderNymID    = OT_API_GetAccountWallet_NymID(MyAcct)
            var strRecipientNymID = OT_API_Instrmnt_GetRecipientUserID(strCheque)
            
            if (!VerifyStringVal(strServerID))
            {
                OT_API_Output(0, "Unable to retrieve a Server ID from this voucher! Very strange. (Failure.)\n")
                return (-1)
            }
            if (!VerifyStringVal(strSenderNymID))
            {
                OT_API_Output(0, "Unable to retrieve a Sender Nym ID from this voucher! Very strange. (Failure.)\n")
                return (-1)
            }
            if (!VerifyStringVal(strRecipientNymID))
            {
                OT_API_Output(0, concat("Unable to retrieve a Recipient Nym ID from this voucher! Very strange. (Failure.)\n(Although ",
                                        "it's fine to WITHDRAW a voucher with no recipient, still need the recipient ID to SEND one.)\n"))
                return (-1)
            }
            // -----------------------------------------------------------
            var strResponse = madeEasy.send_user_payment(strServerID, strSenderNymID, strRecipientNymID, strCheque)
            
            // NOTICE: No need here to deal with retries, timeouts, request number,
            // syncing transaction number, download / process nymbox, etc! It's all
            // handled at a lower level!
            //
            // Instead, simply check for success or failure:
            //
            nReturnVal = VerifyMessageSuccess(strResponse)
            
            if (1 != nReturnVal)
            {
                OT_API_Output(0, "sendvoucher: Failed.\n");
            }
            else
            {
                OT_API_Output(0, "Success in sendvoucher! Server response:\n\n")
                print(strResponse)
                OT_API_Output(0, "(Success in sendvoucher)\n")
                return 1
            }
        }
        
        return nReturnVal
    }
    
    (-1)
}



// -----------------------




def loadMarketList(serverID) 
{
    var vUndefRetVal
    var marketList
    var storable
    
    if (OTDB_Exists("markets", serverID, "market_data.bin", "")) 
    {
        OT_API_Output(1, "Markets file exists...Querying list of markets...\n")
        storable := OTDB_QueryObject(STORED_OBJ_MARKET_LIST, "markets", serverID, "market_data.bin", "")
        
        if (!VerifyStorable(storable, "OTDB_Storable"))
        {
            OT_API_Output(0, "Failed to verify storable object. Probably doesn't exist.\n")
            return vUndefRetVal
        }
        // ------------------------------------------
        OT_API_Output(1, "QueryObject worked. Now dynamic casting from storable to marketlist...\n")
        marketList := OTDB_CAST_MARKET_LIST(storable)
        
        if (!VerifyStorable(marketList, "OTDB_MarketList"))
        {
            OT_API_Output(0, "Unable to dynamic cast a storable to a marketlist.\n")
            return vUndefRetVal
        }
        // ------------------------------------------
        
        return marketList  // success.
    }
    else
    {
        OT_API_Output(0, "The market list file doesn't exist.\n")
        return vUndefRetVal
    }
    // This WAS a "load or create" sort of function, but I commented out the "create" part because
    // you will literally NEVER need to create this list.
    //
//    else 
//    {
//        OT_API_Output(0, "Didn't exist. Creating market list object...\n")
//        storable := OTDB_CreateObject(STORED_OBJ_MARKET_LIST);
//        
//        if (!VerifyStorable(storable))
//        {
//            OT_API_Output(0, "Failed trying to create market list object!\n")
//            return storable  // containing null or undef
//        }
//        
//        OT_API_Output(0, "CreateObject worked. Now dynamic casting from storable to marketlist...\n")
//        marketList := OTDB_CAST_MARKET_LIST(storable)
//        
//        if (!VerifyStorable(marketList))
//        {
//            OT_API_Output(0, "Failed to dynamic cast from storable to marketlist.\n")
//        }
//    }
    
    return vUndefRetVal
}




def main_show_market_list()
{
    if (VerifyExists("Server"))
    {
        var marketList := loadMarketList(Server)
        
        if (!VerifyStorable(marketList, "OTDB_MarketList"))
        {
            OT_API_Output(0, "Unable to load up marketlist from local storage.\n")
            return (-1)
        }
        // ----------------------------------
        
        // LOOP THROUGH THE MARKETS AND PRINT THEM OUT.
        
        var nCount = marketList.GetMarketDataCount()
        var nTemp  = nCount  // this way, nTemp is initialized as a size_t.
        
        if (!VerifyIntVal(nCount))
        {
            OT_API_Output(0, "Loaded the market list, but GetMarketDataCount returns an invalid result. (Failure.)\n")
        }
        else if (!(nCount > 0))
        {
            OT_API_Output(0, "Loaded the market list, but GetMarketDataCount says there aren't any markets in the list. (Returning.)\n")
        }
        else
        {
//          print("\nIndex\tScale\tMarket\tAsset\tCurrency")
            OT_API_Output(0, "\nIndex\tScale\tMarket\t\t\t\t\t\tAsset\t\t\t\t\t\tCurrency\n")
            
            for (var nIndex = 0; nIndex < nCount; ++nIndex)
            {
                nTemp = nIndex // convert nIndex from int to size_t
                var marketData := marketList.GetMarketData(nTemp) // can't pass an int here--it expects size_t. (It'll crash..)
                
                if (!VerifyStorable(marketData, "OTDB_MarketData"))
                {
                    OT_API_Output(0, "Unable to reference marketData on marketList, at index: " + nIndex.to_string() + "\n")
                    return (-1)
                }
                
                // OUTPUT THE MARKET DATA...   
                //
                print(nIndex.to_string() + "\t" + marketData.scale + "\tM " + marketData.market_id + "\tA " + marketData.asset_type_id + "\tC " + marketData.currency_type_id)
            }
        }
        // ------------------------------------------------------
        
        return 1
    }
    
    (-1)
}


def main_get_market_list()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // --------------------------------------------------------------------
    var strUsage = "\n\n USAGE: getmarketlist --server SERVER_ID --mynym YOUR_NYM_ID\n\n"
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {
        // ------------------------------
        // Send the request.
        //
        var strResponse	= madeEasy.get_market_list(Server, MyNym)
        var strAttempt  = "get_market_list"
        // ----------------------------------------------
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        
        // ***************************************************************
        
        var nInterpretReply = VerifyMessageSuccess(strResponse)
        
        if (1 == nInterpretReply)
        {    
            OT_API_Output(0, "Server response ("+strAttempt+"): SUCCESS getting market list.\n\n") 
            
            main_show_market_list()  // if it was successful, then we display the list on the screen.
        }
        
        return nInterpretReply
    }
    
    return (-1)
}











def loadMarketOffers(serverID, marketID) 
{
    var offerList
    var storable
    var vUndefRetVal // for returning "null"
    
    if (OTDB_Exists("markets", serverID, "offers", marketID + ".bin")) 
    {
        OT_API_Output(1, "Offers file exists... Querying file for market offers...\n")
        storable := OTDB_QueryObject(STORED_OBJ_OFFER_LIST_MARKET, "markets", serverID, "offers", marketID + ".bin")
        
        if (!VerifyStorable(storable, "OTDB_Storable"))
        {
            OT_API_Output(0, "Unable to verify storable object. Probably doesn't exist.\n")
            return vUndefRetVal // containing null or undef
        }
        // -----------------------------------------
        OT_API_Output(1, "QueryObject worked. Now dynamic casting from storable to a (market) offerList...\n")
        offerList := OTDB_CAST_OFFER_LIST_MARKET(storable)
        
        if (!VerifyStorable(offerList, "OTDB_OfferListMarket"))
        {
            OT_API_Output(0, "Unable to dynamic cast a storable to a (market) offerList.\n")
            return vUndefRetVal // containing null or undef
        }
    }
    
    return offerList  // possibly containing the offerList (if success), or possibly containing a null/undef value (if failure.)
}



def details_show_market_offers(strServerID, strMarketID)
{
    var offerList := loadMarketOffers(strServerID, strMarketID)
    
    if (!VerifyStorable(offerList, "OTDB_OfferListMarket"))
    {
        OT_API_Output(0, "Unable to load up a (market) offerList from local storage.\n")
        return (-1)
    }
    // ----------------------------------
    // LOOP THROUGH THE BIDS AND PRINT THEM OUT.
    var nBidCount = offerList.GetBidDataCount()  // size_t
    var nTemp     = nBidCount // just so it's created as size_t
    
    if (VerifyIntVal(nBidCount) && (nBidCount > 0))
    {
        OT_API_Output(0, "\n** BIDS **\n\nIndex\tTrans#\tPrice\tAvailable\n")
        
        for (var nIndex = 0; nIndex < nBidCount; ++nIndex)
        {
            nTemp = nIndex
            var offerData := offerList.GetBidData(nTemp)
            
            if (!VerifyStorable(offerData, "OTDB_BidData"))
            {
                OT_API_Output(0, "Unable to reference bidData on offerList, at index: " + nIndex.to_string() + "\n")
                return (-1)
            }
            
            // OUTPUT THE BID OFFER DATA...   
            //
            print(nIndex.to_string() + "\t" + offerData.transaction_id + "\t" + offerData.price_per_scale + "\t" + offerData.available_assets)
        }
    }
    // ----------------------------------
    // LOOP THROUGH THE ASKS AND PRINT THEM OUT.
    var nAskCount = offerList.GetAskDataCount()
    
    if (VerifyIntVal(nAskCount) && (nAskCount > 0))
    {
        OT_API_Output(0, "\n** ASKS **\n\nIndex\tTrans#\tPrice\tAvailable\n")
        
        for (var nIndex = 0; nIndex < nAskCount; ++nIndex)
        {
            nTemp = nIndex
            var offerData := offerList.GetAskData(nTemp)
            
            if (!VerifyStorable(offerData, "OTDB_AskData"))
            {
                OT_API_Output(0, "Unable to reference askData on offerList, at index: " + nIndex.to_string() + "\n")
                return (-1)
            }
            
            // OUTPUT THE ASK OFFER DATA...   
            //
            print(nIndex.to_string() + "\t" + offerData.transaction_id + "\t" + offerData.price_per_scale + "\t" + offerData.available_assets)
        }
    }
    // ------------------------------------------------------
    
    (1)
}




def impl_show_market_offers(strMarket)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // --------------------------------------------------------------------
    var strUsage1 = "\n\n USAGE: showoffers --server SERVER_ID --mynym YOUR_NYM_ID\n"
    var strUsage = concat(strUsage1, "Also: --args \"market MARKET_ID\"\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server"))
    {
        // ------------------------------------        
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (!VerifyStringVal(strMarket) && VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "market MARKET_ID"
            //
            var strNewMarket = OT_CLI_GetValueByKey( Args, "market" ) // the market ID
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewMarket))
            {    strMarket = strNewMarket }
        }            
        // ------------------------------------
        // If the transfer parameters aren't provided, then we
        // ask the user to supply them at the command line.
        //
        if (!VerifyStringVal(strMarket))
        {
            OT_API_Output(0, "Enter the market ID: ")
            strMarket        = OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strMarket))
        {
            return -1
        }
        // ----------------------------------------------  
        
        return details_show_market_offers(Server, strMarket)
    }
    
    return (-1)
}



def main_show_market_offers()
{
    var strMarket
    
    return impl_show_market_offers(strMarket)
}




def main_get_market_offers()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // --------------------------------------------------------------------
    var strUsage1 = "\n\n USAGE: getoffers --server SERVER_ID --mynym YOUR_NYM_ID\n"
    var strUsage = concat(strUsage1, "Also: --args \"market MARKET_ID depth MAX_DEPTH\"\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {
        var strMarket    = ""  // must ultimately be an ID.
        var strDepth     = ""  // can be blank
        // ------------------------------------        
        var strDefaultDepth   = "50"   // can be blank
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "market MARKET_ID depth 50"
            //
            var strNewMarket = OT_CLI_GetValueByKey( Args, "market"    ) // the market ID
            var strNewDepth  = OT_CLI_GetValueByKey( Args, "depth"  )    // how many offers should we retrieve?
            
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewMarket))
            {    strMarket = strNewMarket }
            if (VerifyStringVal(strNewDepth))
            {    strDepth = strNewDepth }
        }            
        // ------------------------------------
        // If the transfer parameters aren't provided, then we
        // ask the user to supply them at the command line.
        //
        if (!VerifyStringVal(strMarket))
        {
            OT_API_Output(0, "Enter the market ID: ")
            strMarket        = OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strDepth))
        {
            OT_API_Output(0, "Optionally, enter a max depth on a single line["+strDepth+"]: ")
            strDepth	= OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strMarket))
        {    return -1  }
        if (!VerifyStringVal(strDepth))
        {    strDepth = strDefaultDepth }
        // ----------------------------------------------    
        // Send the request.
        //
        var strResponse	= madeEasy.get_market_offers(Server, MyNym, strMarket, strDepth)
        var strAttempt  = "get_market_offers"
        // ----------------------------------------------
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        
        // ***************************************************************
        
        var nInterpretReply = VerifyMessageSuccess(strResponse)
        
        if (1 == nInterpretReply)
        {    
            OT_API_Output(0, "Server response ("+strAttempt+"): SUCCESS getting market offers.\n\n") 
            
            impl_show_market_offers(strMarket)  // if it was successful, then we display the list on the screen.
        }
        
        return nInterpretReply
    }
    
    return (-1)
}










def main_adjust_usage_credits()
{
//  def OT_ME::adjust_usage_credits(SERVER_ID, USER_NYM_ID, TARGET_NYM_ID, ADJUSTMENT)
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // --------------------------------------------------------------------
    if (VerifyExists("Server") && VerifyExists("MyNym") && VerifyExists("HisNym"))
    {
        OT_API_Output(0, "Enter the adjustment (positive or negative): ")
        var strAdjustment = OT_CLI_ReadLine()
        
        if (VerifyStringVal(strAdjustment))
        {
            var strResponse = madeEasy.adjust_usage_credits(Server, MyNym, HisNym, strAdjustment)
            var nStatus     = VerifyMessageSuccess(strResponse)            
            // ------------
            // NOTICE: No need here to deal with retries, timeouts, request number,
            // syncing transaction number, download / process nymbox, etc! It's all
            // handled at a lower level!  Instead, simply check for success or failure:
            //
            // -1 is error,
            //  0 is reply received: failure
            //  1 is reply received: success
            //
            switch(nStatus)
            {
                case (1)
                {
                    OT_API_Output(0, "\n\n Server response:\n\n");
                    print(strResponse) // stdout
                    
                    // IF THE_MESSAGE is of command type @usageCredits, and IF it was a SUCCESS,
                    // then this function returns the usage credits BALANCE (it's a long int, but
                    // passed as a string). If you adjusted the balance using the usageCredits
                    // command (THE_MESSAGE being the server's reply to that) then you will see
                    // the balance AFTER the adjustment. (The current "Usage Credits" balance.)
                    //
                    var strNewUsageBalance = OT_API_Message_GetUsageCredits(strResponse)
                    
                    if (!VerifyStringVal(strNewUsageBalance))
                    {
                        strNewUsageBalance = "(Error retrieving usage credits from this server reply.)"
                    }
                    else
                    {
                        OT_API_Output(0, "\n\n SUCCESS in adjust_usage_credits! New usage balance: "+strNewUsageBalance+"\n\n");
                    }
                    break
                }
                case (0)
                {
                    OT_API_Output(0, "\n\nServer response:\n\n");
                    print(strResponse) // stdout
                    OT_API_Output(0, "\n\n FAILURE in adjust_usage_credits!\n\n");
                    break
                }
                default
                {                    
                    if (VerifyStringVal(strResponse))
                    {
                        OT_API_Output(0, "Server response:\n\n")
                        print(strResponse) // stdout
                    }
                    OT_API_Output(0, "\n\nError in adjust_usage_credits! nStatus is: "+nStatus.to_string()+"\n")
                    break
                }
            }
            
            OT_API_Output(0, "\n\n") //stderr
            
            return (0 == nStatus) ? (-1) : nStatus            
        }
    }
    
    (-1)
}





/*
//      pScript->chai.add(fun(&OTDB::OfferDataNym::gui_label),          "gui_label");
        pScript->chai.add(fun(&OTDB::OfferDataNym::valid_from),         "valid_from");
        pScript->chai.add(fun(&OTDB::OfferDataNym::valid_to),           "valid_to");
        pScript->chai.add(fun(&OTDB::OfferDataNym::server_id),          "server_id");
        pScript->chai.add(fun(&OTDB::OfferDataNym::asset_type_id),      "asset_type_id");
        pScript->chai.add(fun(&OTDB::OfferDataNym::asset_acct_id),      "asset_acct_id");
        pScript->chai.add(fun(&OTDB::OfferDataNym::currency_type_id),   "currency_type_id");
        pScript->chai.add(fun(&OTDB::OfferDataNym::currency_acct_id),   "currency_acct_id");
        pScript->chai.add(fun(&OTDB::OfferDataNym::selling),            "selling");
        pScript->chai.add(fun(&OTDB::OfferDataNym::scale),              "scale");
        pScript->chai.add(fun(&OTDB::OfferDataNym::price_per_scale),    "price_per_scale");
        pScript->chai.add(fun(&OTDB::OfferDataNym::transaction_id),     "transaction_id");
        pScript->chai.add(fun(&OTDB::OfferDataNym::total_assets),       "total_assets");
        pScript->chai.add(fun(&OTDB::OfferDataNym::finished_so_far),    "finished_so_far");
        pScript->chai.add(fun(&OTDB::OfferDataNym::minimum_increment),  "minimum_increment");
        pScript->chai.add(fun(&OTDB::OfferDataNym::stop_sign),          "stop_sign");
        pScript->chai.add(fun(&OTDB::OfferDataNym::stop_price),         "stop_price");
        
        OT_CHAI_CONTAINER(OfferListNym, OfferDataNym); 
 */


def details_show_nym_offers(strServerID, strNymID)
{
    var strLocation = "details_show_nym_offers"
    
    var offerList := loadNymOffers(strServerID, strNymID)
    
    if (!VerifyStorable(offerList, "OTDB_OfferListNym"))
    {
        OT_API_Output(0, strLocation+": Unable to load up a (nym) offerList from local storage. Probably doesn't exist.\n")
        return (-1)
    }
    // ----------------------------------
    // LOOP THROUGH THE OFFERS and sort them into a map_of_maps, key is: scale-assetID-currencyID
    // the value for each key is a sub-map, with the key: transaction ID and value: the offer data itself.
    //
    var nCount = offerList.GetOfferDataNymCount() // size_t
    var nTemp  = nCount // so it's created as size_t
    
    if (VerifyIntVal(nCount) && (nCount > 0))
    {        
        var map_of_maps := convert_offerlist_to_maps(offerList)
        
        if (!VerifyType(map_of_maps, "Map"))
        {
            OT_API_Output(0, strLocation+": Unable to convert offer list to map of offers. Perhaps it's empty?\n")
            return (-1)
        }
        // -------------------------------------------        
        // output_nymoffer_data is called for each offer, for this nym,
        // as it iterates through the maps.
        //
        // iterate_nymoffers_maps takes a final parameter extra_vals (not seen here)
        // Other sections in the code which use iterate_nymoffers_maps might pass a value
        // here, or expect one to be returned through the same mechansim.
        //
        var nIterated = iterate_nymoffers_maps(map_of_maps, output_nymoffer_data) // low level. map_of_maps must be good. (assumed.)
        
        if ((-1) == nIterated)
        {
            OT_API_Output(0, strLocation+": Error trying to iterate nym's offers.\n")
            return (-1)
        }        
    }
    
    (1)
}



def main_show_nym_offers()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // --------------------------------------------------------------------
    var strUsage = "\n\n USAGE: showmyoffers --server SERVER_ID --mynym YOUR_NYM_ID\n\n"
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {        
        return details_show_nym_offers(Server, MyNym)
    }
    
    return (-1)
}



def details_get_nym_market_offers(strServerID, strNymID)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    
    var strResponse
    
    // --------------------------------------------------------------------
    if (VerifyStringVal(strServerID) && VerifyStringVal(strNymID))
    {
        // ----------------------------------------------    
        // Send the request.
        //
        strResponse	= madeEasy.get_nym_market_offers(strServerID, strNymID)
        // ----------------------------------------------
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        
        // ***************************************************************
    }
    
    return strResponse
}



def main_get_nym_market_offers()
{
    // --------------------------------------------------------------------
    var strUsage = "\n\n USAGE: getmyoffers --server SERVER_ID --mynym YOUR_NYM_ID\n"
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {        
        // ----------------------------------------------    
        // Send the request.
        //
        var strResponse = details_get_nym_market_offers(Server, MyNym)
        var strAttempt  = "get_nym_market_offers"
        // ----------------------------------------------
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        
        // ***************************************************************
        
        var nInterpretReply = VerifyMessageSuccess(strResponse)
        
        if (1 == nInterpretReply)
        {    
            OT_API_Output(0, "Server response ("+strAttempt+"): SUCCESS getting nym's market offers.\n\n") 
            
            main_show_nym_offers()  // if it was successful, then we display the list on the screen.
        }
        
        return nInterpretReply
    }
    
    return (-1)
}









// ------------------------------
//
// PAY DIVIDEND
//
// Just like withdraw voucher...except instead of withdrawing a single voucher to yourself,
// it removes the total dividend payout from your account, and then divides it up amongst the
// shareholders, sending them EACH a voucher cheque in the amount of strAmount * number of shares owned.
//
def details_pay_dividend(strAmount, strMemo)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    
    // ---------------------------------------------
    // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
    //
    var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
    
    if (!VerifyStringVal(strMyNymID))
    {
        OT_API_Output(0, "\n\nFailure: Unable to find Payer NymID based on myacct. Use: --myacct DIVIDEND_SOURCE_ACCT_ID\n")
        OT_API_Output(0, "The designated asset account (that the dividends will be paid out of) must be yours. OT will find the Nym based on that account.\n\n")
        return (-1)
    }
    // ---------------------------------------------

    var strHisPurse
    
    if (VerifyExists("HisPurse")) // This ID is already validated in the C++ code (in this case.)
    {
        strHisPurse = HisPurse
    }
    else
    {
        while(true)
        {
            OT_API_Output(0, "Enter the SHARES asset type ID (Nym must also be the issuer for these shares): ")
            var strHisPartialPurseID = OT_CLI_ReadLine()
            
            if (VerifyStringVal(strHisPartialPurseID)) // If the user typed something...
            {
                strHisPurse = OT_API_Wallet_GetAssetIDFromPartial(strHisPartialPurseID) // Try to find the associated ID...
                
                if (!VerifyStringVal(strHisPurse)) // But if it returned NULL, failure (return.)
                {
                    OT_API_Output(0, "\n\nFailure: Unable to find SHARES_ASSET_TYPE_ID in your wallet. Use: --hispurse SHARES_ASSET_TYPE_ID\n")
                    return (-1)
                }
                break
            }
        }
    }

    // ***************************************************************
    
    // HERE, WE SEND THE PAY DIVIDEND REQUEST TO THE SERVER
    //
    var strResponse = madeEasy.pay_dividend(Server, strMyNymID, MyAcct, strHisPurse, strMemo, strAmount)
    var strAttempt  = "pay_dividend"
    
//static int payDividend(const std::string SERVER_ID,
//                       const std::string ISSUER_USER_ID,
//                       const std::string DIVIDEND_FROM_ACCT_ID,
//                       const std::string SHARES_ASSET_TYPE_ID,
//                       const std::string DIVIDEND_MEMO,
//                       const std::string AMOUNT_PER_SHARE);
    // ***************************************************************
    
    // HERE, WE INTERPRET THE SERVER REPLY, WHETHER SUCCESS, FAIL, OR ERROR...
    
    var nInterpretReply = InterpretTransactionMsgReply(Server, strMyNymID, MyAcct, strAttempt, strResponse)
    
    if (1 == nInterpretReply) // Success!
    {    
        // ---------------------------------------------------------        
        // Download all the intermediary files (account balance, inbox, outbox, etc)
        // since they have probably changed from this operation.
        //
        var bRetrieved = madeEasy.retrieve_account(Server, strMyNymID, MyAcct, true) //bForceDownload defaults to false.
        OT_API_Output(0, (bRetrieved ? "Success" : "Failed") + " retrieving intermediary files for account.\n")
        // ---------------------------------------------------------
        OT_API_Output(0, "\n\nServer response ("+strAttempt+"): SUCCESS paying out dividends.\n")
    }
    
    return nInterpretReply
}



//static int payDividend(const std::string SERVER_ID,
//                       const std::string ISSUER_USER_ID,
//                       const std::string DIVIDEND_FROM_ACCT_ID,
//                       const std::string SHARES_ASSET_TYPE_ID,
//                       const std::string DIVIDEND_MEMO,
//                       const std::string AMOUNT_PER_SHARE);

// HERE, WE GET ALL THE ARGUMENTS TOGETHER,
// and then call the above function.
//
def main_pay_dividend()
{
    var strUsage1 = concat("\n\n  USAGE: paydividend --server SERVER_ID --mynym SHARES_ISSUER_NYM_ID\n",
                               "             --myacct DIVIDEND_SOURCE_ACCT_ID --hispurse SHARES_ASSET_TYPE_ID\n\n")
    
    var strUsage = concat(strUsage1 + "Also necessary: --args \"amount PAYOUT_AMOUNT_PER_SHARE\"\n",
                          "And OPTIONALLY: --args \"memo \\\"Just a memo for the dividend payment.\\\"\"\n\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server") && VerifyExists("MyAcct"))
    {	
        // strAmount and strNote...
        //
        var strAmount    = "0" // must ultimately be >= 1  (Payout per share.)
        var strNote      = ""  // can be blank
        // ------------------------------------        
        var strDefaultAmount  = "1"  // must be >= 1
        var strDefaultNote    = "(blank memo field)"   // can be blank
        // ------------------------------------
        // If custom arguments have been passed on the command line,
        // then grab them and use them instead of asking the user to enter them
        // at the command line.
        //
        if (VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
            //                                  const std::string str_key)
            // 
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "amount 1"
            // EXAMPLE:  --args "amount 15 memo \"Just a memo for the dividend payout.\""
            //
            var strNewAmount = OT_CLI_GetValueByKey( Args, "amount"    ) // any integer value
            var strNewNote   = OT_CLI_GetValueByKey( Args, "memo"  )     // optional memo field
            
            // ----------------------------------------------
            // Set the values based on the custom arguments, for those found.
            //
            if (VerifyStringVal(strNewAmount))
            {    strAmount = strNewAmount }
            if (VerifyStringVal(strNewNote))
            {    strNote = strNewNote }
        }            
        // ------------------------------------
        // If the transfer parameters aren't provided, then we
        // ask the user to supply them at the command line.
        //
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {
            OT_API_Output(0, "Enter the 'Payout Amount Per-Share' as integer["+strDefaultAmount+"]: ")
            strAmount        = OT_CLI_ReadLine()
        }
        if (!VerifyStringVal(strNote))
        {
            OT_API_Output(0, "Optionally, enter a memo on a single line["+strDefaultNote+"]: ")
            strNote	= OT_CLI_ReadLine()
        }
        // ----------------------------------------------
        if (!VerifyStringVal(strAmount) || (strAmount.to_int() < 1))
        {    strAmount = strDefaultAmount }
        if (!VerifyStringVal(strNote))
        {    strNote = strDefaultNote }
        // ----------------------------------------------    
                
        return details_pay_dividend(strAmount, strNote)
    }
    
    return -1
}

// -----------------------







def main_show_purse()
{
    var strUsage = "\n\n  USAGE: showpurse --mypurse ASSET_TYPE_ID --mynym YOUR_NYM_ID --server SERVER_ID \n\n"    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    if (VerifyExists("Server") && VerifyExists("MyNym") && VerifyExists("MyPurse"))
    {	
        // ------------------------------------
        
        var strPurse = OT_API_LoadPurse(Server, MyPurse, MyNym) // returns NULL, or a purse.

        if (!VerifyStringVal(strPurse))
        {
            OT_API_Output(0, "\n main_show_purse: Unable to load purse. Does it even exist?\n")
        }
        else
        {
            var strAmount = OT_API_Purse_GetTotalValue(Server, MyPurse, strPurse)

            print("\n\nTOTAL VALUE: " + strAmount)
            
            // ---------------------------
            // Loop through purse contents and display tokens.
            var nCount =  OT_API_Purse_Count(Server, MyPurse, strPurse)

            if (!VerifyIntVal(nCount) || (nCount < 0))
            {
                OT_API_Output(0, "\n main_show_purse: Error: Unexpected bad value returned from OT_API_Purse_Count.\n\n")
                return (-1)
            }
            // ----------------------
            
            if (nCount > 0)
            {
                print("Token count: " + nCount.to_string() + "\n")
                print("Index\tValue\tSeries\tValidFrom\tValidTo\t\tStatus")

                var nIndex = -1
                
                while (nCount > 0)
                {
                    --nCount
                    ++nIndex  // on first iteration, this is now 0.
                    // -------------------
                    var strToken = OT_API_Purse_Peek(Server, MyPurse, MyNym, strPurse)
                    
                    if (!VerifyStringVal(strToken))
                    {
                        OT_API_Output(0, "main_show_purse: Error: OT_API_Purse_Peek unexpectedly returned NULL instead of token.\n")
                        return (-1)
                    }
                    // ------------------------------------------
                    
                    var strNewPurse = OT_API_Purse_Pop(Server, MyPurse, MyNym, strPurse)
                    
                    if (!VerifyStringVal(strNewPurse))
                    {
                        OT_API_Output(0, "main_show_purse: Error: OT_API_Purse_Pop unexpectedly returned NULL instead of updated purse.\n")
                        return (-1)
                    }
                    // ------------------------------------------
                    strPurse = strNewPurse
                    // ------------------------------------------
                    var strDenomination = OT_API_Token_GetDenomination(Server, MyPurse, strToken)
                    var nSeries         = OT_API_Token_GetSeries      (Server, MyPurse, strToken)
                    var strValidFrom    = OT_API_Token_GetValidFrom   (Server, MyPurse, strToken)
                    var strValidTo      = OT_API_Token_GetValidTo     (Server, MyPurse, strToken)
                    var strTime         = OT_API_GetTime()
                    // ------------------------------------------
                    if (!VerifyStringVal(strDenomination))
                    {
                        OT_API_Output(0, "Error while showing purse: bad strDenomination.\n")
                        return (-1)
                    }
                    if (!VerifyIntVal(nSeries))
                    {
                        OT_API_Output(0, "Error while showing purse: bad nSeries.\n")
                        return (-1)
                    }
                    if (!VerifyStringVal(strValidFrom))
                    {
                        OT_API_Output(0, "Error while showing purse: bad strValidFrom.\n")
                        return (-1)
                    }
                    if (!VerifyStringVal(strValidTo))
                    {
                        OT_API_Output(0, "Error while showing purse: bad strValidTo.\n")
                        return (-1)
                    }
                    if (!VerifyStringVal(strTime))
                    {
                        OT_API_Output(0, "Error while showing purse: bad strTime.\n")
                        return (-1)
                    }
                    // ------------------------------------------
                    // Output the token...
                    
                    var strStatus = (strTime.to_int() > strValidTo.to_int()) ? "expired" : "valid"
                    
                    print(nIndex.to_string() + "\t" + strDenomination + "\t" + nSeries.to_string() + "\t" + strValidFrom + "\t" + strValidTo + "\t" + strStatus)
                    // ------------------------------------------
                } // while
            } // if nCount > 0
            
            return 1
            
        } // valid purse string was loaded.
        // ------------------------------------
    }
    
    return -1
}








//
//
// THESE FUNCTIONS were added for the PAYMENTS screen. (They are fairly new.)
//
// Basically there was a need to have DIFFERENT instruments, but to be able to
// treat them as though they are a single type.
//
// In keeping with that, the below functions will work with disparate types.
// You can pass [ CHEQUES / VOUCHERS / INVOICES ] and PAYMENT PLANS, and
// SMART CONTRACTS, and PURSEs into these functions, and they should be able
// to handle any of those types.
//
//
//const char * OT_API_Instrmnt_GetAmount(const char * SERVER_ID, const char * THE_INSTRUMENT);
//const char * OT_API_Instrmnt_GetTransNum(const char * SERVER_ID, const char * THE_INSTRUMENT);
//
//const char * OT_API_Instrmnt_GetValidFrom(const char * SERVER_ID, const char * THE_INSTRUMENT);
//const char * OT_API_Instrmnt_GetValidTo(const char * SERVER_ID, const char * THE_INSTRUMENT);
//
//const char * OT_API_Instrmnt_GetMemo(const char * SERVER_ID, const char * THE_INSTRUMENT);
//
//const char * OT_API_Instrmnt_GetAssetID(const char * SERVER_ID, const char * THE_INSTRUMENT);
//
//const char * OT_API_Instrmnt_GetSenderUserID(const char * SERVER_ID, const char * THE_INSTRUMENT);
//const char * OT_API_Instrmnt_GetSenderAcctID(const char * SERVER_ID, const char * THE_INSTRUMENT);
//const char * OT_API_Instrmnt_GetRecipientUserID(const char * SERVER_ID, const char * THE_INSTRUMENT);
//const char * OT_API_Instrmnt_GetRecipientAcctID(const char * SERVER_ID, const char * THE_INSTRUMENT);
//

def details_deposit_cheque(strServerID, strMyAcct, strMyNymID, strInstrument, strType)
{
    var strAssetTypeID = OT_API_Instrmnt_GetAssetID(strInstrument)
    
    if (!VerifyStringVal(strAssetTypeID))
    {
        OT_API_Output(0, "\n\nFailure: Unable to find Asset Type ID on the instrument.\n\n")
        return (-1)
    }
    // ---------------------------------------------    
    if (strAssetTypeID != OT_API_GetAccountWallet_AssetTypeID(strMyAcct))
    {
        OT_API_Output(0, "\n\nFailure: Asset Type ID on the instrument doesn't match the one on the MyAcct.\n\n")
        return (-1)
    }
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()

    // ***************************************************************
    
    // HERE, WE SEND THE TRANSFER REQUEST TO THE SERVER
    //
    var strResponse = madeEasy.deposit_cheque(strServerID, strMyNymID, strMyAcct, strInstrument)
    var strAttempt  = "deposit_cheque"

    // ***************************************************************
    
    // HERE, WE INTERPRET THE SERVER REPLY, WHETHER SUCCESS, FAIL, OR ERROR...
    
    var nInterpretReply = InterpretTransactionMsgReply(strServerID, strMyNymID, strMyAcct, strAttempt, strResponse)
    
    if (1 == nInterpretReply)
    {    
        // Download all the intermediary files (account balance, inbox, outbox, etc)
        // since they have probably changed from this operation.
        //
        var bRetrieved = madeEasy.retrieve_account(strServerID, strMyNymID, strMyAcct, true) //bForceDownload defaults to false.
        
        OT_API_Output(0, "Server response ("+strAttempt+"): SUCCESS!\n")
        OT_API_Output(0, (bRetrieved ? "Success" : "Failed") + " retrieving intermediary files for account.\n")
    }
    
    // ***************************************************************
    //
    // Return status to caller.
    //
    return nInterpretReply

    // --------------------------------------------------------------------
}




def details_deposit_purse(strServerID, strMyAcct, strFromNymID, strInstrument, strType, strIndices)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ---------------------------------------------
    // HERE, WE LOOK UP THE asset type ID, BASED ON THE ACCOUNT ID.
    //
    var strAssetTypeID = OT_API_GetAccountWallet_AssetTypeID(strMyAcct)
    
    if (!VerifyStringVal(strAssetTypeID))
    {
        OT_API_Output(0, "\n\nFailure: Unable to find Asset Type ID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the asset type based on the account.\n\n")
        return (-1)
    }
    // ---------------------------------------------    
    if (VerifyExists("MyPurse", false) && (MyPurse != strAssetTypeID))
    {
        OT_API_Output(0, "Warning: Depositing to MyAcct, which is NOT the same asset type as the MyPurse asset type specified.\n")
    }
    // ---------------------------------------------    
    
    var bLoadedPurse = false
    
    // If strInstrument wasn't passed, that means we're supposed to load 
    // the purse ourselves, from local storage.
    //
    if (!VerifyStringVal(strInstrument))
    {
        // LOAD PURSE
        
        strInstrument = OT_API_LoadPurse(strServerID, strAssetTypeID, strFromNymID) // returns NULL, or a purse.
        
        if (!VerifyStringVal(strInstrument))
        {
            OT_API_Output(0, "\n details_deposit_purse: Unable to load purse from local storage. Does it even exist?\n")
            return (-1)
        }
        
        bLoadedPurse = true
    }
    // ---------------------------------------------    
    // Below this point, we know that strInstrument contains either the purse as it was passed in
    // to us, or it contains the purse as we loaded it from local storage.
    // If it WAS from local storage, then there's a chance that strIndices contains "all" or "4, 6, 2" etc.
    // If that's the case, then we need to iterate through the purse, and add the denoted token IDs to 
    // a vector (selectedTokens) and pass it into depositCashPurse.
    //
    // ---------------------------------------------    
    
    var vecSelectedTokenIDs = Vector()
    
    // If we loaded the purse (vs the user pasting one in...)
    // then the user might have wanted to deposit only selected indices,
    // rather than ALL the tokens in that purse.
    // So we'll loop through the purse and add any relevant IDs to the
    // "selected" list, since the actual Token IDs must be passed.
    //
    if (bLoadedPurse)
    {
        // ---------------------------
        // Loop through purse contents...
        //
        var nCount =  OT_API_Purse_Count(strServerID, strAssetTypeID, strInstrument)
        
        if (!VerifyIntVal(nCount) || (nCount < 0))
        {
            OT_API_Output(0, "\n details_deposit_purse: Error: Unexpected bad value returned from OT_API_Purse_Count.\n\n")
            return (-1)
        }
        // ----------------------
        if (nCount < 1)
        {
            OT_API_Output(0, "\n details_deposit_purse: The purse is empty, so you can't deposit it.\n\n")
            return -1
        }
        // ----------------------
        else //nCount >= 1
        {
            // Make a copy of the purse passed in, so we can iterate it and find the 
            // appropriate Token IDs...
            
            var strPurse = strInstrument
            
            if (VerifyStringVal(strIndices))
            {
                var nIndex   = -1
                
                while (nCount > 0)
                {
                    --nCount
                    ++nIndex  // on first iteration, this is now 0.
                    // -------------------
//                  var strOwner = bPasswordProtected ? "" : strFromNymID
                    
                    // NOTE: Owner can ONLY be strFromNymID in here, since bLoadedPurse
                    // is only true in the case where we LOADED the purse from local storage.
                    // (Therefore this DEFINITELY is not a password-protected purse.)
                    //
                    var strToken = OT_API_Purse_Peek(strServerID, strAssetTypeID,
                                                     strFromNymID,
                                                     strPurse)
                    
                    if (!VerifyStringVal(strToken))
                    {
                        OT_API_Output(0, "details_deposit_purse: Error: OT_API_Purse_Peek unexpectedly returned NULL instead of token.\n")
                        return (-1)
                    }
                    // ------------------------------------------
                    var strNewPurse = OT_API_Purse_Pop(strServerID, strAssetTypeID,
                                                       strFromNymID,
                                                       strPurse)
                    
                    if (!VerifyStringVal(strNewPurse))
                    {
                        OT_API_Output(0, "details_deposit_purse: Error: OT_API_Purse_Pop unexpectedly returned NULL instead of updated purse.\n")
                        return (-1)
                    }
                    // ------------------------------------------
                    strPurse = strNewPurse
                    // ------------------------------------------
                    var strTokenID  =  OT_API_Token_GetID(strServerID, strAssetTypeID, strToken)

                    if (!VerifyStringVal(strTokenID))
                    {
                        OT_API_Output(0, "details_deposit_purse: Error while depositing purse: bad strTokenID.\n")
                        return (-1)
                    }
                    // ------------------------------------------
                    if (!("all" == strIndices) && OT_API_NumList_VerifyQuery(strIndices, nIndex.to_string())) // empty vector should be interpreted already as "all"
                    {
                        vecSelectedTokenIDs.push_back(strTokenID)
                    }
                    // ------------------------------------------
                } // while
            } // if strIndices
        } // if nCount > 0
    }// if (bLoadedPurse)
    // ---------------------------------------------    

    var nResult = depositCashPurse(strServerID, strAssetTypeID, strFromNymID, strInstrument, vecSelectedTokenIDs, strMyAcct)

    return nResult;
    // --------------------------------------------------------------------
}


//case (this.DEPOSIT_CASH)
//{	nRetVal = OT_API_notarizeDeposit(this.serverID, this.nymID, this.accountID, this.strData);	 break; }
//case (this.DEPOSIT_CHEQUE)
//{	nRetVal = OT_API_depositCheque(this.serverID, this.nymID, this.accountID, this.strData);	 break; }
//case (this.DEPOSIT_PAYMENT_PLAN)
//{	nRetVal = OT_API_depositPaymentPlan(this.serverID, this.nymID, this.strData);	 break; }


def details_deposit()
{
    var strInstrument = ""

    // ---------------------------------------------
    // HERE, WE LOOK UP THE recipient NYM ID, BASED ON THE ACCOUNT ID.
    //
    var strToNymID = OT_API_GetAccountWallet_NymID(MyAcct)
    
    if (!VerifyStringVal(strToNymID))
    {
        OT_API_Output(0, "\n\nFailure: Unable to find depositor NymID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
        return (-1)
    }
    // ---------------------------------------------    
    // 
    var strIndices = ""

    if (VerifyExists("Args", false))
    {
        // You have the OPTION to pass in indices for tokens in your purse, and deposit
        // will automatically assume "deposit cash" and deposit those tokens.
        // You can also specify to deposit ALL tokens in your cash purse.
        // Without this extra argument, OT will ask you to paste an instrument,
        // and then will dynamically determine its contract type.
        //
        
        // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
        //                                  const std::string str_key)
        // 
        // OPTION:   --args "key value key value"
        // EXAMPLE:  --args "indices \"4, 6, 9\" "
        // EXAMPLE:  --args "indices \"all\" "
        //
        strIndices = OT_CLI_GetValueByKey(Args, "indices") // OTNumList will be used for this value.        
    }            
    // ----------------------------------------------
    //
    if (VerifyStringVal(strIndices)) // He wants to deposit some or all of his local purse.
    {
        // Only in the case of cash, it's possible you have some cash in Nym A's purse, but
        // you want to deposit it into Nym B's account. So we have a "to" Nym and a "from" Nym
        // even though they will often be the same.
        //
        var strFromNymID = ""
        
        if (VerifyExists("MyNym", false))
        {
            strFromNymID = MyNym
        }
        else
        {
            strFromNymID = strToNymID
        }
        // ---------------------------
        // In this case, strInstrument is blank.
        // That's how the callee knows that we're working with the local purse.
        // Then strIndices tells him either to use "all" tokens in that purse, or
        // the selected indices.
        //
        return details_deposit_purse(Server, MyAcct, strFromNymID, strInstrument, "PURSE", strIndices)
    }
    // ---------------------------------------------    
    
    else // he wants to paste an instrument.
    {
        // 
        OT_API_Output(0, "You can deposit a PURSE (containing cash tokens) or a CHEQUE / VOUCHER. \n")
        OT_API_Output(0, "Paste your financial instrument here, followed by a ~ by itself on a blank line: \n")
        
        strInstrument = OT_CLI_ReadUntilEOF() 
        
        if(!VerifyStringVal(strInstrument))
        {
            return (-1)
        }
        // -----------------------
        
//      const char * OTPayment::_TypeStrings[] = 
//      {
//          // ------------------
//          // OTCheque is derived from OTTrackable, which is derived from OTInstrument, which is
//          // derived from OTScriptable, which is derived from OTContract.
//          // ------------------
//          "CHEQUE",         // A cheque drawn on a user's account.
//          "VOUCHER",        // A cheque drawn on a server account (cashier's cheque aka banker's cheque)
//          "INVOICE",        // A cheque with a negative amount. (Depositing this causes a payment out, instead of a deposit in.)
//          // ------------------
//          "PAYMENT_PLAN",   // An OTCronItem-derived OTPaymentPlan, related to a recurring payment plan.
//          "SMART_CONTRACT", // An OTCronItem-derived OTSmartContract, related to a smart contract.
//          // ------------------
//          "PURSE",          // An OTContract-derived OTPurse containing a list of cash OTTokens.
//          // ------------------
//          "ERROR_STATE"
//      };

        
        var strType = OT_API_Instrmnt_GetType(strInstrument)
        
        if (!VerifyStringVal(strType))
        {
            OT_API_Output(0, "\n\nFailure: Unable to determine instrument type. Expected CHEQUE, VOUCHER, INVOICE, or (cash) PURSE.\n")
            return (-1)
        }
        // ---------------------------------------------    

        switch(strType)
        {
            case ("CHEQUE") 
            {
                return details_deposit_cheque(Server, MyAcct, strToNymID, strInstrument, strType)
            }
            case ("VOUCHER")
            {
                return details_deposit_cheque(Server, MyAcct, strToNymID, strInstrument, strType)
            }
            case ("INVOICE")
            {
                return details_deposit_cheque(Server, MyAcct, strToNymID, strInstrument, strType)
            }
            case ("PURSE")
            {
                return details_deposit_purse(Server, MyAcct, strToNymID, strInstrument, strType, "") // strIndices is left blank in this case
            }
            default
            {
                OT_API_Output(0, "\n\nFailure: Unable to determine instrument type. Expected CHEQUE, VOUCHER, INVOICE, or (cash) PURSE.\n")
                return (-1)
            }
        }
    }
    
    return (-1)
}


def main_deposit()
{                       
    var strUsage1 = "\n\n  USAGE: deposit --myacct YOUR_ACCT_ID --mynym YOUR_NYM_ID --server SERVER_ID \n(OT will ask you to paste the instrument.)\n"    
    var strUsage2 = concat(strUsage1, "Optionally:    --args \"indices \\\"4, 6, 9\\\" \"\n")
    var strUsage3 = concat(strUsage2, "Optionally:    --args \"indices all \"  (To deposit ALL cash tokens in your purse.)\n")
    var strUsage  = concat(strUsage3, "NymID is often determined based on MyAcct.\n If you supply optional indices, they must correspond to tokens in your cash purse.\n\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------        
    
    // A bit complicated:
    //
    // If I specify MyPurse and MyAcct, then they MUST have the same asset type.
    //
    // If I specify MyNym and MyPurse, that is where we will look for the purse.
    //
    // If I specify MyAcct, and it's owned by a different Nym than MyNym, then the cash 
    // tokens will be reassigned from MyNym to MyAcct's Nym, before depositing.
    // Basically ALWAYS look up MyAcct's owner, and set HIM as the recipient Nym.
    // (But still use MyNym, independently, to find the purse being deposited.)
    // 
    // Must ALWAYS specify MyAcct because otherwise, where are you depositing to?
    // 
    // If MyNym isn't available, should use MyAcct's Nym.
    //
    // Shouldn't need to specify MyPurse, since we can ONLY deposit into MyAcct of
    // the same type as MyAcct. Thus we should ignore any other asset types or purses
    // since they couldn't possibly be deposited into MyAcct anyway.
    //
    
    if (VerifyExists("Server") && VerifyExists("MyAcct"))
    {	
        return details_deposit()
    }
    
    return -1
}


/*
 
 const char * OT_API_Instrmnt_GetAmount(const char * THE_INSTRUMENT);
 const char * OT_API_Instrmnt_GetTransNum(const char * THE_INSTRUMENT);
 const char * OT_API_Instrmnt_GetValidFrom(const char * THE_INSTRUMENT);
 const char * OT_API_Instrmnt_GetValidTo(const char * THE_INSTRUMENT);
 const char * OT_API_Instrmnt_GetMemo(const char * THE_INSTRUMENT);
 const char * OT_API_Instrmnt_GetType(const char * THE_INSTRUMENT);
 const char * OT_API_Instrmnt_GetServerID(const char * THE_INSTRUMENT);
 const char * OT_API_Instrmnt_GetAssetID(const char * THE_INSTRUMENT);
 const char * OT_API_Instrmnt_GetSenderUserID(const char * THE_INSTRUMENT);
 const char * OT_API_Instrmnt_GetSenderAcctID(const char * THE_INSTRUMENT);
 const char * OT_API_Instrmnt_GetRecipientUserID(const char * THE_INSTRUMENT);
 const char * OT_API_Instrmnt_GetRecipientAcctID(const char * THE_INSTRUMENT);
 
 
 pScript->chai.add(fun(&OTAPI_Wrap::CreatePurse), "OT_API_CreatePurse");
 pScript->chai.add(fun(&OTAPI_Wrap::CreatePurse_Passphrase), "OT_API_CreatePurse_Passphrase");
 pScript->chai.add(fun(&OTAPI_Wrap::SavePurse), "OT_API_SavePurse");
 pScript->chai.add(fun(&OTAPI_Wrap::Purse_GetTotalValue), "OT_API_Purse_GetTotalValue");
 pScript->chai.add(fun(&OTAPI_Wrap::Purse_Count), "OT_API_Purse_Count");
 pScript->chai.add(fun(&OTAPI_Wrap::Purse_Peek), "OT_API_Purse_Peek");
 pScript->chai.add(fun(&OTAPI_Wrap::Purse_Pop), "OT_API_Purse_Pop");
 pScript->chai.add(fun(&OTAPI_Wrap::Purse_Push), "OT_API_Purse_Push");
 pScript->chai.add(fun(&OTAPI_Wrap::Wallet_ImportPurse), "OT_API_Wallet_ImportPurse");
 pScript->chai.add(fun(&OTAPI_Wrap::exchangePurse), "OT_API_exchangePurse");
 pScript->chai.add(fun(&OTAPI_Wrap::Token_ChangeOwner), "OT_API_Token_ChangeOwner");
 pScript->chai.add(fun(&OTAPI_Wrap::Purse_HasPassword), "OT_API_Purse_HasPassword");

 */

def details_import_cash(strInstrument)
{
    if(!VerifyStringVal(strInstrument))
    {
        return (-1)
    }
    // -----------------------
    var strServerID = OT_API_Instrmnt_GetServerID(strInstrument)
    
    if (!VerifyStringVal(strServerID))
    {
        OT_API_Output(0, "\n\nFailure: Unable to determine server ID from purse.\n")
        return (-1)
    }
    // ---------------------------------------------
    var strAssetID  = OT_API_Instrmnt_GetAssetID (strInstrument)

    if (!VerifyStringVal(strAssetID))
    {
        OT_API_Output(0, "\n\nFailure: Unable to determine asset type ID from purse.\n")
        return (-1)
    }
    // ---------------------------------------------
    var strType = OT_API_Instrmnt_GetType(strInstrument)
    
    if (!VerifyStringVal(strType))
    {
        OT_API_Output(0, "\n\nFailure: Unable to determine instrument type. Expected (cash) PURSE.\n")
        return (-1)
    }
    // ---------------------------------------------
    switch(strType)
    {
        case ("PURSE")
        {
            break
        }
        // Todo: case "TOKEN"
            //
            // NOTE: This is commented out because since it is guessing the NymID as MyNym,
            // then it will just create a purse for MyNym and import it into that purse, and
            // then later when doing a deposit, THAT's when it tries to DECRYPT that token
            // and re-encrypt it to the SERVER's nym... and that's when we might find out that
            // it never was encrypted to MyNym in the first place -- we had just assumed it
            // was here, when we did the import. Until I can look at that in more detail, it
            // will remain commented out.
        default
        {            
//            // This version supports cash tokens (instead of purse...)
//            var bImportedToken = importCashPurse(strServerID, MyNym, strAssetID, userInput, isPurse)
//            
//            if (bImportedToken)
//            {
//                OT_API_Output(0, "\n\n Success importing cash token!\nServer: "+strServerID+"\nAsset Type: "+strAssetID+"\nNym: "+MyNym+"\n\n")
//                return 1
//            }
            
            OT_API_Output(0, "\n\nFailure: Unable to determine instrument type. Expected (cash) PURSE.\n")
            return (-1)
        }
    }
    // ---------------------------------------------
    // This tells us if the purse is password-protected. (Versus being owned
    // by a Nym.)
    var bHasPassword  = OT_API_Purse_HasPassword(strServerID, strInstrument)

    // Even if the Purse is owned by a Nym, that Nym's ID may not necessarily
    // be present on the purse itself (it's optional to list it there.)
    // OT_API_Instrmnt_GetRecipientUserID tells us WHAT the recipient User ID
    // is, IF it's on the purse. (But does NOT tell us WHETHER there is a
    // recipient. The above function is for that.)
    //
    var strPurseOwner
    
    if (!bHasPassword)
    {
        strPurseOwner = OT_API_Instrmnt_GetRecipientUserID(strInstrument) // TRY and get the Nym ID (it may have been left blank.)
    }
    // ---------------------------------------------
    
    // Whether the purse was password-protected (and thus had no Nym ID)
    // or whether it does have a Nym ID (but it wasn't listed on the purse)
    // Then either way, in those cases strPurseOwner will still be NULL.
    // (The third case is that the purse is Nym protected and the ID WAS available,
    // in which case we'll skip this block, since we already have it.)
    // But even in the case where there's no Nym at all (password protected)
    // we STILL need to pass a Signer Nym ID into OT_API_Wallet_ImportPurse.
    // So if it's still NULL here, then we use --mynym to make the call.
    // And also, even in the case where there IS a Nym but it's not listed,
    // we must assume the USER knows the appropriate NymID, even if it's not
    // listed on the purse itself. And in that case as well, the user can
    // simply specify the Nym using --mynym.
    // Bottom line: by this point, if it's still not set, then we just use
    // MyNym, and if THAT's not set, then we return failure.
    if (!VerifyStringVal(strPurseOwner))
    {
        OT_API_Output(0, "\n\n Unable to determine NymID from the purse itself. (It's optional to list the NymID on the purse itself, even though one may nevertheless be expected. Also, the purse may have no owner at all--it may be password-protected instead.) Either way, a signer nym is STILL necessary, even for password-protected purses. Trying MyNym...\n")
        
        if (!VerifyExists("MyNym"))
        {
            return -1
        }
        
        strPurseOwner = MyNym
    }
    // ---------------------------------------------
    var bImported = OT_API_Wallet_ImportPurse(strServerID, strAssetID, strPurseOwner, strInstrument)
    
    if (bImported)
    {
        OT_API_Output(0, "\n\n Success importing purse!\nServer: "+strServerID+"\nAsset Type: "+strAssetID+"\nNym: "+strPurseOwner+"\n\n")
        return 1
    }
    // ---------------------------------------------
    return -1
}






def main_import_cash()
{
    var strUsage1 =               "\n\n  USAGE: importcash   (OT will ask you to paste the instrument.)\n"
    var strUsage2 = concat(strUsage1, "Optionally: importcash --mynym YOUR_NYM_ID\n\n")
    var strUsage3 = concat(strUsage2, "Asset (Purse) ID and ServerID are both deduced from the cash purse that you're importing.\n")
    var strUsage  = concat(strUsage3, "NymID is also deduced, if necessary. (Otherwise, specify using --mynym.)\n\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------
    OT_API_Output(0, "You can import a PURSE (containing cash tokens.)\n")
    OT_API_Output(0, "Paste your financial instrument here, followed by a ~ by itself on a blank line: \n")
    
    var strInstrument = OT_CLI_ReadUntilEOF()
    
    if(!VerifyStringVal(strInstrument))
    {
        return (-1)
    }
    // -----------------------
    return details_import_cash(strInstrument)
}




// MyPurse and HisPurse will call the script even when not found, giving the script
// the opportunity to download the appropriate asset contract from the server, if
// necessary.
//
// Similarly, HisAcct works without being expected to be found in the wallet (since
// maybe it's HIS account and thus it's not IN your wallet...)
//
// Similarly, HisNym will call the script even when not found, giving the script the
// opportunity to download the appropriate pubkey ("check_user" aka "checknym") and
// continue operating.
//
// All of the above, plus Server, ALREADY attempt a partial match search. Therefore,
// it's not necessary to perform ANOTHER partial match, when the value comes from
// --server, --mynym, --hisnym, --mypurse, --hispurse, --myacct, or --hisacct.
//
// You only need to do partial matches when you get values from ELSEWHERE, such as
// from custom arguments, or user-pasted input.
//
// Therefore, add a function for downloading a Nym's pubkey if not already in the wallet,
// and one that downloads an asset contract if not already in the wallet





def details_export_cash(strServerID, strFromNymID, strAssetTypeID, strHisNymID, strIndices, bPasswordProtected)
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    
    // --------------------------------------------------------------------
    // The first three arguments are for loading up the purse we're exporting FROM.
    //
    // Then strHisNymID is for the Nym we're exporting TO (if bPasswordProtected is false.)
    //
    // Then strIndices contains the indices for the tokens to export.
    //
    // Then bPasswordProtected tells us whether to export to strHisNymID,
    // or to create a password-protected purse and export to that instead.
    // (In which case, the purse itself becomes the "owner" and can be passed
    // wherever we would normally pass a NymID as a purse owner.)
    //
    // if bPasswordProtected is false, then strHisNymID needs to contain the recipient Nym.
    // This will contain MyNym by default, if --hisnym wasn't used at the command line.
    //
    // ---------------------------------------------
    var strContract = madeEasy.load_or_retrieve_contract(strServerID, strFromNymID, strAssetTypeID)

    if (!VerifyStringVal(strContract))
    {
        OT_API_Output(0, "\n details_export_cash: Unable to load asset contract: "+strAssetTypeID+"\n")
        return ""
    }
    // ---------------------------------------------
    var bLoadedPurse  = false
    
    var strInstrument = OT_API_LoadPurse(strServerID, strAssetTypeID, strFromNymID) // returns NULL, or a purse.
    
    if (!VerifyStringVal(strInstrument))
    {
        OT_API_Output(0, "\n details_export_cash: Unable to load purse from local storage. Does it even exist?\n")
        return ""
    }
    
    bLoadedPurse = true
    // ---------------------------------------------    
    // Below this point, we know that strInstrument contains the purse as we loaded it from local storage.
    // If it WAS from local storage, then there's a chance that strIndices contains "4, 6, 2" etc.
    // If that's the case, then we need to iterate through the purse, and add the denoted token IDs to 
    // a vector (selectedTokens) and pass it into exportCashPurse.
    // ---------------------------------------------    
    
    var vecSelectedTokenIDs = Vector()
    
    // the user might have wanted to export only selected indices,
    // rather than ALL the tokens in the purse.
    // So we'll loop through the purse and add any relevant IDs to the
    // "selected" list, since the actual Token IDs must be passed.
    //
    if (bLoadedPurse)
    {
        // ---------------------------
        // Loop through purse contents...
        //
        var nCount =  OT_API_Purse_Count(strServerID, strAssetTypeID, strInstrument)
        
        if (!VerifyIntVal(nCount) || (nCount < 0))
        {
            OT_API_Output(0, "\n details_export_cash: Error: Unexpected bad value returned from OT_API_Purse_Count.\n\n")
            return ""
        }
        // ----------------------
        if (nCount < 1)
        {
            OT_API_Output(0, "\n details_export_cash: The purse is empty, so you can't export it.\n\n")
            return ""
        }
        // ----------------------
        else //nCount >= 1
        {
            // Make a COPY of the purse for this loop, so we can iterate it and find the 
            // appropriate Token IDs...
            
            var strPurse = strInstrument
            
            if (VerifyStringVal(strIndices)) // if strIndices is empty, then we send vecSelectedTokenIDs empty as well (which means, "do them all.")
            {
                var nIndex   = -1
                
                while (nCount > 0)
                {
                    --nCount
                    ++nIndex  // on first iteration, this is now 0.
                    // -------------------
                    var strToken = OT_API_Purse_Peek(strServerID, strAssetTypeID, strFromNymID, strPurse)
                    
                    if (!VerifyStringVal(strToken))
                    {
                        OT_API_Output(0, "details_export_cash: Error: OT_API_Purse_Peek unexpectedly returned NULL instead of token.\n")
                        return ""
                    }
                    // ------------------------------------------
                    var strNewPurse = OT_API_Purse_Pop(strServerID, strAssetTypeID, strFromNymID, strPurse)
                    
                    if (!VerifyStringVal(strNewPurse))
                    {
                        OT_API_Output(0, "details_export_cash: Error: OT_API_Purse_Pop unexpectedly returned NULL instead of updated purse.\n")
                        return ""
                    }
                    // ------------------------------------------
                    strPurse = strNewPurse
                    // ------------------------------------------
                    var strTokenID  =  OT_API_Token_GetID(strServerID, strAssetTypeID, strToken)

                    if (!VerifyStringVal(strTokenID))
                    {
                        OT_API_Output(0, "details_export_cash: Error while exporting purse: bad strTokenID.\n")
                        return ""
                    }
                    // ------------------------------------------
//                  bool NumList_VerifyQuery(const std::string str_NumList, const std::string str_Numbers);

                    // If there are no indices, then do them all. (Thus push this one,
                    // as we push every one.)
                    // OR, If there are indices, and the current index is FOUND on the
                    // vector of indices, then we push this one (since it was selected.)
                    //
                    if (!("all" == strIndices) && OT_API_NumList_VerifyQuery(strIndices, nIndex.to_string())) // empty vector should be interpreted already as "all"
                    {
                        vecSelectedTokenIDs.push_back(strTokenID)
                    }
                    // ------------------------------------------
                } // while
            } // if strIndices
            // ------------------------------------------------------------
            var strExportedCashPurse =  exportCashPurse(strServerID, strAssetTypeID, strFromNymID, strInstrument,  vecSelectedTokenIDs, strHisNymID, bPasswordProtected)
            
            return strExportedCashPurse
                        
        } // if nCount > 0
        
    }// if (bLoadedPurse)
    // --------------------------------------------------------------------
    return ""
}



def main_export_cash()
{
    var strUsage1 = "\n\n  USAGE: exportcash --mypurse ASSET_TYPE_ID --mynym YOUR_NYM_ID --hisnym RECIPIENT_NYM_ID --server SERVER_ID\n"
    var strUsage2 = concat(strUsage1, "Optionally:    --args \"indices \\\"4, 6, 9\\\" \"\n")
    var strUsage3 = concat(strUsage2, "Optionally:    --args \"passwd true\"  (To create a password-protected purse.)\n\n")
    var strUsage4 = concat(strUsage3, "(If you create a password-protected purse, then HisNym will be ignored and can be left out.)\n")
    var strUsage  = concat(strUsage4, "If you supply optional indices, they must correspond to tokens in your cash purse.\n\n")
    
    OT_API_Output(0, strUsage)
    // ------------------------------------
    if (VerifyExists("Server") && VerifyExists("MyNym") && VerifyExists("MyPurse"))
    {
        var strIndices = ""
        var bPasswordProtected = false
        
        if (VerifyExists("Args", false))
        {
            // std::string OT_CLI_GetValueByKey(const std::string str_Args,
            //                                  const std::string str_key)
            //
            // OPTION:   --args "key value key value"
            // EXAMPLE:  --args "indices \"4, 6, 9\" "
            // EXAMPLE:  --args "indices \"all\" "
            //
            strIndices = OT_CLI_GetValueByKey(Args, "indices") // OTNumList will be used for this value.
            
            var strPasswordProtected = OT_CLI_GetValueByKey(Args, "passwd")
            
            if (VerifyStringVal(strPasswordProtected) && ("true" == strPasswordProtected))
            {
                bPasswordProtected = true
            }
        }
        // ----------------------------------------------
        var strHisNym = MyNym  // default export is to your own Nym.
        
        if (!bPasswordProtected && VerifyExists("HisNym", false))
        {
            OT_API_Output(0, "HisNym was provided at the command line.\nDo you wish to export this cash to HisNym instead of MyNym?\n\n")
            OT_API_Output(0, "HisNym is: "+HisNym+"\n MyNym is: "+MyNym+"\n\n Type yes to use HisNym, or no to use MyNym.[no]: ")
            
            var strAnswer  = OT_CLI_ReadLine()
            
            if (VerifyStringVal(strAnswer) && (("y" == strAnswer) || ("yes" == strAnswer)))
            {
                strHisNym = HisNym
            }
        }
        // -------------------------------
        
        var strServerID      = Server  // so it makes a copy. (Partial ID processing will alter the variable internally here, and that will fail with Server since it's a global constant.)
        var strMyNymID       = MyNym   // Same reason.
        var strMyPurse       = MyPurse // Same reason.
        
        var strExportedPurse = details_export_cash(strServerID, strMyNymID, strMyPurse, strHisNym, strIndices, bPasswordProtected)
        
        if (VerifyStringVal(strExportedPurse))
        {
            print("\n"+strExportedPurse+"\n") // stdout
            OT_API_Output(0, "Success exporting cash purse!\n\n") // stderr
            return 1 // Success!
        }
    }
    
    return -1
}








def main_new_symmetric_key()
{
	var strKey = OT_API_CreateSymmetricKey()
    
	if (VerifyStringVal(strKey))
	{
		// stderr
		OT_API_Output(0, "\n")
        
		// stdout
		print(strKey)
        
		// stderr
		OT_API_Output(0, "\n")
		
		return 1
    }
    
    // "return value"
    -1
}





// Show an individual payment in detail.
//
def main_payinvoice()
{
    var strUsage1 = "\nUsage:  payinvoice --myacct FROM_ACCT --args \"index INVOICE_INDEX\" \n"
    var strUsage2 = "The invoice and myacct must both have same asset type. If an index is not\n"
    var strUsage  = strUsage1 + strUsage2 + "specified, then OT will ask you to paste an invoice.\n\n"
    
    OT_API_Output(0, strUsage)
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    // SHOW PAYMENTS INBOX
    // 
    // Load an asset account's payments inbox from local storage and display it on the screen.
    //
    if (!VerifyExists("MyAcct"))
    {
        return (-1)
    }
    // --------------------------------------------------------------------
    // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
    //
    var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
    
    if (!VerifyStringVal(strMyNymID))
    {
        OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
        return (-1)
    }
    // ---------------------------------------------
    // HERE, WE LOOK UP THE SERVER ID, BASED ON THE ACCOUNT ID.
    //
    var strServerID = OT_API_GetAccountWallet_ServerID(MyAcct)
    
    if (!VerifyStringVal(strServerID))
    {
        OT_API_Output(0, "Failure: Unable to find Server ID based on myacct. Use: --myacct ACCT_ID\n")
        OT_API_Output(0, "The designated asset account must be yours. OT will find the Server based on the account.\n\n")
        return (-1)
    }
    // ***************************************************************
    var nIndex   = (-1)

    if (VerifyExists("Args"))
    {
        // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
        //                                  const std::string str_key)
        //
        // OPTION:   --args "key value key value"
        // EXAMPLE:  --args "index 1"
        //
        var strIndex = OT_CLI_GetValueByKey( Args, "index" ) // any integer value
        // ----------------------------------------------
        if (VerifyStringVal(strIndex))
        {    
            var nTempIndex = strIndex.to_int()
            
            if (VerifyIntVal(nTempIndex) && (nTempIndex >= 0))
            {
                nIndex = nTempIndex
            }
        }
    }
    OT_API_Output(0, "\n\n") // stderr
    // ***************************************************************
    var strInbox      = ""
    var strInstrument = ""

    if ((-1) == nIndex) // paste an instrument
    {
        OT_API_Output(0, "Please paste an invoice, followed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        //
        strInstrument = OT_CLI_ReadUntilEOF()
        
        if (!VerifyStringVal(strInstrument))
        {
            OT_API_Output(0, "\n\n Sorry, You must paste an invoice, in order to pay it. Or, specify an index in the\npayments inbox using the option:  --args \"index INDEX_OF_INVOICE\".\n\n")
            return (-1)
        }
    }
    // ------------------------------------------------------------------------
    else // Use an instrument from the payments inbox, since a valid index was provided.
    {
        strInbox = OT_API_LoadPaymentInbox(strServerID, strMyNymID); // Returns NULL, or an inbox.
        
        if (!VerifyStringVal(strInbox))
        {
            OT_API_Output(0, "\n\n OT_API_LoadPaymentInbox Failed.\n\n")
            return (-1)
        }
        else	// Success!
        {
            var nCount = OT_API_Ledger_GetCount(strServerID, strMyNymID, strMyNymID, strInbox)
            
            if (VerifyIntVal(nCount))
            {
                if (nIndex > (nCount - 1))
                {
                    OT_API_Output(0, "Index "+nIndex.to_string()+" out of bounds. (The last index is: " + nCount.to_string() + ". The first is 0.)\n")
                    return (-1)
                }
            }
            // ------------------------------------------------------------------------
            else
            {
                OT_API_Output(0, "Unable to retrieve payments inbox ledger size. (Failure.)\n")
                return (-1)
            }
            // ------------------------------------------------------------------------
//          const char * OT_API_Ledger_GetInstrument(const char * SERVER_ID,
//                                                   const char * USER_ID,
//                                                   const char * ACCOUNT_ID,
//                                                   const char * THE_LEDGER,
//                                                   int nIndex); // returns financial instrument by index of the transaction it's in.
            
            strInstrument = OT_API_Ledger_GetInstrument(strServerID, strMyNymID, strMyNymID, strInbox, nIndex)
            
            if (!VerifyStringVal(strInstrument))
            {
                OT_API_Output(0, "Failed trying to get payment instrument from payments box.\n")
                return (-1)
            }
        }
    }
    // ------------------------------------------------------------------------
    // By this point, strInstrument is a valid string (whether we got it from the payments inbox,
    // or whether we got it from stdin.)
    //
    var strType = OT_API_Instrmnt_GetType(strInstrument)
    
    if ("INVOICE" != strType)
    {
        OT_API_Output(0, "That instrument is not an invoice! (Failure.)  The instrument:\n")
        OT_API_Output(0, strInstrument + "\n\n (This instrument is not an invoice.)\n\n")
        return (-1)
    }
    // ------------------------------------------------------------------------
    // Note: I USED to check the ASSET TYPE ID here, but then I removed it, since
    // details_deposit_cheque() already verifies that (so I don't need to do it twice.)
    //
//  var strInstrumentAssetType  = OT_API_Instrmnt_GetAssetID(strInstrument)
//  var strAccountAssetID       = OT_API_GetAccountWallet_AssetTypeID(MyAcct)
//    
//  if (strInstrumentAssetType != strAccountAssetID)
//  {
//      OT_API_Output(0, "The instrument's asset type ("+strInstrumentAssetType+") doesn't match the account's asset type ("+strAccountAssetID+").\nTry specifying a different account using --myacct ACCT_ID\n")
//      return (-1)
//  }
    // ------------------------------------------------------------------------
    // By this point, we know the invoice has the right asset type for the account
    // we're trying to use (to pay it from.)
    //
    // But we need to make sure the invoice is made out to strMyNymID (or to no one.)
    // Because if it IS endorsed to a Nym, and strMyNymID is NOT that nym, then the
    // transaction will fail. So let's check, before we bother sending it...
    //
    var strRecipientUserID = OT_API_Instrmnt_GetRecipientUserID(strInstrument)
    
    // Not all instruments have a specified recipient. But if they do, let's make
    // sure the Nym matches.
    //
    if (VerifyStringVal(strRecipientUserID) && (strRecipientUserID != strMyNymID))
    {
        OT_API_Output(0, "The invoice is endorsed to a specific recipient ("+strRecipientUserID+") and that doesn't match the account's owner Nym ("+strMyNymID+").\nTry specifying a different account to pay this invoice, using --myacct ACCT_ID \n")
        return (-1)   
    }
    // ------------------------------------------------------------------------
    // At this point I know the invoice isn't made out to anyone, or if it is, it's properly
    // made out to the owner of the account which I'm trying to use to pay the invoice from.
    // So let's pay it!  P.S. strRecipientUserID might be NULL, but strMyNymID is guaranteed
    // to be good.
    // ------------------------------------------------------------------------
//  var strPayeeUserID    = OT_API_Instrmnt_GetSenderUserID    (strInstrument)
//  var strPayeeAcctID    = OT_API_Instrmnt_GetSenderAcctID    (strInstrument)
    // ------------------------------------------------------------------------
    //
    var nPaidInvoice = details_deposit_cheque(strServerID, MyAcct, strMyNymID, strInstrument, strType)

    if (1 == nPaidInvoice) // Success!  (Therefore, remove from payments inbox, and move to record box.)
    {
        // Should I bother moving the invoice from the payments inbox to the record box?
        //
        // Update, TODO: Okay for now, I'm using an API call here (RecordPayment) which moves the invoice.
        // HOWEVER, in the long term, we don't want to do it here. Rather, we want to do it inside OT while
        // it's processesing the server reply for your cheque (invoice) deposit. For example what if there's
        // a network problem and we don't process that reply here now? There'll still be a copy of the reply
        // in the Nymbox and it will still get processed at a future time... and THAT's when we need to move
        // the record, not here. (But this is what we'll do for now.)
        //
        // OT_API_RecordPayment(const OTIdentifier & SERVER_ID,
//                              const OTIdentifier & USER_ID,
//                              bool bIsInbox, // true == payments inbox. false == payments outbox.
//                              int  nIndex)   // removes payment instrument (from payments in or out box) and moves to record box.
//        if (!OT_API_RecordPayment(strServerID, strMyNymID, ))   { }
        //
  // UPDATE:
        /*
         - In my Payments Inbox, there could be a cheque or invoice. Either way, when I deposit the cheque or
         pay the invoice, the chequeReceipt goes back to the signer's asset account's inbox.
         - When he accepts the chequeReceipt (during a processInbox) and WHEN HE GETS THE "SUCCESS" REPLY to that
         processInbox, is when the chequeReceipt should be moved from his inbox to his record box. It MUST be
         done then, inside OT, because the next time he downloads the inbox from the server, that chequeReceipt
         won't be in there anymore! It'll be too late to pass it on to the records.
         - Whereas I, being the recipient of his cheque, had it in my **payments inbox,** and thus upon receipt
         of a successful server-reply to my deposit transaction, need to move it from my payments inbox to my
         record box. (The record box will eventually be a callback so that client software can take over that
         functionality, which is outside the scope of OT. The actual CALL to store in the record box, however
         should occur inside OT.)
         - For now, I'm using the below API call, so it's available inside the scripts. This is "good enough"
         for now, just to get the payments inbox/outbox working for the scripts. But in the long term, I'll need
         to add the hooks directly into OT as described just above. (It'll be necessary in order to get the record
         box working.)
         - Since I'm only worried about Payments Inbox for now, and since I'll be calling the below function
         directly from inside the scripts, how will this work? Incoming cheque or invoice will be in the payments
         inbox, and will need to be moved to recordBox (below call) when the script receives a success reply to
         the depositing/paying of that cheque/invoice.
         - Whereas outoing cheque/invoice is in the Outpayments box, (fundamentally more similar to the outmail
         box than to the payments inbox.) If the cheque/invoice is cashed/paid by the endorsee, **I** will receive
         the chequeReceipt, in MY asset account inbox, and when I accept it during a processInbox transaction,
         the SUCCESS REPLY from the server for that processInbox is where I should actually process that chequeReceipt
         and, if it appears in the outpayments box, move it at that time to the record box. The problem is, I can NOT
         do this much inside the script. To do this part, I thus HAVE to go into OT itself as I just described.
         - Fuck!
         - Therefore I might as well comment this out, since this simply isn't going to work.
         
         - Updated plan:
         1. Inside OT, when processing successful server reply to processInbox request, if a chequeReceipt
         was processed out successfully, and if that chequeReceipt is found inside the outpayments, then
         move it at that time to the record box.
         2. Inside OT, when processing successful server reply to depositCheque request, if that cheque is
         found inside the Payments Inbox, move it to the record box.
         3. As for cash:
         If I SENT cash, it will be in my outpayments box. But that's wrong. Because I can
         never see if the guy cashed it or not. Therefore it should go straight to the record box, when
         sent. AND it needs to be encrypted to MY key, not his -- so need to generate BOTH versions, when
         exporting the purse to him in the FIRST PLACE. Then my version goes straight into my record box and
         I can delete it at my leisure. (If he comes running the next day saying "I lost it!!" I can still
         recover it. But once he deposits it, then the cash will be no good and I might as well archive it
         or destroy it, or whatever I choose to do with my personal records.)
         If I RECEIVED cash, it will be in my payments inbox, and then when I deposit it, and when I process
         the SUCCESSFUL server REPLY to my depositCash request, it should be moved to my record Box.
         4. How about vouchers? If I deposit a voucher, then the "original sender" should get some sort of
         notice. This means attaching his ID to the voucher--which should be optional--and then dropping an
         "FYI" notice to him when it gets deposited. It can't be a normal chequeReceipt because that's used
         to verify the balance agreement against a balance change, whereas a "voucher receipt" wouldn't represent
         a balance change at all, since the balance was already changed when you originally bought the voucher.
         Instead it would probably be send to your Nymbox but it COULD NOT BE PROVEN that it was, since OT currently
         can't prove NOTICE!!
         
         All of the above needs to happen inside OT, since there are many plances where it's the only appropriate
         place to take the necessary action. (Script cannot.)
         
         TODO!!!!!
         
         */

        print ("\n Success paying invoice!\n\n")
        
        return 1
    }
    // ------------------------------------------------------------------------
    
    return -1
}





// Show an individual payment in detail.
//
def main_show_payment()
{
    var strUsage = "\nUsage:  showpayment --args \"index PAYMENT_INDEX showmemo true|false\"\n Default index is 0. Default showmemo is false.\n"

    OT_API_Output(0, strUsage)
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    // SHOW PAYMENTS INBOX
    // 
    // Load an asset account's payments inbox from local storage and display it on the screen.
    //
    
    if (VerifyExists("Server") && VerifyExists("MyNym") && VerifyExists("Args"))
    {	
        
        // std::string OT_CLI_GetValueByKey(const std::string str_Args, 
        //                                  const std::string str_key)
        // 
        // OPTION:   --args "key value key value"
        // EXAMPLE:  --args "index 1"
        //
        var strIndex         = OT_CLI_GetValueByKey( Args, "index"    ) // any integer value
        var strShowLargeMemo = OT_CLI_GetValueByKey( Args, "showmemo"    ) // any integer value
        var nIndex   = 0
        var bShowLargeMemo = false  // Memos aren't normally shown if they contain a newline. But you can force them to show anyway.
        // ----------------------------------------------
        // Set the values based on the custom arguments, for those found.
        //
        if (VerifyStringVal(strShowLargeMemo) && ("true" == strShowLargeMemo))
        {
            bShowLargeMemo = true // now we'll show the memo even if it spans multiple lines.
        }
        // -----------------------------
        if (VerifyStringVal(strIndex))
        {    
            var nTempIndex = strIndex.to_int()
            
            if (VerifyIntVal(nTempIndex) && (nTempIndex >= 0))
            {
                nIndex = nTempIndex
            }
        }
        // ***************************************************************
        
        var strInbox = OT_API_LoadPaymentInbox(Server, MyNym); // Returns NULL, or an inbox.
        
        if (!VerifyStringVal(strInbox))
        {
            OT_API_Output(0, "\n\n OT_API_LoadPaymentInbox: Failed.\n\n")
            return (-1)
        }
        else	// Success!
        {
            OT_API_Output(0, "\n\n") // stderr
//          print(strInbox)          // stdout
            
            var nCount = OT_API_Ledger_GetCount(Server, MyNym, MyNym, strInbox)
            
            if (VerifyIntVal(nCount))
            {
                if (nIndex > (nCount - 1))
                {
                    OT_API_Output(0, "Index out of bounds. (There are " + nCount.to_string() + " indices, starting at 0.\n")
                    return (-1)
                }
                // ------------------------------------------------------------------------
                OT_API_Output(0, "Ind  Amt   Type       Txn#   Memo\n")
                OT_API_Output(0, "---------------------------------\n")
                
                var strInstrument      = OT_API_Ledger_GetInstrument(Server, MyNym, MyNym, strInbox, nIndex)

                if (!VerifyStringVal(strInstrument))
                {
                    OT_API_Output(0, "Failed trying to get payment instrument from payments box.\n")
                    return (-1)
                }
                
                var strTrans           = OT_API_Ledger_GetTransactionByIndex(Server, MyNym, MyNym, strInbox, nIndex)
                var strTransID         = OT_API_Ledger_GetTransactionIDByIndex(Server, MyNym, MyNym, strInbox, nIndex)
                
                var strRefNum          = OT_API_Transaction_GetDisplayReferenceToNum(Server, MyNym, MyNym, strTrans)
                
                var strAmount          = OT_API_Instrmnt_GetAmount(strInstrument)
                var strType            = OT_API_Instrmnt_GetType(strInstrument)
                var strAssetType       = OT_API_Instrmnt_GetAssetID(strInstrument)  // todo: output this.
                var strMemo            = OT_API_Instrmnt_GetMemo(strInstrument)
                var strSenderUserID    = OT_API_Instrmnt_GetSenderUserID(strInstrument)
                var strSenderAcctID    = OT_API_Instrmnt_GetSenderAcctID(strInstrument)
                var strRecipientUserID = OT_API_Instrmnt_GetRecipientUserID(strInstrument)
                var strRecipientAcctID = OT_API_Instrmnt_GetRecipientAcctID(strInstrument)
                
                var strUserID = VerifyStringVal(strSenderUserID) ? strSenderUserID : strRecipientUserID;
                var strAcctID = VerifyStringVal(strSenderAcctID) ? strSenderAcctID : strRecipientAcctID;
                // ------------------------------
                var bUserIDExists  = VerifyStringVal(strUserID)
                var bAcctIDExists  = VerifyStringVal(strAcctID)
                var bAssetIDExists = VerifyStringVal(strAssetType)
                var bMemoExists    = VerifyStringVal(strMemo)
                
                if (bMemoExists && (strMemo.find("\n") >= 0) && !bShowLargeMemo)
                {
                    strMemo = "<too large to display here>"
                }
                else if (bMemoExists)
                {
                    var strTempMemo = "\"" + strMemo + "\""
                    strMemo = strTempMemo
                }
                // ------------------------------
                var strNewlineSeparator = ""
                
                if (bUserIDExists || bAcctIDExists)
                {  strNewlineSeparator = "\n" }
                
                var strSeparator = (!bUserIDExists && !bAcctIDExists && !bAssetIDExists) ? "" : strNewlineSeparator;
                // ------------------------------
                // Set up some symbols to appear or not, 
                // based on whether there is something to show.
                //
                var strUserDenoter   = (bUserIDExists  ? "U:" : "")
                var strUserDenoter2  = (bUserIDExists  ? " - " : "")
                var strAcctDenoter   = (bAcctIDExists  ? "A:" : "")
                var strAcctDenoter2  = (bAcctIDExists  ? " - " : "")
                var strAssetDenoter  = (bAssetIDExists ? "T:" : "")
                var strAssetDenoter2 = (bAssetIDExists ? " - " : "")
                // ------------------------------
                // If we have the user/acct/asset ID, then get the associated name (if that exists.)
                //
                var strUserName     = (bUserIDExists  ? ("\"" + OT_API_GetNym_Name(strUserID) + "\"") : "")
                var strAcctName     = (bAcctIDExists  ? ("\"" + OT_API_GetAccountWallet_Name(strAcctID) + "\"") : "")
                var strAssetName    = (bAssetIDExists ? ("\"" + OT_API_GetAssetType_Name(strAssetType) + "\"") : "")
                
                // Just making sure here that if the string wasn't there, that it's set to 
                // a proper empty string, instead of a null or a "not a value" value.
                //
                if (!VerifyStringVal(strUserName))      { strUserName   = ""; strUserDenoter2  = "" }
                if (!VerifyStringVal(strAcctName))      { strAcctName   = ""; strAcctDenoter2  = "" }
                if (!VerifyStringVal(strAssetName))     { strAssetName  = ""; strAssetDenoter2 = "" }
                
                if ("\"\"" == strUserName)              { strUserName   = ""; strUserDenoter2  = "" }
                if ("\"\"" == strAcctName)              { strAcctName   = ""; strAcctDenoter2  = "" }
                if ("\"\"" == strAssetName)             { strAssetName  = ""; strAssetDenoter2 = "" }
                // ------------------------------
                var strOut1 = nIndex.to_string() + "    "
                var strOut2 = strAmount + (strAmount.size() < 3 ? "    " : "   ")
                var strOut3 = strType
                var strOut4 = strType.size() > 10 ? " " : "    "
                var strOut5 = strTransID + (strTransID.size() < 2 ? "    " : "   ")
                var strOut6 = (bMemoExists ? ( strMemo ) : "") + "\n"
                var strOut7 = strUserDenoter+strUserID + strUserDenoter2 + strUserName + strSeparator
                var strOut8 = strAcctDenoter+strAcctID + strAcctDenoter2 + strAcctName + strSeparator
                var strOut9 = strAssetDenoter+strAssetType + strAssetDenoter2 + strAssetName

                print(strOut1 + strOut2 + strOut3 + strOut4 + strOut5 + strOut6 + strOut7 + strOut8 + strOut9)
                
                print("Instrument:\n" + strInstrument)
                
            } // VerifyIntVal (nCount)
            
//          OT_API_Output(0, "\n\n") // stderr
            return 1
        }        
    }
    return -1
}




def main_show_payments_inbox()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    
    var madeEasy	= OT_ME()
    // ------------------------------
    // SHOW PAYMENTS INBOX
    // 
    // Load an asset account's payments inbox from local storage and display it on the screen.
    //
    
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {	
        // ***************************************************************
        
        var strInbox = OT_API_LoadPaymentInbox(Server, MyNym); // Returns NULL, or an inbox.
        
        if (!VerifyStringVal(strInbox))
        {
            OT_API_Output(0, "\n\n OT_API_LoadPaymentInbox: Failed.\n\n")
            return (-1)
        }
        else	// Success!
        {
            OT_API_Output(0, "\n\n") // stderr
//          print(strInbox)          // stdout
            
            var nCount = OT_API_Ledger_GetCount(Server, MyNym, MyNym, strInbox)
            
            if (VerifyIntVal(nCount))
            {
                OT_API_Output(0, "Show payments inbox...\n")
                OT_API_Output(0, "Ind  Amt   Type      Txn#  Asset_Type\n")
                OT_API_Output(0, "---------------------------------------\n")
                
                for (var nIndex = 0; nIndex < nCount; ++nIndex)
                {
                    var strInstrument      = OT_API_Ledger_GetInstrument(Server, MyNym, MyNym, strInbox, nIndex)

                    if (!VerifyStringVal(strInstrument))
                    {
                        OT_API_Output(0, "Failed trying to get payment instrument from payments box.\n")
                        return (-1)
                    }
                    
                    var strTrans           = OT_API_Ledger_GetTransactionByIndex(Server, MyNym, MyNym, strInbox, nIndex)
                    var strTransID         = OT_API_Ledger_GetTransactionIDByIndex(Server, MyNym, MyNym, strInbox, nIndex)
                    
                    var strRefNum          = OT_API_Transaction_GetDisplayReferenceToNum(Server, MyNym, MyNym, strTrans)
//                  var strAmount          = OT_API_Transaction_GetAmount(Server, MyNym, MyNym, strTrans)
//                  var strType            = OT_API_Transaction_GetType(Server, MyNym, MyNym, strTrans)
//                  var strSenderUserID    = OT_API_Transaction_GetSenderUserID(Server, MyNym, MyNym, strTrans)
//                  var strSenderAcctID    = OT_API_Transaction_GetSenderAcctID(Server, MyNym, MyNym, strTrans)
//                  var strRecipientUserID = OT_API_Transaction_GetRecipientUserID(Server, MyNym, MyNym, strTrans)
//                  var strRecipientAcctID = OT_API_Transaction_GetRecipientAcctID(Server, MyNym, MyNym, strTrans)
                    
//                  var strRefNum          = OT_API_Transaction_GetDisplayReferenceToNum(Server, MyNym, MyNym, strTrans)
                    var strAmount          = OT_API_Instrmnt_GetAmount(strInstrument)
                    var strType            = OT_API_Instrmnt_GetType(strInstrument)
                    var strAssetType       = OT_API_Instrmnt_GetAssetID(strInstrument)  // todo: output this.
                    var strSenderUserID    = OT_API_Instrmnt_GetSenderUserID(strInstrument)
                    var strSenderAcctID    = OT_API_Instrmnt_GetSenderAcctID(strInstrument)
                    var strRecipientUserID = OT_API_Instrmnt_GetRecipientUserID(strInstrument)
                    var strRecipientAcctID = OT_API_Instrmnt_GetRecipientAcctID(strInstrument)
                    
                    var strUserID = VerifyStringVal(strSenderUserID) ? strSenderUserID : strRecipientUserID;
                    var strAcctID = VerifyStringVal(strSenderAcctID) ? strSenderAcctID : strRecipientAcctID;
                    // ------------------------------
                    var bUserIDExists  = VerifyStringVal(strUserID)
                    var bAcctIDExists  = VerifyStringVal(strAcctID)
                    var bAssetIDExists = VerifyStringVal(strAssetType)
                    // ------------------------------
                    var strAssetDenoter = (bAssetIDExists ? " - " : "")
                    // ------------------------------
                    var strAssetName    = (bAssetIDExists ? ("\"" + OT_API_GetAssetType_Name(strAssetType) + "\"") : "")
                    if (!VerifyStringVal(strAssetName))     { strAssetName = ""; strAssetDenoter2 = "" }
                    // ------------------------------
                    var strOut1 = nIndex.to_string() + "    "
                    var strOut2 = strAmount + (strAmount.size() < 3 ? "    " : "   ")
                    var strOut3 = strType
                    var strOut4 = strType.size() > 10 ? " " : "    "
                    var strOut5 = strTransID + (strTransID.size() < 2 ? "    " : "   ")
                    var strOut6 = strAssetType + strAssetDenoter + strAssetName
                    
                    print(strOut1 + strOut2 + strOut3 + strOut4 + strOut5 + strOut6)                    
                } // for
            } // VerifyIntVal (nCount)
            
            return 1
        }        
    }
    return -1
}







def main_show_records()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    // SHOW RECORD BOX
    // 
    // Load an asset account's record box from local storage and display it on the screen.
    //
    
    if (VerifyExists("MyAcct"))
    {	
        // ---------------------------------------------
        // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
        //
        var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
        
        if (!VerifyStringVal(strMyNymID))
        {
            OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
            return (-1)
        }
        // ---------------------------------------------
        // HERE, WE LOOK UP THE SERVER ID, BASED ON THE ACCOUNT ID.
        //
        var strServerID = OT_API_GetAccountWallet_ServerID(MyAcct)
        
        if (!VerifyStringVal(strServerID))
        {
            OT_API_Output(0, "Failure: Unable to find Server ID based on myacct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Server based on the account.\n\n")
            return (-1)
        }
        // ***************************************************************
        
        var strInbox = OT_API_LoadRecordBox(strServerID, strMyNymID, MyAcct); // Returns NULL, or an inbox.
        
        if (!VerifyStringVal(strInbox))
        {
            OT_API_Output(0, "\n\n OT_API_LoadRecordBox: Failed.\n\n")
            return -1
        }
        else	// Success!
        {
            OT_API_Output(0, "\n\n") // stderr
//          print(strInbox)          // stdout
            
            var nCount = OT_API_Ledger_GetCount(strServerID, strMyNymID, MyAcct, strInbox)
            
            if (VerifyIntVal(nCount))
            {
                OT_API_Output(0, "SHOW RECORDS: \n\n")
                OT_API_Output(0, "Ind  Amt  Type        Txn# InRef#|User / Acct\n")
                OT_API_Output(0, "---------------------------------|(from or to)\n")
                
                for (var nIndex = 0; nIndex < nCount; ++nIndex)
                {
                    var strTrans           = OT_API_Ledger_GetTransactionByIndex(strServerID, strMyNymID, MyAcct, strInbox, nIndex)
                    var strTransID         = OT_API_Ledger_GetTransactionIDByIndex(strServerID, strMyNymID, MyAcct, strInbox, nIndex)
                    var strRefNum          = OT_API_Transaction_GetDisplayReferenceToNum(strServerID, strMyNymID, MyAcct, strTrans)
                    var strAmount          = OT_API_Transaction_GetAmount(strServerID, strMyNymID, MyAcct, strTrans)
                    var strType            = OT_API_Transaction_GetType(strServerID, strMyNymID, MyAcct, strTrans)
                    var strSenderUserID    = OT_API_Transaction_GetSenderUserID(strServerID, strMyNymID, MyAcct, strTrans)
                    var strSenderAcctID    = OT_API_Transaction_GetSenderAcctID(strServerID, strMyNymID, MyAcct, strTrans)
                    var strRecipientUserID = OT_API_Transaction_GetRecipientUserID(strServerID, strMyNymID, MyAcct, strTrans)
                    var strRecipientAcctID = OT_API_Transaction_GetRecipientAcctID(strServerID, strMyNymID, MyAcct, strTrans)
                    
                    var strUserID = VerifyStringVal(strSenderUserID) ? strSenderUserID : strRecipientUserID;
                    var strAcctID = VerifyStringVal(strSenderAcctID) ? strSenderAcctID : strRecipientAcctID;
                    
                    var bUserIDExists = VerifyStringVal(strUserID)
                    var bAcctIDExists = VerifyStringVal(strAcctID)
                    
                    var strNewlineSeparator = ""
                    
                    if (bUserIDExists || bAcctIDExists)
                    {  strNewlineSeparator = "\n                                 |" }
                    
                    var strSeparator = (!bUserIDExists && !bAcctIDExists) ? "" : strNewlineSeparator;
                    
                    var strUserDenoter = (bUserIDExists ? "U:" : "")
                    var strAcctDenoter = (bAcctIDExists ? "A:" : "")
                    
                    OT_API_Output(0, nIndex.to_string() + "    ")
                    OT_API_Output(0, strAmount + (strAmount.size() < 3 ? "    " : "   "))
                    OT_API_Output(0, strType)
                    OT_API_Output(0, strType.size() > 10 ? " " : "    ")
                    OT_API_Output(0, strTransID + (strTransID.size() < 2 ? "    " : "   "))
                    OT_API_Output(0, strRefNum + (strRefNum.size() > 2 ? "  " : " ") + "|")
                    OT_API_Output(0, strUserDenoter+strUserID + strSeparator + strAcctDenoter+strAcctID + "\n")
                } // for
            } // VerifyIntVal (nCount)
            
            return 1
        }
    }
    -1
}








def main_show_inbox()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    
    var madeEasy	= OT_ME()
    // ------------------------------
    // SHOW INBOX
    // 
    // Load an asset account's inbox from local storage and display it on the screen.
    //
    
    if (VerifyExists("MyAcct"))
    {	
        // ---------------------------------------------
        // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
        //
        var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
        
        if (!VerifyStringVal(strMyNymID))
        {
            OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
            return (-1)
        }
        // ---------------------------------------------
        // HERE, WE LOOK UP THE SERVER ID, BASED ON THE ACCOUNT ID.
        //
        var strServerID = OT_API_GetAccountWallet_ServerID(MyAcct)
        
        if (!VerifyStringVal(strServerID))
        {
            OT_API_Output(0, "Failure: Unable to find Server ID based on myacct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Server based on the account.\n\n")
            return (-1)
        }
        // ***************************************************************
        
        var strInbox = OT_API_LoadInbox(strServerID, strMyNymID, MyAcct); // Returns NULL, or an inbox.
        
        if (!VerifyStringVal(strInbox))
        {
            OT_API_Output(0, "\n\n OT_API_LoadInbox: Failed.\n\n")
            return -1
        }
        else	// Success!
        {
            OT_API_Output(0, "\n\n") // stderr
//          print(strInbox)          // stdout
            
            var nCount = OT_API_Ledger_GetCount(strServerID, strMyNymID, MyAcct, strInbox)
            
            if (VerifyIntVal(nCount))
            {
                OT_API_Output(0, "SHOW INBOX: \n\n")
                OT_API_Output(0, "Ind  Amt  Type        Txn# InRef#|User / Acct\n")
                OT_API_Output(0, "---------------------------------|(from or to)\n")
                
                for (var nIndex = 0; nIndex < nCount; ++nIndex)
                {
                    var strTrans           = OT_API_Ledger_GetTransactionByIndex(strServerID, strMyNymID, MyAcct, strInbox, nIndex)
                    var strTransID         = OT_API_Ledger_GetTransactionIDByIndex(strServerID, strMyNymID, MyAcct, strInbox, nIndex)
                    var strRefNum          = OT_API_Transaction_GetDisplayReferenceToNum(strServerID, strMyNymID, MyAcct, strTrans)
                    var strAmount          = OT_API_Transaction_GetAmount(strServerID, strMyNymID, MyAcct, strTrans)
                    var strType            = OT_API_Transaction_GetType(strServerID, strMyNymID, MyAcct, strTrans)
                    var strSenderUserID    = OT_API_Transaction_GetSenderUserID(strServerID, strMyNymID, MyAcct, strTrans)
                    var strSenderAcctID    = OT_API_Transaction_GetSenderAcctID(strServerID, strMyNymID, MyAcct, strTrans)
                    var strRecipientUserID = OT_API_Transaction_GetRecipientUserID(strServerID, strMyNymID, MyAcct, strTrans)
                    var strRecipientAcctID = OT_API_Transaction_GetRecipientAcctID(strServerID, strMyNymID, MyAcct, strTrans)
                    
                    var strUserID = VerifyStringVal(strSenderUserID) ? strSenderUserID : strRecipientUserID;
                    var strAcctID = VerifyStringVal(strSenderAcctID) ? strSenderAcctID : strRecipientAcctID;
                    
                    var bUserIDExists = VerifyStringVal(strUserID)
                    var bAcctIDExists = VerifyStringVal(strAcctID)
                    
                    var strNewlineSeparator = ""
                    
                    if (bUserIDExists || bAcctIDExists)
                    {  strNewlineSeparator = "\n                                 |" }
                    
                    var strSeparator = (!bUserIDExists && !bAcctIDExists) ? "" : strNewlineSeparator;
                    
                    var strUserDenoter = (bUserIDExists ? "U:" : "")
                    var strAcctDenoter = (bAcctIDExists ? "A:" : "")
                    
                    OT_API_Output(0, nIndex.to_string() + "    ")
                    OT_API_Output(0, strAmount + (strAmount.size() < 3 ? "    " : "   "))
                    OT_API_Output(0, strType)
                    OT_API_Output(0, strType.size() > 10 ? " " : "    ")
                    OT_API_Output(0, strTransID + (strTransID.size() < 2 ? "    " : "   "))
                    OT_API_Output(0, strRefNum + (strRefNum.size() > 2 ? "  " : " ") + "|")
                    OT_API_Output(0, strUserDenoter+strUserID + strSeparator + strAcctDenoter+strAcctID + "\n")
                } // for
            } // VerifyIntVal (nCount)
            
            return 1
        }
    }
    -1
}








def main_show_outbox()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    
    var madeEasy	= OT_ME()
    // ------------------------------
    // SHOW OUTPUT
    // 
    // Load an asset account's outbox from local storage and display it on the screen.
    //
    
    if (VerifyExists("MyAcct"))
    {	
        // ---------------------------------------------
        // HERE, WE LOOK UP THE NYM ID, BASED ON THE ACCOUNT ID.
        //
        var strMyNymID = OT_API_GetAccountWallet_NymID(MyAcct)
        
        if (!VerifyStringVal(strMyNymID))
        {
            OT_API_Output(0, "Failure: Unable to find NymID based on myacct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Nym based on the account.\n\n")
            return (-1)
        }
        // ---------------------------------------------
        // HERE, WE LOOK UP THE SERVER ID, BASED ON THE ACCOUNT ID.
        //
        var strServerID = OT_API_GetAccountWallet_ServerID(MyAcct)
        
        if (!VerifyStringVal(strServerID))
        {
            OT_API_Output(0, "Failure: Unable to find Server ID based on myacct. Use: --myacct ACCT_ID\n")
            OT_API_Output(0, "The designated asset account must be yours. OT will find the Server based on the account.\n\n")
            return (-1)
        }
        // ***************************************************************
        
        var strOutbox = OT_API_LoadOutbox(strServerID, strMyNymID, MyAcct); // Returns NULL, or an outbox.
        
        if (!VerifyStringVal(strOutbox))
        {
            OT_API_Output(0, "\n\n OT_API_LoadOutbox: Failed.\n\n")
            return -1
        }
        else	// Success!
        {
            OT_API_Output(0, "\n\n") // stderr
//          print(strOutbox)         // stdout
            
            var nCount = OT_API_Ledger_GetCount(strServerID, strMyNymID, MyAcct, strOutbox)
            
            if (VerifyIntVal(nCount))
            {
                OT_API_Output(0, "SHOW OUTBOX: \n\n")
                OT_API_Output(0, "Ind  Amt  Type        Txn# InRef#|User / Acct\n")
                OT_API_Output(0, "---------------------------------|(from or to)\n")
                
                for (var nIndex = 0; nIndex < nCount; ++nIndex)
                {
                    var strTrans           = OT_API_Ledger_GetTransactionByIndex(strServerID, strMyNymID, MyAcct, strOutbox, nIndex)
                    var strTransID         = OT_API_Ledger_GetTransactionIDByIndex(strServerID, strMyNymID, MyAcct, strOutbox, nIndex)
                    var strRefNum          = OT_API_Transaction_GetDisplayReferenceToNum(strServerID, strMyNymID, MyAcct, strTrans)
                    var strAmount          = OT_API_Transaction_GetAmount(strServerID, strMyNymID, MyAcct, strTrans)
                    var strType            = OT_API_Transaction_GetType(strServerID, strMyNymID, MyAcct, strTrans)
                    var strSenderUserID    = OT_API_Transaction_GetSenderUserID(strServerID, strMyNymID, MyAcct, strTrans)
                    var strSenderAcctID    = OT_API_Transaction_GetSenderAcctID(strServerID, strMyNymID, MyAcct, strTrans)
                    var strRecipientUserID = OT_API_Transaction_GetRecipientUserID(strServerID, strMyNymID, MyAcct, strTrans)
                    var strRecipientAcctID = OT_API_Transaction_GetRecipientAcctID(strServerID, strMyNymID, MyAcct, strTrans)
                    
                    var strUserID = strRecipientUserID
                    var strAcctID = strRecipientAcctID
                    
                    var bUserIDExists = VerifyStringVal(strUserID)
                    var bAcctIDExists = VerifyStringVal(strAcctID)
                    
                    var strNewlineSeparator = ""
                    
                    if (bUserIDExists || bAcctIDExists)
                    {  strNewlineSeparator = "\n                                 |" }
                    
                    var strSeparator = (!bUserIDExists && !bAcctIDExists) ? "" : strNewlineSeparator;
                    
                    var strUserDenoter = (bUserIDExists ? "U:" : "")
                    var strAcctDenoter = (bAcctIDExists ? "A:" : "")
                    
                    OT_API_Output(0, nIndex.to_string() + "    ")
                    OT_API_Output(0, strAmount + (strAmount.size() < 3 ? "    " : "   "))
                    OT_API_Output(0, strType)
                    OT_API_Output(0, strType.size() > 10 ? " " : "    ")
                    OT_API_Output(0, strTransID + (strTransID.size() < 2 ? "    " : "   "))
                    OT_API_Output(0, strRefNum + (strRefNum.size() > 2 ? "  " : " ") + "|")
                    OT_API_Output(0, strUserDenoter+strUserID + strSeparator + strAcctDenoter+strAcctID + "\n")
                } // for
            } // VerifyIntVal (nCount)
            
            return 1
        }
    }
    -1
}



def show_mail_message(strMyNymID, nIndex, bShowContents)
{
    var bMailVerified   = OT_API_Nym_VerifyMailByIndex(strMyNymID, nIndex)
    
    if (!VerifyBoolVal(bMailVerified))
    {
        OT_API_Output(0, "Error: bad result from OT_API_Nym_VerifyMailByIndex at Index: " + nIndex.to_string() + "\n")
        return false
    }
    // -------------------------------------------------
    if (!bMailVerified) // 1 meaning OT_TRUE.
    {
        print("UNVERIFIED mail! At index: " + nIndex.to_string())
//      return false
    }
    // -------------------------------------------------
    else
    { print("------------------------------\nVerified mail at index: " + nIndex.to_string()) }
    // -------------------------------------------------
    var strMailServerID = OT_API_GetNym_MailServerIDByIndex(strMyNymID, nIndex)
    var strMailSenderID = OT_API_GetNym_MailSenderIDByIndex(strMyNymID, nIndex)
    var strMailContents = OT_API_GetNym_MailContentsByIndex(strMyNymID, nIndex)
    
    if (VerifyStringVal(strMailSenderID))
    {
        var strName = OT_API_GetNym_Name(strMailSenderID)
        if (!VerifyStringVal(strName)) { strName = "" }
        print("Mail from: " + strMailSenderID + " \""+strName+"\" ")
    }
    if (VerifyStringVal(strMailServerID))
    {
        var strName = OT_API_GetServer_Name(strMailServerID)
        if (!VerifyStringVal(strName)) { strName = "" }
        print("Server ID: " + strMailServerID + " \""+strName+"\" ")
    }
    if (bShowContents && VerifyStringVal(strMailContents))
    {
        print("Contents:\n" + strMailContents + "\n")
    }
    
    return true
}

 
def main_show_mail()
{
    var strUsage = "USAGE:   mail --mynym MY_NYM_ID   (To list all the mail messages for mynym.)\n Also:   mail --args \"index 5\"  (To examine a specific message.)\n\n"
    OT_API_Output(0, strUsage)
    // ----------------------------------
    if (!VerifyExists("MyNym"))
    {
        return (-1)
    }
    // ----------------------------------
    var nCount = OT_API_GetNym_MailCount(MyNym)
    
    if (!VerifyIntVal(nCount))
    {
        OT_API_Output(0, "Error: bad result from OT_API_GetNym_MailCount for Nym: " + MyNym + "\n")
        return (-1)
    }
    // -------------------------------------------------
    if (0 == nCount)
    {
        OT_API_Output(0, "\n(Mail is empty.)\n\n")
        return 0
    }
    // ----------------------------------
    var strIndex = ""
    var nIndex = (-1)

    if (VerifyExists("Args", false))
    {
        // std::string OT_CLI_GetValueByKey(const std::string str_Args,
        //                                  const std::string str_key)
        //
        // OPTION:   --args "key value key value"
        // EXAMPLE:  --args "index 5 "
        //
        strIndex = OT_CLI_GetValueByKey(Args, "index")
        // ----------------------------------------------
        if (VerifyStringVal(strIndex))
        {
            nIndex = strIndex.to_int()
        }
    }
    // ----------------------------------------------
    //
    var nReturnVal = 1
    
    if (nIndex > (-1))
    {
        nReturnVal =  show_mail_message(MyNym, nIndex, true) ? 1 : (-1)
    }
    else
    {
        OT_API_Output(0, "\n Mail contents:\n\n")

        for (nIndex = 0; nIndex < nCount; ++nIndex)
        {
            if (!show_mail_message(MyNym, nIndex, false))
            {
                OT_API_Output(0, "show_mail_message returned false. I'll finish out the loop, but that's weird.\n")
                nReturnVal = (-1)
            }
        }
    }
    return nReturnVal
}

//pScript->chai.add(fun(&OTAPI_Wrap::Nym_RemoveMailByIndex), "OT_API_Nym_RemoveMailByIndex");


// ------------------------------------------------------------------


def show_outmail_message(strMyNymID, nIndex, bShowContents)
{
    var bMailVerified   = OT_API_Nym_VerifyOutmailByIndex(strMyNymID, nIndex)
    
    if (!VerifyBoolVal(bMailVerified))
    {
        OT_API_Output(0, "Error: bad result from OT_API_Nym_VerifyOutmailByIndex at Index: " + nIndex.to_string() + "\n")
        return false
    }
    // -------------------------------------------------
    if (!bMailVerified) // 1 meaning OT_TRUE.
    {
        print("UNVERIFIED sent (outgoing) mail! At index: " + nIndex.to_string() + "\n")
//      return false
    }
    // -------------------------------------------------
    else
    { print("--------------------------------------------------------\nVerified outmail at index: " + nIndex.to_string()) }
    // -------------------------------------------------
    var strMailServerID    = OT_API_GetNym_OutmailServerIDByIndex(strMyNymID, nIndex)
    var strMailRecipientID = OT_API_GetNym_OutmailRecipientIDByIndex(strMyNymID, nIndex)
    var strMailContents    = OT_API_GetNym_OutmailContentsByIndex(strMyNymID, nIndex)
    
    if (VerifyStringVal(strMailRecipientID))
    {
        print("Mail was sent to: " + strMailRecipientID)
    }
    if (VerifyStringVal(strMailServerID))
    {
        print("At server ID: " + strMailServerID)
    }
    if (bShowContents && VerifyStringVal(strMailContents))
    {
        print("Contents:\n" + strMailContents + "\n")
    }
    return true
}


def main_show_outmail()
{
    var strUsage = "USAGE:   outmail --mynym MY_NYM_ID   (To list all the sent mail messages for mynym.)\n Also:   outmail --args \"index 5\"  (To examine a specific message.)\n\n"
    OT_API_Output(0, strUsage)
    // ----------------------------------
    if (!VerifyExists("MyNym"))
    {
        return (-1)
    }
    // ----------------------------------
    var nCount = OT_API_GetNym_OutmailCount(MyNym)
    
    if (!VerifyIntVal(nCount))
    {
        OT_API_Output(0, "Error: bad result from OT_API_GetNym_OutmailCount for Nym: " + MyNym + "\n")
        return (-1)
    }
    // -------------------------------------------------
    if (0 == nCount)
    {
        OT_API_Output(0, "\n(Outmail box is empty.)\n\n")
        return 0
    }
    // -------------------------------------------------
    var strIndex = ""
    var nIndex   = (-1)
    
    if (VerifyExists("Args", false))
    {
        // std::string OT_CLI_GetValueByKey(const std::string str_Args,
        //                                  const std::string str_key)
        //
        // OPTION:   --args "key value key value"
        // EXAMPLE:  --args "index 5 "
        //
        strIndex = OT_CLI_GetValueByKey(Args, "index")
        // ----------------------------------------------
        if (VerifyStringVal(strIndex))
        {
            nIndex = strIndex.to_int()
        }
    }
    // ----------------------------------------------
    var nReturnVal = 1
    
    if (nIndex > (-1))
    {
        nReturnVal = show_outmail_message(MyNym, nIndex, true) ? 1 : (-1)
    }
    else
    {
        for (nIndex = 0; nIndex < nCount; ++nIndex)
        {
            if (!show_outmail_message(MyNym, nIndex, false))
            {
                OT_API_Output(0, "show_outmail_message returned false. I'll finish out the loop, but that's weird.\n")
                nReturnVal = (-1)
            }
        }
    }
    
    return nReturnVal
}

//pScript->chai.add(fun(&OTAPI_Wrap::Nym_RemoveOutmailByIndex), "OT_API_Nym_RemoveOutmailByIndex");



//pScript->chai.add(fun(&OTAPI_Wrap::Nym_RemoveOutpaymentsByIndex), "OT_API_Nym_RemoveOutpaymentsByIndex");

// ------------------------------------------------------------------

//pScript->chai.add(fun(&OTAPI_Wrap::GetNym_OutpaymentsCount), "OT_API_GetNym_OutpaymentsCount");
//pScript->chai.add(fun(&OTAPI_Wrap::GetNym_OutpaymentsContentsByIndex), "OT_API_GetNym_OutpaymentsContentsByIndex");
//pScript->chai.add(fun(&OTAPI_Wrap::GetNym_OutpaymentsRecipientIDByIndex), "OT_API_GetNym_OutpaymentsRecipientIDByIndex");
//pScript->chai.add(fun(&OTAPI_Wrap::GetNym_OutpaymentsServerIDByIndex), "OT_API_GetNym_OutpaymentsServerIDByIndex");

//pScript->chai.add(fun(&OTAPI_Wrap::Nym_VerifyOutpaymentsByIndex), "OT_API_Nym_VerifyOutpaymentsByIndex");




def show_outpayment(strMyNym, nIndex, bShowInFull)
{
    var bMailVerified   = OT_API_Nym_VerifyOutpaymentsByIndex(strMyNym, nIndex)
    
    if (!VerifyBoolVal(bMailVerified))
    {
        OT_API_Output(0, "Error: bad result from OT_API_Nym_VerifyOutpaymentsByIndex at Index: " + nIndex.to_string() + "\n")
        return false
    }
    // -------------------------------------------------
    if (!bMailVerified) // 1 meaning OT_TRUE.
    {
        print("UNVERIFIED sent (outgoing) payment! At index: " + nIndex.to_string())
//      return false
    }
    // ------------------------------------------------------
    else
    { print("\n----------------------------------------------\n(index "+nIndex.to_string()+")" ) }
    // ------------------------------------------------------
    var strMailServerID    = OT_API_GetNym_OutpaymentsServerIDByIndex    (strMyNym, nIndex)
    var strMailRecipientID = OT_API_GetNym_OutpaymentsRecipientIDByIndex (strMyNym, nIndex)
    var strMailContents    = OT_API_GetNym_OutpaymentsContentsByIndex    (strMyNym, nIndex)
    // ------------------------------------------------------
    if (VerifyStringVal(strMailContents))
    {
        var strPaymentAmount    = OT_API_Instrmnt_GetAmount  (strMailContents)
        var strPaymentAssetID   = OT_API_Instrmnt_GetAssetID (strMailContents)
        var strPaymentType      = OT_API_Instrmnt_GetType    (strMailContents)
        // -------------------------------------------------
        var strFormatted        = ""
        var strAssetTypeName    = ""
        // -------------------------------------------------
        var strRecipientString  = ""
        var strServerString     = ""
        // -------------------------------------------------
        if (VerifyStringVal(strMailRecipientID))
        {
            var strName = OT_API_GetNym_Name(strMailRecipientID)
            if (!VerifyStringVal(strName)) { strName = "" }
            strRecipientString = "Payment sent to: " + strMailRecipientID + " \""+strName+"\" "
        }
        if (VerifyStringVal(strMailServerID))
        {
            var strName = OT_API_GetServer_Name(strMailServerID)
            if (!VerifyStringVal(strName)) { strName = "" }
            strServerString = "   At server ID: " + strMailServerID + " \""+strName+"\" "
        }
        // -------------------------------------------------
        if (VerifyStringVal(strPaymentAssetID))
        {
            strAssetTypeName = OT_API_GetAssetType_Name(strPaymentAssetID)
            if (!VerifyStringVal(strAssetTypeName)) { strAssetTypeName = "" }
        }
        else
        {
            strPaymentAssetID = "UNKNOWN_ASSET_ID"
        }
        // -------------------------------------------------
        if (VerifyStringVal(strPaymentAmount))
        {
            var strTempFormat = OT_API_FormatAmount(strPaymentAssetID, strPaymentAmount)
            if (!VerifyStringVal(strTempFormat))  { strTempFormat  = strPaymentAmount }
            if (!VerifyStringVal(strPaymentType)) { strPaymentType = "UNKNOWN_PAYMENT_TYPE" }

            strFormatted = "( "+strPaymentType+": "+strTempFormat+" )"
        }
        else
        {
            strPaymentAmount = "UNKNOWN_PAYMENT_AMOUNT"
        }
        // -------------------------------------------------
        print("         Amount: " + strPaymentAmount  + "  "  + strFormatted )
        print(strRecipientString)
        print("  Of asset type: " + strPaymentAssetID + " \"" + strAssetTypeName + "\" " )
        print(strServerString)
        
        if (bShowInFull)
        {
            print("     Instrument: \n" + strMailContents + "\n")
        }
    }
    else
    {
        OT_API_Output(0, "Error: bad result from OT_API_GetNym_OutpaymentsContentsByIndex at Index: " + nIndex.to_string() + "\n")
        return false
    }
    
    return true
}

def show_outpayment(strMyNym, nIndex)
{
    var bShowInFull = true
    
    show_outpayment(strMyNym, nIndex, bShowInFull)
}

def main_show_outpayment()
{
    var strUsage = "USAGE:   outpayment --mynym MY_NYM_ID --args \"index 5\"   (for example)\nIf no index is specified, all outgoing payments are listed.\n"
    OT_API_Output(0, strUsage)
    // ----------------------------------
    if (!VerifyExists("MyNym"))
    {
        return (-1)
    }
    // ----------------------------------   
    var strIndex = ""
    var nIndex   = (-1)

    if (VerifyExists("Args", false))
    {
        // std::string OT_CLI_GetValueByKey(const std::string str_Args,
        //                                  const std::string str_key)
        //
        // OPTION:   --args "key value key value"
        // EXAMPLE:  --args "index 5 "
        //
        strIndex = OT_CLI_GetValueByKey(Args, "index") // OTNumList will be used for this value.
        
        if (VerifyStringVal(strIndex))
        {
            nIndex = strIndex.to_int()
        }
    }
    // ----------------------------------------------
    //    
    var nCount = OT_API_GetNym_OutpaymentsCount(MyNym)
    
    if (!VerifyIntVal(nCount))
    {
        OT_API_Output(0, "Error: bad result from OT_API_GetNym_OutpaymentsCount for Nym: " + MyNym + "\n")
        return (-1)
    }
    // -------------------------------------------------
    if (0 == nCount)
    {
        OT_API_Output(0, "\nSent (outgoing) payments box is empty.\n\n")
        return 0
    }
    // -------------------------------------------------
    if (!(nIndex < nCount))
    {
        OT_API_Output(0, "\nIndex ("+strIndex+") out of bounds. (Acceptable range is 0 to " + (nCount-1).to_string() + ".)\n\n")
        return 0
    }
    // -------------------------------------------------
    var nReturnVal = 1
    
    if (nIndex > (-1))
    {
        if (!show_outpayment(MyNym, nIndex, true))  { nReturnVal = (-1) }
    }
    else
    {
        OT_API_Output(0, "\n Outgoing payments...\n\n")

        for (nIndex = 0; nIndex < nCount; ++nIndex)
        {
            if (!show_outpayment(MyNym, nIndex, false))  { nReturnVal = (-1) }
        }
    }
    return nReturnVal
}

// ------------------------------------------------------------------




def main_add_server()
{
    OT_API_Output(0, "Please paste a server contract, followed by an EOF or a ~ by itself on a blank line:\n\n")
    
    // The reason we accept the tilde ~ on a blank line by itself, is because
    // the EOF, while it works, causes us not to be able to read any more input
    // from stdin. Stdin is considered "closed" for the duration of the run.
    // So the tilde allows us to read multiple times without closing stdin.
    
    var strContract = OT_CLI_ReadUntilEOF() 
    
    if (!VerifyStringVal(strContract))
    {
        OT_API_Output(0, "\n\n Sorry, You must input a server contract, in order to add it to your wallet.\n\n")
        return (-1)
    }
    // ------------
    
    var bAdded = OT_API_AddServerContract(strContract)
    
    if (false == bAdded)
    {
        OT_API_Output(0, "\n\n Sorry, failed. Are you sure that was a server contract?\n\n")
        return (-1)
    }
    
    OT_API_Output(0, "\n\n Success adding server contract to your wallet.\n\n")
    1
}


def main_add_asset()
{
    OT_API_Output(0, "Please paste a currency contract, followed by an EOF or a ~ by itself on a blank line:\n\n")
    
    // The reason we accept the tilde ~ on a blank line by itself, is because
    // the EOF, while it works, causes us not to be able to read any more input
    // from stdin. Stdin is considered "closed" for the duration of the run.
    // So the tilde allows us to read multiple times without closing stdin.
    
    var strContract = OT_CLI_ReadUntilEOF() 
    
    if (!VerifyStringVal(strContract))
    {
        OT_API_Output(0, "\n\n Sorry, You must input a currency contract, in order to add it to your wallet.\n\n")
        return (-1)
    }
    // ------------
    
    var bAdded = OT_API_AddAssetContract(strContract)
    
    if (false == bAdded)
    {
        OT_API_Output(0, "\n\n Sorry, failed. Are you sure that was an asset contract?\n\n")
        return (-1)
    }
    
    OT_API_Output(0, "\n\n Success adding asset contract to your wallet.\n\n")
    1
}



def main_issue_asset()
{
    // --------------------------------------------------------------------
    // Instantiate the "OT Made Easy" object.
    //
    var madeEasy	= OT_ME()
    // ------------------------------
    
    var strUsage = concat("\n\nUsage: issue_asset.ot --server SERVER_ID --mynym NYM_ID\n\n",
                          "       (NYM_ID must already be the 'contract' key on the new contract.)\n       See create_asset_contract.ot before running this script.\n\n")
    
    OT_API_Output(0, strUsage)
    
    // ----------------------------------------------------
    if (VerifyExists("Server") && VerifyExists("MyNym"))
    {   
        OT_API_Output(0, "Please paste a currency contract, followed by an EOF or a ~ by itself on a blank line:\n\n")
        
        // The reason we accept the tilde ~ on a blank line by itself, is because
        // the EOF, while it works, causes us not to be able to read any more input
        // from stdin. Stdin is considered "closed" for the duration of the run.
        // So the tilde allows us to read multiple times without closing stdin.
        
        var strContract = OT_CLI_ReadUntilEOF() 
        
        if (!VerifyStringVal(strContract))
        {
            OT_API_Output(0, "\n\n Sorry, You must input a currency contract, in order to issue it on an OT server.\n\n")
            return (-1)
        }
        // ------------
        
        var strResponse	= madeEasy.issue_asset_type(Server, MyNym, strContract)
        var nStatus     = VerifyMessageSuccess(strResponse)
        
        // NOTICE: No need here to deal with retries, timeouts, request number,
        // syncing transaction number, download / process nymbox, etc! It's all
        // handled at a lower level!  Instead, simply check for success or failure:
        //
        // -1 is error, 
        //  0 is reply received: failure 
        //  1 is reply received: success
        //
        switch(nStatus)
        {
            case (1)
            {
                OT_API_Output(0, "\n\n SUCCESS in issue_asset! Server response:\n\n");
                print(strResponse) // stdout
                break
            }
            case (0)
            {
                OT_API_Output(0, "\n\n FAILURE in issue_asset! Server response:\n\n");
                print(strResponse) // stdout
                break
            }
            default
            {
                OT_API_Output(0, "\n\nError in issue_asset! nStatus is: "+nStatus.to_string()+"\n")
                
                if (VerifyStringVal(strResponse))
                {
                    OT_API_Output(0, "Server response:\n\n")
                    print(strResponse) // stdout
                }
                break
            }
        }
        OT_API_Output(0, "\n\n") //stderr
        
        return (0 == nStatus) ? (-1) : nStatus
    }
    
    return -1
}































